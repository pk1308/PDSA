{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PDSA","text":""},{"location":"#welcome-to-pdsa","title":"Welcome to PDSA","text":""},{"location":"#pdsa-using-python","title":"PDSA using Python","text":"<p>This is an online textbook for the course Programming, Data Structures and Algorithms using Python (PDSA).</p> <p>Note to students : This book is meant to be used as a reference. You may find content that has not been covered in the video lectures. Likewise, there may be some content that is present in the lectures which is not covered here. Additional content appearing in this book will not be considered for grading. In summary, please refer to chapters that you feel are relevant for the course. But you are under no obligation to read the entire book cover to cover. Interested students are always welcome to read the entire thing!</p>"},{"location":"#index","title":"INDEX","text":"Week Content Summaryand Implementations link 1 Python recap, Why efficiency matters? Open 2 Algorithm analysis: Complexity and Notations, Searching algorithms:- Linear and Binary Search, Sorting algorithms:- Selection, Insertion and Merge Sort Open 3 Quick Sort, Data structures: Python List vs NumPy Array, Linked List, Hashing, Stack,Queue Open 4 Graph algorithms:- Introduction, Graph representation, BFS, DFS, Topological Sorting,Longest Path in DAG Open 5 Graph algorithms:- Shortest Path:- Dijkstra's, Bellman Ford and Floyd-Warshall Algorithm,Minimum Spanning Tree:- Prim's and Kruskal's Algorithm Open 6 Union-Find Data Structure, Data structures: Tree, Heap, Binary Search Tree Open 7 AVL Tree, Greedy Algorithm Open 8 Divide and Conquer Algorithm Open 9 Dynamic programming Open 10 String or Pattern Matching Algorithm and Regular Expressions Open 11 Complexity classes, Flow network and Linear programming"},{"location":"reference/book1/","title":"Book1","text":""},{"location":"reference/book2/","title":"Book2","text":""},{"location":"reference/book3/","title":"Book3","text":""},{"location":"reference/priya_suggestion/","title":"Priya suggestion","text":""},{"location":"week1/Euclid%27s%20Algorithm/","title":"Euclid's Algorithm","text":"<p>Euclid's Algorithm</p> <p>Euclid's Algorithm is an efficient method for finding the greatest common divisor (GCD) of two positive integers. The GCD is the largest number that divides both integers without leaving a remainder.</p> <p>The Algorithm:</p> <ol> <li>Base Case: If one of the numbers is 0, the GCD is the other number.</li> <li>Recursive Step: While the second number is not 0:</li> <li>Divide the larger number by the smaller number and get the remainder.</li> <li>Set the larger number to the previous smaller number.</li> <li>Set the smaller number to the remainder obtained in the previous step.</li> <li>Return: Once the second number becomes 0, the GCD is the value stored in the first number (which was originally the larger number).</li> </ol> <p>Advantages:</p> <ul> <li>Efficient: Euclid's Algorithm has a time complexity of O(log(min(a, b))), where a and b are the two integers. This means it's relatively fast, especially for larger numbers.</li> <li>Simple to understand and implement.</li> </ul> <p>Python Implementation:</p> <pre><code>def gcd(a, b):\n  \"\"\"\n  This function implements Euclid's Algorithm to find the GCD of two positive integers.\n\n  Args:\n      a: The first positive integer.\n      b: The second positive integer.\n\n  Returns:\n      The GCD of a and b.\n  \"\"\"\n\n  a, b = max(a,b) , min(a,b)\n  while b != 0:\n    remainder = a % b\n    a = b\n    b = remainder\n  return a\n\n# Example usage\nnum1 = 97\nnum2 = 2\ngcd_result = gcd(num1, num2)\nprint(f\"The GCD of {num1} and {num2} is: {gcd_result}\")\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n  \"\"\"\n  This function implements Euclid's Algorithm to find the GCD of two positive integers.\n\n  Args:\n      m: The first positive integer.\n      n: The second positive integer.\n\n  Returns:\n      The GCD of m and n.\n  \"\"\"\n    (a, b) = (max(m,n) , min(m,n))\n    print(f\" a: {a} , b:{b}\")\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a%b)\n</code></pre> <p>This code defines a function <code>gcd</code> that takes two positive integers <code>a</code> and <code>b</code> as input and returns their GCD. It uses a loop to implement the recursive steps of Euclid's Algorithm. The example usage demonstrates how to call the function and print the result.</p>"},{"location":"week1/class%26object/","title":"Class&object","text":"<pre><code>class Stack:\n    \"\"\"\n    A Last-In-First-Out (LIFO) data structure implemented using a Python list.\n\n    Attributes:\n        __a (list): The internal list used to store the stack elements.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initializes an empty stack.\n        \"\"\"\n        self.__a = []\n\n    def pop(self):\n        \"\"\"\n        Removes and returns the element at the top of the stack (the last element added).\n\n        Returns:\n            The value at the top of the stack, or -1 if the stack is empty.\n        \"\"\"\n        if self.__a:\n            return self.__a.pop()\n        else:\n            return -1\n\n    def push(self, value):\n        \"\"\"\n        Adds a new element to the top of the stack.\n\n        Args:\n            value: The element to be pushed onto the stack.\n        \"\"\"\n        self.__a.append(value)\n\n    def peek(self):\n        \"\"\"\n        Returns the element at the top of the stack without removing it.\n\n        Returns:\n            The value at the top of the stack, or -1 if the stack is empty.\n        \"\"\"\n        if self.__a:\n            return self.__a[-1]\n        else:\n            return -1\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the stack (useful for debugging).\n\n        Returns:\n            A string representation of the stack contents.\n        \"\"\"\n        return str(self.__a)\n\n    def __dict__(self):\n        \"\"\"\n        Returns a dictionary representing the stack's attributes (for debugging).\n\n        Returns:\n            A dictionary containing the stack's attributes.\n        \"\"\"\n        return self.__dict__\n</code></pre> <pre><code>my_stack = Stack()\n\n# Push elements onto the stack\nmy_stack.push(10)\nmy_stack.push(20)\nmy_stack.push(30)\n\n# Get the top element without removing it\ntop_element = my_stack.peek()\nprint(f\"Top element: {top_element}\")  \n\n# Print the stack contents (for demonstration)\nprint(f\"Stack: {my_stack}\") \n</code></pre> <pre><code>Top element: 30\nStack: [10, 20, 30]\n</code></pre> <pre><code>value_removed = my_stack.pop()\nprint(f\"Valued removed : {value_removed}\")\n# Print the stack contents after removing the element \nprint(f\"Stack: {my_stack}\") \n</code></pre> <pre><code>Valued removed : 30\nStack: [10, 20]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week1/exception_handling/","title":"Exception handling","text":"<p>Exception Handling: Making Your Python Code Robust</p> <p>In Python programming, exceptions are events that disrupt the normal flow of your code's execution. These can arise from various situations, such as:</p> <ul> <li>Division by zero (e.g., <code>10 / 0</code>)</li> <li>Accessing elements outside a list's or array's index range (e.g., <code>my_list[10]</code> when the list has only 5 elements)</li> <li>File-related errors (e.g., trying to open a non-existent file)</li> <li>Network errors (e.g., attempting to connect to a unavailable server)</li> <li>User input errors (e.g., the user enters an invalid value)</li> </ul> <p>If left unhandled, exceptions can cause your program to crash abruptly, leading to a frustrating user experience. Exception handling provides a mechanism to gracefully manage these errors, making your code more robust and user-friendly.</p> <p>Core Constructs: <code>try</code>, <code>except</code>, and <code>finally</code></p> <p>Python offers three primary keywords for exception handling:</p> <ol> <li> <p><code>try</code> block: This block encloses the code that might potentially raise an exception.</p> </li> <li> <p><code>except</code> block: This block follows the <code>try</code> block and specifies how to handle exceptions that occur within the <code>try</code> block. You can have multiple <code>except</code> blocks to catch different types of exceptions:</p> </li> <li> <p>Bare <code>except</code>: Catches any exception type. Use this cautiously, as it can mask more specific errors.</p> </li> <li> <p><code>except ExceptionType</code>: Catches a specific exception type (e.g., <code>except ZeroDivisionError</code>).</p> </li> <li> <p><code>finally</code> block (optional): This block executes unconditionally, whether an exception occurs or not. It's often used for cleanup tasks like closing files or releasing resources.</p> </li> </ol> <p>Example:</p> <pre><code>def calculate_average(numbers):\n    try:\n        total = sum(numbers)\n        average = total / len(numbers)\n        return average\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero. Please provide a non-empty list.\")\n    finally:\n        print(\"Calculation completed.\")\n\n# Example usage\nnumbers = [1, 2, 3]\nresult = calculate_average(numbers)\nprint(result)  # Output: 2.0\n\nnumbers = []\nresult = calculate_average(numbers)  # Output: Error: Cannot divide by zero. Please provide a non-empty list.\n                                    #          Calculation completed.\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>calculate_average</code> function takes a list of numbers.</li> <li>The <code>try</code> block attempts to calculate the average.</li> <li>If a <code>ZeroDivisionError</code> occurs (division by zero), the corresponding <code>except</code> block prints an error message.</li> <li>The <code>finally</code> block always executes, regardless of exceptions, and prints a completion message.</li> </ul> <p>Key Points:</p> <ul> <li>Use specific exception types in <code>except</code> blocks for targeted handling.</li> <li><code>finally</code> is useful for essential cleanup tasks.</li> <li>Consider using <code>else</code> after the <code>try</code> block to execute code if no exception occurs.</li> <li>For more complex scenarios, you can nest <code>try...except</code> blocks.</li> </ul> <p>By effectively incorporating exception handling into your Python code, you can create more reliable and user-friendly applications.</p> <p>Python provides a rich set of built-in exceptions that cover various error conditions. Here's a comprehensive list of some common exceptions you'll encounter:</p> <p>Base Exceptions:</p> <ul> <li><code>BaseException</code>: The root class for all built-in exceptions. It's not meant to be directly used.</li> </ul> <p>Standard Exceptions:</p> <ul> <li><code>ArithmeticError</code>: Raised when an error occurs in arithmetic operations (e.g., division by zero).</li> <li><code>AssertionError</code>: Raised when an <code>assert</code> statement fails.</li> <li><code>AttributeError</code>: Raised when an attribute reference or assignment fails.</li> <li><code>EOFError</code>: Raised when <code>input()</code> hits the end-of-file (EOF) condition.</li> <li><code>FloatingPointError</code>: Raised when a result is too large or too small for a floating-point representation.</li> <li><code>GeneratorExit</code>: Raised when <code>next()</code> is called on a generator that has finished executing.</li> <li><code>ImportError</code>: Raised when importing a module fails.</li> <li><code>IndexError</code>: Raised when the index of a sequence is out of range.</li> <li><code>KeyError</code>: Raised when a key is not found in a dictionary.</li> <li><code>KeyboardInterrupt</code>: Raised when the user interrupts the program with Ctrl+C or Delete.</li> <li><code>LookupError</code>: Raised when a lookup operation (e.g., <code>x in y</code>) fails. This is the base class for <code>IndexError</code> and <code>KeyError</code>.</li> <li><code>MemoryError</code>: Raised when an operation runs out of memory.</li> <li><code>NameError</code>: Raised when a variable is not found in local or global scope.</li> <li><code>NotImplementedError</code>: Raised when an abstract method or requested operation isn't implemented.</li> <li><code>OSError</code>: Raised when a system-related operation causes an error. This is the base class for numerous OS-specific exceptions.</li> <li><code>OverflowError</code>: Raised when the result of an arithmetic operation is too large to be represented.</li> <li><code>RuntimeError</code>: Raised when some error occurs during runtime that doesn't fall into another category.</li> <li><code>StopIteration</code>: Raised by the <code>next()</code> function when there are no more elements in an iterator.</li> <li><code>SyntaxError</code>: Raised when a syntax error (invalid code) is encountered.</li> <li><code>SystemError</code>: Raised when an internal interpreter error occurs.</li> <li><code>SystemExit</code>: Raised by the <code>sys.exit()</code> function to exit the program.</li> <li><code>TabError</code>: Raised when inconsistent tabs and spaces are used for indentation.</li> <li><code>TypeError</code>: Raised when an operation or function receives an argument of an inappropriate type.</li> <li><code>ValueError</code>: Raised when an operation or function receives an argument that has an invalid value.</li> <li><code>Warning</code>: The base class for warning exceptions. It's not an error, but indicates a potential problem.</li> </ul> <p>Custom Exceptions:</p> <p>You can also define your own custom exceptions by subclassing the <code>Exception</code> class. This allows you to create specific exceptions for your application's needs.</p> <p>Remember that this list covers the most common built-in exceptions. The Python documentation provides a more exhaustive reference: https://docs.python.org/3/library/exceptions.html</p>"},{"location":"week1/p_session/","title":"P session","text":"<pre><code>def shuffle(first_list : list , second_list : list )-&gt; list :\n\n    first_list_len , second_list_len = len(first_list) , len(second_list)\n\n    max_len = 0 \n    result = []\n    while max_len &lt; max(first_list_len, second_list_len) :\n        if max_len &lt; first_list_len:\n            result.append(first_list[max_len])\n        if max_len &lt; second_list_len:\n            result.append(second_list[max_len])\n        max_len+=1\n    return result\n</code></pre> <pre><code>def expanding(list_to_check : list ) -&gt; bool:\n\n    current_difference = -float(\"inf\")\n\n    for index in range(len(list_to_check)-1):\n        temp_difference = abs(list_to_check[index+1]-list_to_check[index])\n        if current_difference &gt;= temp_difference:\n            return False\n        else:\n            current_difference = temp_difference\n    return True \n</code></pre> <pre><code>L = [1,3,7,2,-3]\n</code></pre> <pre><code>expanding(L)\n</code></pre> <pre><code>2 3 1\n4 7 3\n5 2 7\n5 -3 2\n***************************\n5 -3 2\n\n\n\n\n\nFalse\n</code></pre> <pre><code>def sumsquare(list_of_value : list)-&gt; list:\n\n    odd = 0 \n    even = 0\n    for value in list_of_value:\n        if value%2==0:\n            even+= value**2\n        else:\n            odd += value**2\n    return [odd, even]\n</code></pre> <pre><code># write code here\ndef histogram(list_of_value : list )-&gt; list:\n    result_dic = {}\n    for i in list_of_value:\n        if i in result_dic:\n            result_dic[i]+=1\n        else:\n            result_dic[i] = 1 \n    return sorted(result_dic.items(), key=lambda item: (item[1], item[0]))\n</code></pre> <pre><code>histogram([7,12,11,13,7,11,13,14,12])\n</code></pre> <pre><code>[(14, 1), (7, 2), (11, 2), (12, 2), (13, 2)]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week1/ta_session_06_06/","title":"Ta session 06 06","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>25**.5==int(25)**0.5\n</code></pre> <pre><code>True\n</code></pre> <pre><code>def h(n):\n    return n**0.5 == int(n)**0.5\n</code></pre> <pre><code>h(24)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>24**0.5\n</code></pre> <pre><code>4.898979485566356\n</code></pre> <pre><code>int(24)**0.5\n</code></pre> <pre><code>4.898979485566356\n</code></pre> <pre><code>def fun(m,n):\n    if m==n:\n        return n \n    else:\n        if m &gt; n:\n            return fun(m=m-n, n =n )\n        else:\n            return fun(m , n-m)\n</code></pre> <pre><code>fun(25,100)\n</code></pre> <pre><code>25\n</code></pre> <pre><code>def fun(N):\n    total  = 0 \n    for i in range(N//2, N ):\n        j = 2\n        while (j &lt;=N):\n            total = total + N/2\n            j = j * 2 \n    return total \n</code></pre> <pre><code>fun(1024)\n</code></pre> <pre><code>2621440.0\n</code></pre> <pre><code>import math \n</code></pre> <pre><code>(1024**2 * math.log2(1024) )/4\n</code></pre> <pre><code>2621440.0\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week1/time_it/","title":"Time it","text":"<pre><code>import time \n\nstart_time = time.perf_counter()\n</code></pre> <pre><code>end_time = time.perf_counter()\n</code></pre> <pre><code>start_time- end_time\n</code></pre> <pre><code>-0.250828417003504\n</code></pre> <pre><code>class TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None \n        self._stop_time = None \n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None \n    def elapsed(self):\n        if self.elapsed == None and self._start_time== None:\n            raise TimerError(\"the counter not running\")\n        elif self.elapsed == None and self._start_time != None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n    def __str__(self) -&gt; str:\n        return (str(self.elapsed_time))\n</code></pre> <pre><code>timer_obj =  TimerError()\n\nfor i in range(4,10):\n    timer_obj.start()\n    for j in range(10**i):\n        pass \n    print(f\" i: {i} time taken {timer_obj.elapsed()}\")\n</code></pre> <pre><code> i: 4 time taken 0.00022252700000535697\n i: 5 time taken 0.0022203449916560203\n i: 6 time taken 0.01746416199603118\n i: 7 time taken 0.14385948498966172\n i: 8 time taken 1.4716057649930008\n i: 9 time taken 14.134486352995737\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n    (a, b) = (max(m,n) , min(m,n))\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a-b)\ntimer_obj.start()\ngcd(9000,2)\ntimer_obj.elapsed()\n</code></pre> <pre><code>2.4133012630045414e-05\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n    (a, b) = (max(m,n) , min(m,n))\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a%b)\ntimer_obj.start()\ngcd(9000,2)\ntimer_obj.elapsed()\n</code></pre> <pre><code>2.3304994101636112e-05\n</code></pre>"},{"location":"week2/TA_session1/","title":"TA session1","text":"<pre><code>class Solution(object):\n    def answerQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        from bisect import bisect_right\n        nums.sort()\n        prefix_sums = []\n        for num in nums:\n            prefix_sums.append(num + (prefix_sums[-1] if prefix_sums else 0))\n\n        answer = []\n        for query in queries:\n            idx = bisect_right(prefix_sums, query)\n            answer.append(idx)\n\n        return answer\n</code></pre> <pre><code>num = [4,5,2,1]\nqueries = [3,10,21]\n</code></pre> <pre><code>x = Solution()\nx.answerQueries(num, queries)\n</code></pre> <pre><code>[2, 3, 4]\n</code></pre> <pre><code>class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        max_value = 0\n        max_count = 0 \n        dict_value = {}\n        for value in nums:\n            if value in dict_value:\n                dict_value[value]+=1\n            else:\n                dict_value[value]=1\n        result = []\n        for  key, values in dict_value.items():\n            if values == k:\n                result.append(key)\n        return result \n</code></pre> <pre><code>z = Solution()\nz.topKFrequent(nums=[1,1,1,2,2,3], k = 2)\n</code></pre> <pre><code>[2]\n</code></pre> <pre><code>test = {1:2 , 4:5}\n</code></pre> <pre><code>max(list(test.values()))\n</code></pre> <pre><code>5\n</code></pre> <pre><code>[7]*7\n</code></pre> <pre><code>[7, 7, 7, 7, 7, 7, 7]\n</code></pre> <pre><code>class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        test = {}\n        for value in nums:\n            if value in test:\n                test[value]+=1\n            else:\n                test[value]=1\n        result = []\n\n        for order in range(3):\n            occurrence = test.get(order)\n\n            result.extend([order]*occurrence)\n\n        return result\n</code></pre> <pre><code>x = Solution()\n\nx.sortColors([2,0,2,1,1,0])\n</code></pre> <pre><code>[0, 0, 1, 1, 2, 2]\n</code></pre> <pre><code>class Solution:\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n\n        intervals.sort(key=lambda x: x[0])  # Sort by starting point\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] &lt; interval[0]:\n                merged.append(interval)  # No overlap, add directly\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])  # Merge overlapping intervals\n\n        return merged\n</code></pre> <pre><code>x = Solution()\n\nx.merge([[1,4],[0,2],[3,5]])\n</code></pre> <pre><code>[[0, 5]]\n</code></pre> <pre><code>intervals= [[1,4],[0,2],[3,5]]\nintervals.sort()\n\nintervals\n</code></pre> <pre><code>[[0, 2], [1, 4], [3, 5]]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/grpa/","title":"Grpa","text":"<pre><code>def sort_list(L: list ):\n    if len(L) == 0:\n        return []\n    midpoint = len(L)//2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\ndef sort_list_descending(L: list) -&gt; list:\n    if len(L) == 0:\n        return []\n    midpoint = len(L)//2\n    mid_value = L[midpoint]\n    first_list = [first for first in L if int(first[1:]) &gt; int(mid_value[1:])]\n    mid_list = [mid for mid in L if int(mid[1:]) == int(mid_value[1:])]\n    last_list = [last for last in L if int(last[1:]) &lt; int(mid_value[1:])]\n    return sort_list_descending(first_list) + mid_list + sort_list_descending(last_list)\n\ndef combinationSort(strList: list) -&gt; list:\n    ascending_list , descending_list = [] , []\n    master_dict = {}\n\n    for value in strList:\n        if value[0] in master_dict:\n            master_dict[value[0]].append(value)\n        else:\n            master_dict[value[0]] = [value]\n    sorted_keys = sort_list(list(master_dict.keys()))\n    for keys in sorted_keys:\n        value_to_add = master_dict.get(keys)\n        ascending_list.extend(value_to_add)\n        if len(value_to_add) &gt; 1:\n            descending_list.extend(sort_list_descending(value_to_add))\n        else:\n            descending_list.extend(value_to_add)\n\n\n\n    return ascending_list , descending_list \n</code></pre> <pre><code>mast_dict = combinationSort([\"d34\", \"g54\", \"d12\", \"b87\", \"g1\", \"c65\", \"g40\", \"g5\", \"d77\"])\n</code></pre> <pre><code>mast_dict\n</code></pre> <pre><code>(['b87', 'c65', 'd34', 'd12', 'd77', 'g54', 'g1', 'g40', 'g5'],\n ['b87', 'c65', 'd77', 'd34', 'd12', 'g54', 'g40', 'g5', 'g1'])\n</code></pre> <pre><code>L = ['g54', 'g1', 'g40', 'g5']\n</code></pre> <pre><code>midpoint = len(L)//2\nmid_value = L[midpoint]\nfirst_list = [first for first in L if int(first[1:]) &gt; int(mid_value[1:])]\nmid_list = [mid for mid in L if int(mid[1:]) == int(mid_value[1:])]\nlast_list = [last for last in L if int(last[1:]) &lt; int(mid_value[1:])]\n</code></pre> <pre><code>first_list\n</code></pre> <pre><code>['g54']\n</code></pre> <pre><code>mid_list\n</code></pre> <pre><code>['g40']\n</code></pre> <pre><code>last_list\n</code></pre> <pre><code>['g1', 'g5']\n</code></pre> <pre><code>def findLargest(L):\n    left , right = 0 , len(L)-1\n    if len(L) ==1:\n        return L[0]\n\n    largest = -1 \n    while left &lt; right:\n        midpoint = L[(left+right)//2]\n        largest = max(largest, L[left], L[right] , midpoint)  # Update largest if temp is greater\n\n        if midpoint &gt; L[left] :\n            left = (left+right)//2+1\n        else:\n            right = (left+right)//2-1\n    return largest\n</code></pre> <pre><code>L =[7 ,8 ,2 ,4 ,5 ,6]\n</code></pre> <pre><code>findLargest(L)\n</code></pre> <pre><code>8\n</code></pre> <pre><code>L =[2 , 4 , 5 ,7 ,9]\n</code></pre> <pre><code>findLargest(L)\n</code></pre> <pre><code>9\n</code></pre> <pre><code>left , right = 0 , len(L)-1\n</code></pre> <pre><code>largest = -1 \n</code></pre> <pre><code>left , right\n</code></pre> <pre><code>(3, 2)\n</code></pre> <pre><code>midpoint = L[(left+right)//2]\nlargest = max(largest, L[left], L[right] , midpoint)  # Update largest if temp is greater\nlargest\n</code></pre> <pre><code>9\n</code></pre> <pre><code>if midpoint &gt; L[left] :\n            left = (left+right)//2+1\nelse:\n    right = (left+right)//2-1\n</code></pre> <pre><code>def selectionsort(L : list) -&gt; list :\n    number_of_elements = len(L)\n    if number_of_elements&lt;= 1:\n        return L\n    for i in range(number_of_elements):\n        index_to_sort = i \n        for j in range(i+1, number_of_elements):\n            if L[j] &lt; L[index_to_sort]:\n                L[j] , L[index_to_sort] = L[index_to_sort] , L[j]\n    return L\n</code></pre> <pre><code>selectionsort(L)\n</code></pre> <pre><code>[2, 4, 5, 7, 9]\n</code></pre> <pre><code>\n</code></pre> <pre><code>class MyList:\n    def __init__(self, data):\n        self.data = data\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, index):\n        return self.data[index]\n\n    def swap(self, indexA, other, indexB):\n        if isinstance(other, MyList):\n            self.data[indexA], other.data[indexB] = other.data[indexB], self.data[indexA]\n        else:\n            self.data[indexA], self.data[other] = self.data[other], self.data[indexA]\n</code></pre> <pre><code>def mergeInPlace(first_list , second_list):\n    len_of_first , len_of_second = len(first_list) , len(second_list)\n    pointer_first , pointer_second = 0, 0 \n\n    while pointer_first &lt; len_of_first and pointer_second &lt; len_of_second:\n        if first_list[pointer_first] &lt;= second_list[pointer_second]:\n            pointer_first+=1 \n        else:\n            first_list.swap(pointer_first, second_list, pointer_second)\n        # temp pointer to sorted second list \n        k = pointer_second\n        while k &lt; len_of_second-1 and second_list[k] &gt; second_list[k+1]:\n            second_list.swap(k, second_list, k+1)\n            k+=1\n        pointer_first+=1\n    return first_list , second_list    \n</code></pre> <pre><code>def mergeInPlace(first_list , second_list):\n    len_of_first , len_of_second = len(first_list) , len(second_list)\n    for first_index in range(len_of_first):\n        for second_index in range(len_of_second):\n            if first_list[first_index] &gt; second_list[second_index]:\n                first_list.swap(first_index, second_list, second_index)\n    for second_index in range(len_of_second):\n        for j in range(second_index+1, len_of_second):\n            if second_list[second_index] &gt; second_list[j]:\n                second_list.swap(second_index, second_list, j)\n    return first_list , second_list    \n</code></pre> <pre><code>A = MyList([2,4 ,6 ,9 ,13 ,15])\nB = MyList([1 ,3 ,5 ,10])\nmergeInPlace(A, B)\nprint(A.data)  # Output: [1, 2, 3]\nprint(B.data)  # Output: [4, 5, 6]\n</code></pre> <pre><code>[1, 2, 3, 4, 5, 6]\n[9, 10, 13, 15]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/insert_sort_2_6/","title":"Insert sort 2 6","text":"<pre><code>from loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\n# lg.add(sys.stdout, colorize=True)\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:21:09.423[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m37[0m - [1mtime taken:1.105800038203597e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 100) for i in range(1000)]\nV = random.randint(1, 100)\n</code></pre>"},{"location":"week2/insert_sort_2_6/#insertion-sort","title":"insertion sort","text":"<pre><code>def insertion_sort(L):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm.\n\n    Args:\n        L (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(L)\n\n    # If the list has 1 or fewer elements, it is already sorted\n    if n &lt;= 1:\n        return L\n\n    # Iterate through each element in the list\n    for i in range(n):\n        j = i\n\n        # Mo value_to_inserte the element at index j towards the beginning of the list\n        # until it's in the correct sorted position\n        while j &gt; 0 and L[j] &lt; L[j - 1]:\n            # Swap the current element with the prevalue_to_insertalue_to_insertious one if it's smaller\n            L[j], L[j - 1] = L[j - 1], L[j]\n            j -= (\n                1  # Decrement j to movalue_to_inserte towards the beginning of the list\n            )\n\n    return L\n</code></pre> <pre><code>T = TimerError()\nT.start()\ninsertion_sort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:47:10.805[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:0.014249863976147026[0m\n</code></pre> \\[ \\begin{gather*} outer\\ loop\\ =\\ n\\ \\\\ inner\\ loop\\ =\\ \\frac{n( n-1)}{2}\\\\ \\\\ complexity\\ =\\ O\\left( n^{2}\\right) \\end{gather*}\\] <pre><code>def Insert(List_to_sort, Value_to_insert):\n    \"\"\"\n    Inserts a value into a sorted list while maintaining the sorted order.\n\n    Args:\n        List_to_sort (list): The sorted list to insert the value into.\n        Value_to_insert (Any): The value to insert into the list.\n\n    Returns:\n        list: The sorted list after inserting the value.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list is empty, simply return the value as a single-element list\n    if n == 0:\n        return [Value_to_insert]\n\n    # If the value is greater than or equal to the last element in the list,\n    # append it to the end of the list\n    if Value_to_insert &gt;= List_to_sort[-1]:\n        return List_to_sort + [Value_to_insert]\n    else:\n        # Recursively insert the value into the sublist List_to_sort[:-1]\n        # and then append the last element of List_to_sort to the result\n        return Insert(List_to_sort[:-1], Value_to_insert) + List_to_sort[-1:]\n\n\ndef ISort(List_to_sort):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm recursively.\n\n    Args:\n        List_to_sort (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list has less than 1 element, it is already sorted\n    if n &lt; 1:\n        return List_to_sort\n\n    # Recursively sort the sublist List_to_sort[:-1]\n    # and then insert the last element of List_to_sort into the sorted sublist\n    L = Insert(ISort(List_to_sort[:-1]), List_to_sort[-1])\n\n    return L\n</code></pre> <pre><code>T = TimerError()\nT.start()\nISort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:49:07.900[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:0.003761364030651748[0m\n</code></pre> <p>$$ \\begin{gather*}</p> <p>complexity\\ =\\ O\\left( n^{2}\\right) \\end{gather*}$$</p>"},{"location":"week2/lec2.1/","title":"Lec2.1","text":"<p>Sim card vs Aadhar card example</p> <ul> <li>Naive</li> <li>smarter approach</li> </ul> <p>Main resources of interest</p> <ul> <li>running time</li> <li>space</li> </ul> <p>Time is depends on the processing power.</p> <ul> <li>10^6 operation for python</li> </ul> <p>Storage is limited by available.</p> <p>Running time depends on the input size.</p> <p>we will be measure time efficiency as a function of input size.</p> <ul> <li>input size n</li> <li>Running Time  t(n)</li> </ul> <p>$$ \\begin{array}{l} data\\ avaiable\\ of\\ Aadhaar\\ -\\ n\\ \\approx \\ 10^{9}\\ -\\ Naive\\ algorithin\\ t( n) \\ =\\ n^{2}\\</p> <p>-\\ clever\\ algo\\ t( n) \\ \\approx \\ n\\ \\log_{2} n \\end{array} $$</p> <p>Asymptotyic complexity</p> <ul> <li>means we will be ingonring the coinstants in the function as we will be looking at large value of n (input value )</li> <li>When comparingt(n), focus on orders of magnitudeIgnore constant factors.</li> </ul> <p></p> <p>Typically a natural parameter</p> <ul> <li>side of the list or array - sort / search</li> <li>number of objects we want to re arrange</li> <li>for graphs we will have two parameter</li> <li>vertices</li> <li>number of edge</li> </ul> <p>numeric problem </p> <ul> <li>magnitude of n is not the correct measure</li> <li>Arithmetic operations are performed digit by digitAddition with carry, subtraction with borrow, multiplication, long division .</li> </ul> <p>Ideally, want the \u201caverage\u201d behaviour</p> <ul> <li>Difficult to compute Average over what?</li> <li>Are all inputs equally likely?</li> <li>Need a probability distribution over inputs</li> </ul> <p>Instead, worst case input</p> <ul> <li>Input that forces algorithm to take longest possible time</li> <li>Search for a value that is not present in an unsorted list</li> <li>Must scan all elements</li> <li>Pessimistic \u2014 worst case may be rare</li> <li>Upper bound for worst case guarantees good performance.</li> </ul>"},{"location":"week2/lec2_2/","title":"Comparing Orders of Magnitude.","text":""},{"location":"week2/lec2_2/#comparing-orders-of-magnitude","title":"Comparing Orders of Magnitude.","text":"<p>f(x) is said to be O(g(x)) if we can find constants c and x0 such that c\u00b7g(x) is an upper bound forf(x) for x beyond x0 f(x)\u2264cg(x) </p> <p>pending -  greek and latin</p>"},{"location":"week2/lec2_3/","title":"Lec2 3","text":"<pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n</code></pre> <pre><code>class TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(1000000)]\n</code></pre> <pre><code>\n</code></pre> <pre><code>def MaxELement(L):\n    time = TimerError()\n    time.start()\n    maxval = L[0]\n    for i in range(len(L)):\n        if L[i] &gt; maxval:\n            maxval = L[i]\n    end_time = time.elapsed()\n    lg.info(f\"time take \\n {end_time}\")\n    return maxval\n</code></pre> <pre><code>MaxELement(L)\n</code></pre> <pre><code>[32m2024-05-08 15:07:43.327[0m | [1mINFO    [0m | [36m__main__[0m:[36mMaxELement[0m:[36m9[0m - [1mtime take \n 0.01241532398853451[0m\n\n\n\n\n\n999999798\n</code></pre>"},{"location":"week2/lec2_3/#input-size-n","title":"input size = N","text":"\\[ Overall\\ time\\ =\\ 0( n) \\]"},{"location":"week2/lec2_3/#example-2","title":"Example 2","text":"<pre><code>def noDuplicates(L):\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if L[i] == L[j]:\n                return False\n    return True\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = noDuplicates(L)\nlg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.224[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m4[0m - [1mFalse[0m\n[32m2024-05-08 15:07:46.225[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 2.88110359798884[0m\n</code></pre> <p>Time is</p> <p>$$</p> <p>  $$</p>"},{"location":"week2/lec2_3/#example-3","title":"Example 3","text":"<p>Matrix multiplication </p> <pre><code>def matrix_Multiplication(A, B):\n    (m, n, p) = (len(A), len(B), len(B[0]))\n    C = [[0 for i in range(p)] for j in range(m)]\n    for i in range(m):\n        for j in range(p):\n            for k in range(n):\n                C[i][j] = C[i][j] + A[i][k] * B[k][j]\n    return C\n</code></pre> <pre><code>m, n = 100, 1001\n</code></pre> <pre><code>A = [[random.randint(1, 100) for _ in range(n)] for j in range(m)]\nB = [[random.randint(1, 100) for _ in range(m)] for j in range(n)]\n</code></pre> <pre><code>len(A[0]), len(B)\n</code></pre> <pre><code>(1001, 1001)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = matrix_Multiplication(A, B)\n# lg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.752[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 0.4464707520091906[0m\n</code></pre> <pre><code>import numpy as np\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = np.matmul(A, B)\n# lg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.785[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 0.019344176980666816[0m\n</code></pre> \\[ \\begin{gather*} Overall\\ time\\ \\equiv O( MNP) \\ \\\\ Overall\\ time\\ \\equiv O\\left( N^{3}\\right) \\ if\\ N\\ x\\ N\\ \\ \\\\ \\end{gather*}\\]"},{"location":"week2/lec2_3/#example-3_1","title":"example 3","text":"<pre><code>def numberOfBits(n):\n    count = 1\n    while n &gt; 1:\n        count = count + 1\n        n = n // 2\n    return count\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = numberOfBits(12564665525885888)\n# lg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.799[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 5.3243013098835945e-05[0m\n</code></pre> \\[Overall\\ time\\ =\\ O( log_{2} n)\\]"},{"location":"week2/lec2_3/#example-4","title":"example 4","text":"<p>Tower of hanoi </p> <pre><code># Recursive Python function to solve tower of hanoi\n\n\ndef TowerOfHanoi(n, from_rod, to_rod, aux_rod):\n    if n == 0:\n        return\n    TowerOfHanoi(n - 1, from_rod, aux_rod, to_rod)\n    print(\"Move disk\", n, \"from rod\", from_rod, \"to rod\", to_rod)\n    TowerOfHanoi(n - 1, aux_rod, to_rod, from_rod)\n\n\n# Driver code\nN = 10\nT = TimerError()\nT.start()\n# A, C, B are the name of rods\nTowerOfHanoi(N, \"A\", \"C\", \"B\")\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.819[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m19[0m - [1mtime take \n 0.012417969992384315[0m\n\n\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 7 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 8 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 7 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 9 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 7 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 8 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 7 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 10 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 7 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 8 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 7 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 9 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 7 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 8 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 7 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\n</code></pre> <pre><code>def Tower_of_Hanoi(n, from_rod, tp_rod, aux_rod):\n    if n:\n        pass\n</code></pre> \\[Overall\\ time\\ =\\ O(n^{2})\\]"},{"location":"week2/lec2_4_searchinlist/","title":"Lec2 4 searchinlist","text":"<pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.450[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m38[0m - [1mtime taken:1.1658004950731993e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(10000)]\n</code></pre> <pre><code>v = random.randint(1, 1000000)\n</code></pre>"},{"location":"week2/lec2_4_searchinlist/#naive-approach","title":"Naive Approach","text":"<pre><code>def naive_search(V, L):\n    for x in L:\n        if V == x:\n            return True\n    else:\n        return False\n</code></pre> <p>complexity = O(n)</p> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nprint(naive_search(v, L))\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.480[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.00020517699886113405[0m\n\n\nlength of L :10000\nFalse\n</code></pre>"},{"location":"week2/lec2_4_searchinlist/#binary-search","title":"binary search","text":""},{"location":"week2/lec2_4_searchinlist/#sorting-function","title":"sorting function","text":"<pre><code>def sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n</code></pre> <pre><code>midpoint = len(L) // 2\nmid_value = L[midpoint]\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nsort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.512[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.012002756993751973[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def sort_list(L: list) -&gt; list:\n    \"\"\"Sorts a list of numbers in ascending order using Quicksort algorithm.\n\n    Args:\n        L: The list to be sorted.\n\n    Returns:\n        A new list containing the sorted elements of the original list.\n    \"\"\"\n\n    if len(L) &lt;= 1:\n        return L\n\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = sort_list([low for low in L if low &lt; mid_value])\n    upper_list = sort_list([upper for upper in L if upper &gt; mid_value])\n    mid_list = [mid for mid in L if mid == mid_value]\n    return lower_list + mid_list + upper_list\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nL = sort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.538[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.009969204023946077[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def binarysearch(v: int, L: list) -&gt; bool:\n\n    if not L:\n        return False\n    midpoint = len(L) // 2\n\n    if v == L[midpoint]:\n        return True\n    if v &lt; L[midpoint]:\n        return binarysearch(v, L[:midpoint])\n    else:\n        return binarysearch(v, L[midpoint + 1 :])\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nprint(binarysearch(v, L))\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.554[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.0001781220198608935[0m\n\n\nlength of L :10000\nFalse\n</code></pre> <p>Complexity = O(logn)</p>"},{"location":"week2/lec_summary/","title":"Lec summary","text":"<p>for loop in pseudocode is  i =0 , i&lt;= n-1 , i++  this is equal to if n = 5  loop will run for n times then checks and terminate when  i == n  so total the loop will run for n+1 </p> <p>j loop will fun for n * (n+1)</p> <p>The Cauchy-Schwarz Inequality</p> <pre><code>$\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)$\n</code></pre>"},{"location":"week2/live_coding/","title":"Live coding","text":"<pre><code># Write code here\ndef Findpeak(L):\n  left , right = 0 , len(L)-1\n  if len(L)==1:\n      return L[0]\n  largest = -1\n\n  while left &lt; right:\n    mid_point = L[(left+right)//2]\n    largest = max(largest, L[left], L[right] , mid_point)\n    if L[left] &gt; mid_point:\n      left = (left+right)//2+1\n    else:\n      right = (left+right)//2-1\n  return largest\n\n\n\n#Suffix Code\n\nres = Findpeak(L)\nprint(res)\n</code></pre> <pre><code>9\n</code></pre> <pre><code>L = [1,3,5,7,9,8,6,4,2]\n</code></pre> <pre><code>def findCommonElements(L1, L2):\n    # Create a dictionary to store elements of L1\n    element_dict = {}\n    for element in L1:\n        element_dict[element] = True\n\n    # Iterate through L2 and find common elements\n    common_elements = []\n    for element in L2:\n        if element in element_dict:\n            common_elements.append(element)\n\n    return common_elements\n</code></pre> <pre><code>def findCommonElements(L1, L2):\n    # Sort both lists\n    L1.sort()\n    L2.sort()\n\n\n    i, j = 0, 0\n    common_elements = []\n\n    # Traverse both lists\n    while i &lt; len(L1) and j &lt; len(L2):\n        if L1[i] == L2[j]:\n            common_elements.append(L1[i])\n            i += 1\n            j += 1\n        elif L1[i] &lt; L2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return common_elements\n</code></pre> <pre><code>def merge(left, right):\n    merged = []\n    i, j = 0, 0\n\n    while i &lt; len(left) and j &lt; len(right):\n        if left[i] &lt; right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    # Add any remaining elements\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged\n\ndef count_sort(deck):\n    # Increment the level as we go deeper into the recursion\n    global level \n    level+= 1\n\n    if len(deck) &lt;= 2:\n        return sorted(deck)\n\n    mid = len(deck) // 2\n\n    left_sorted_list = count_sort(deck[:mid])\n    right_sorted_list = count_sort(deck[mid:])\n\n    merged_list = merge(left_sorted_list, right_sorted_list)\n\n    # Return the merged list and the maximum level encountered\n    return merged_list, \n\ndef subordinates(deck):\n    sorted_deck= count_sort(deck)\n    return sorted_deck, level\nlevel = 0 \n\n# Test the function with sample inputs\nprint(subordinates([194, 69, 103, 150, 151, 44, 103, 98]))  # Output: ([44, 69, 98, 103, 103, 150, 151, 194], 4)\nprint(subordinates([10, 33, 45, 67, 92, 100, 5]))  # Output: ([5, 10, 33, 45, 67, 92, 100], 4)\n</code></pre> <pre><code>(([[44, 98, 103, 151], [69, 103, 150, 194]],), 7)\n(([[5, 67, 92, 100], [10, 33, 45]],), 14)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/live_session/","title":"Live session","text":"<p>Space Complexity </p> <ul> <li>fixed part(C) - size of code</li> <li>Variable Part (\\(S_x\\)) = the size of the input</li> <li>T(X) =  C + \\(S_x\\) = Total space</li> </ul> <p>Time  Complexity </p> <ul> <li>Best case</li> <li>Average Case</li> <li>Worst case</li> </ul> <p>unit of time - how many steps or code is excuteds for a input n</p> <p>notion to represent complexity </p> <ul> <li>Big o  O(n) = upper Bound</li> <li>always f(n)  less than or = c * g(n)</li> <li>Omega - lower bound</li> <li>theta - Tightly bound - average case</li> </ul> <p></p>"},{"location":"week2/master%20theorm/","title":"Master theorm","text":"<p>The time complexity of the merge sort algorithm can be analyzed using the recurrence relation and its components. Let's break it down and then solve the recurrence relation to determine the overall complexity.</p>"},{"location":"week2/master%20theorm/#components-of-merge-sort","title":"Components of Merge Sort","text":"<ol> <li>Base Case: When the list has 0 or 1 element, the function returns immediately with O(1) time complexity.</li> <li>Splitting the List: Dividing the list into two halves takes O(1) time since it only involves calculating the middle index and slicing the list.</li> <li>Recursive Calls: The function makes two recursive calls, each with a list half the size of the original, leading to <code>2T(n/2)</code>.</li> <li>Merging: Merging the two sorted halves takes O(n) time, where n is the total number of elements in the list.</li> </ol>"},{"location":"week2/master%20theorm/#recurrence-relation","title":"Recurrence Relation","text":"<p>The recurrence relation for merge sort can be written as:  </p>"},{"location":"week2/master%20theorm/#solving-the-recurrence-relation","title":"Solving the Recurrence Relation","text":"<p>We can solve this recurrence relation using the Master Theorem for divide-and-conquer recurrences of the form:  </p> <p>For merge sort:</p> <ul> <li>\\( a = 2 \\) (number of subproblems)</li> <li>\\( b = 2 \\) (each subproblem size is n/2)</li> <li>\\( f(n) = O(n) \\) (the cost of dividing and merging)</li> </ul> <p>According to the Master Theorem, we compare \\( f(n) \\) with \\( n^{\\log_b{a}} \\):</p> <ol> <li>Calculate \\( \\log_b{a} \\):     </li> <li> <p>Compare \\( f(n) \\) with \\( n^{\\log_b{a}} \\):</p> </li> <li> <p>\\( f(n) = O(n) \\)</p> </li> <li>\\( n^{\\log_2{2}} = n^1 = n \\)</li> </ol> <p>Since \\( f(n) \\) is \\( O(n) \\) and \\( n^{\\log_2{2}} \\) is also \\( O(n) \\), we are in case 2 of the Master Theorem, which states:</p> <p>If \\( f(n) = O(n^{\\log_b{a}}) \\), then:  </p> <p>Thus:  </p>"},{"location":"week2/master%20theorm/#conclusion","title":"Conclusion","text":"<p>The overall time complexity of merge sort is:  </p> <p>This complexity reflects the efficient performance of merge sort for large datasets, combining the divide-and-conquer approach with efficient merging, resulting in a logarithmic number of levels of recursion and linear work per level.</p>"},{"location":"week2/mergesort2_7/","title":"Mergesort2 7","text":"<pre><code>from loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\n# lg.add(sys.stdout, colorize=True)\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:56:27.046[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m37[0m - [1mtime taken:1.082499511539936e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 100) for i in range(1000)]\nV = random.randint(1, 100)\n</code></pre> <pre><code>def merge(A, B):\n    \"\"\"\n    Merge two sorted lists A and B into a single sorted list.\n\n    Args:\n        A (list): The first sorted list.\n        B (list): The second sorted list.\n\n    Returns:\n        list: The merged sorted list.\n    \"\"\"\n    C, i, j, k = [], 0, 0, 0\n    m, n = len(A), len(B)\n\n    while k &lt; m + n:\n        if i == m:\n            C.extend(B[j:])\n            k = k + (n - j)\n        elif j == n:\n            C.extend(A[i:])\n            k = k + (m - i)\n        elif A[i] &lt; B[j]:\n            C.append(A[i])\n            i, k = i + 1, k + 1\n        else:\n            C.append(B[j])\n            j, k = j + 1, k + 1\n\n    return C\n\n\ndef mergesort(A):\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    Args:\n        A (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(A)\n\n    # Base case: If the list has 0 or 1 element, it is already sorted\n    if n &lt;= 1:\n        return A\n\n    # Recursively split the list into two halves and sort each half\n    L = mergesort(A[: n // 2])\n    R = mergesort(A[n // 2 :])\n\n    # Merge the sorted halves\n    B = merge(L, R)\n\n    return B\n</code></pre> \\[complexity\\ =\\ O\\left( nlogn\\right)\\] <pre><code>T = TimerError()\nT.start()\nmergesort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:07:56.251[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:0.0008673730189912021[0m\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/ppa/","title":"Ppa","text":"<pre><code>def merge(first_list : list, second_list : list) -&gt; list:\n\n    sorted_listed = list() \n    first_list_size = len(first_list)\n    second_list_size = len(second_list)\n    first_pointer , second_pointer = 0, 0 \n    while len(sorted_listed) &lt; first_list_size+second_list_size:\n        if first_pointer == first_list_size:\n            sorted_listed.extend(second_list[second_pointer:])\n            break\n        elif second_pointer == second_list_size:\n            sorted_listed.extend(first_list[first_pointer:])\n            break\n        elif first_list[first_pointer] &lt; second_list[second_pointer]:\n            sorted_listed.append(first_list[first_pointer])\n            first_pointer += 1\n        else:\n            sorted_listed.append(second_list[second_pointer])\n            second_pointer += 1\n    return  sorted_listed\n\ndef merge_sort( list_to_sort : list) -&gt; list:\n\n    if len(list_to_sort) &lt;= 1:\n        return list_to_sort\n\n    mid = len(list_to_sort) // 2\n\n    left = merge_sort(list_to_sort[:mid])\n    right = merge_sort(list_to_sort[mid:])\n    return merge(left, right)\n\ndef  binarySearchIndexAndComparisons(list_to_sort : list , value_to_check) -&gt; tuple:\n    search_result =  False\n    value_compared = 0\n    sorted_list = merge_sort(list_to_sort)\n    left , right = 0, len(sorted_list)-1\n    while left &lt;=right:\n        mid = (left + right) // 2\n        value_compared += 1\n        if value_to_check == sorted_list[mid]:\n            search_result = True\n            return (search_result, value_compared)\n        elif value_to_check &lt; sorted_list[mid]:\n            right = mid-1\n        elif value_to_check &gt; sorted_list[mid]:\n            left = mid + 1\n    return (search_result, value_compared)\n</code></pre> <pre><code>import random\nL = [random.randint(1, 100) for i in range(10)]\nV = random.randint(1, 100)\nprint(L)\nj = merge_sort(L)\n</code></pre> <pre><code>[67, 65, 11, 52, 50, 99, 9, 31, 2, 23]\n</code></pre> <pre><code>L=[2, 6, 8, 11, 17, 23, 33, 44, 46, 50, 65]\n</code></pre> <pre><code>binarySearchIndexAndComparisons(L,100)\n</code></pre> <pre><code>(False, 4)\n</code></pre> <pre><code>len(L)//2\n</code></pre> <pre><code>5\n</code></pre> <pre><code>j[5]\n</code></pre> <pre><code>54\n</code></pre> <pre><code>j\n</code></pre> <pre><code>[8, 9, 37, 37, 41, 54, 76, 84, 90, 97]\n</code></pre> <pre><code>[0]*4\n</code></pre> <pre><code>[0, 0, 0, 0]\n</code></pre>"},{"location":"week2/ppa/#dont-return-the-sorted-listed-the-sorted-has-to-be-same","title":"dont return the sorted listed , the sorted has to be same","text":"<pre><code>def sortInRange(list_to_sort : list,range_value: int)-&gt; list:\n    result_dict = {}\n    for n in list_to_sort:\n        if n in result_dict:\n            result_dict[n].append(n)\n        else:\n            result_dict[n] = [n]\n    list_to_sort.clear()\n    for i in range(range_value):\n        list_to_sort.extend(result_dict.get(i))\n    return\n</code></pre> <pre><code>L = [2 ,0, 1, 1 ,2, 3 ,0, 2, 1 ,0, 2, 3 ,1, 2]\nvalue = 4 \n\nsortInRange(L, 4)\n</code></pre> <pre><code>L\n</code></pre> <pre><code>[0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/rev/","title":"Rev","text":"<p>Notations to represent complexity The notation are mathematical notations that are commonly used to describe the time complexity of an algorithm or the upper and lower bounds of how an algorithm's running time grows as the input size grows.</p> <p>Big-Oh(O) - Upper bound:</p> <p>Big O notation describes the upper bound of an algorithm's running time. Specifically, we use the notation   to describe the maximum growth rate of an algorithm's running time. This means that the algorithm's running time will not grow faster than some constant multiple of   as the input size grows.</p> <p>Omega( $ \\Omega $) - Lower bound:</p> <p>Omega notation, on the other hand, describes the lower bound of an algorithm's running time. Specifically, we use the notation   to describe the minimum growth rate of an algorithm's running time. This means that the algorithm's running time will not grow slower than some constant multiple of  as the input size grows.</p> <p>Theta( $ \\theta$ ) - Tightly bound:</p> <p>Theta notation describes both the upper and lower bounds of an algorithm's running time. Specifically, we use the notation   to describe the tight bound of an algorithm's running time. This means that the algorithm's running time will grow at the same rate as some constant multiple of   as the input size grows.</p> <pre><code>n = 500\ns = 0\nfor i in range(n):\n    s = s + 1\nprint(f\" Big0 n = {n} s value {s}\")\ns = 0\nfor i in range(n):\n    for j in range(n):\n        s = s + 1\nprint(f\" Big0 n^2 = {n**2} s value {s}\")\ns = 0\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            s = s + 1\nprint(f\" Big0 n^3 = {n**3} s value {s}\")\n</code></pre> <pre><code> Big0 n = 500 s value 500\n Big0 n^2 = 250000 s value 250000\n Big0 n^3 = 125000000 s value 125000000\n</code></pre>"},{"location":"week2/rev/#binary-search","title":"Binary Search","text":"<p>Algorithm: Start with a sorted list and a target value.</p> <p>Set the low and high pointers to the first and last indices of the list, respectively.</p> <p>While the low pointer is less than or equal to the high pointer: </p> <p>A. Calculate the middle index as the average of the low and high pointers (round down if necessary). </p> <p>B. If the target value is equal to the middle element of the list, return the middle index. </p> <p>C. If the target value is less than the middle element, set the high pointer to the index before the middle index. </p> <p>D. If the target value is greater than the middle element, set the low pointer to the index after the middle index.</p> <p>If the target value is not found in the list, return False (or some other indication that the value is not present).</p> <pre><code>def merge(first_list , second_list) -&gt; list :\n\n    sorted_list = []\n\n    first_pointer , second_pointer = 0 , 0 \n\n    while first_pointer &lt; len(first_list) and second_pointer &lt; len(second_list):\n\n        if first_list[first_pointer] &lt; second_list[second_pointer]:\n            sorted_list.append(first_list[first_pointer])\n            first_pointer+=1\n        else:\n            sorted_list.append(second_list[second_pointer])\n            second_pointer+=1\n    sorted_list.extend(first_list[first_pointer:])\n    sorted_list.extend(second_list[second_pointer:])\n\n    return sorted_list\n\ndef mergesort(L):\n\n    n = len(L)\n\n    if n==1:\n        return L\n    left_half = mergesort(L[ : n//2])\n    right_half = mergesort(L[n//2:])\n    sorted_list = merge(left_half, right_half)\n    return sorted_list\n</code></pre> <pre><code>import random \n\nL = [random.randint(a=1, b = 100000) for i in range(10000)]\n\nV = random.choice(L)\n</code></pre> <pre><code>V\n</code></pre> <pre><code>27952\n</code></pre> <pre><code>import sys\nimport random\n\n\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nprint(f\" CWD : {os.getcwd()}\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code> CWD : /home/pk/Desktop/gitmaster/PDSA\n</code></pre> <pre><code>J = L.copy()\n</code></pre> <pre><code>T = TimerError()\nT.start()\nJ.sort()\nend_time_1 = T.elapsed()\nprint(f\"time taken:{end_time_1}\")\n</code></pre> <pre><code>time taken:7.14799971319735e-05\n</code></pre> <pre><code>T = TimerError()\nT.start()\nL = mergesort(L)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:0.013598621997516602\n</code></pre> <pre><code>end_time_1- end_time\n</code></pre> <pre><code>-0.011775112012401223\n</code></pre> <pre><code>def binarysearch(L , v ):\n    # L is sorted list     \n    low , high = 0 , len(L)-1 \n\n    while low &lt;= high:\n        mid = (low+high)//2\n        if L[mid] &lt; V:\n            low = mid+1\n        elif L[mid] &gt; v:\n            high = mid -1 \n        else:\n            return True\n    return False\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(V in L)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>True\ntime taken:0.0001255530078196898\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(binarysearch(L, V))\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>True\ntime taken:0.00010096999176312238\n</code></pre> <pre><code>def binarysearch(L, v , low , high):\n    if high - low &lt; 0 :\n        return False\n    mid =  (high+low)//2\n    if v == L[mid]:\n        return True \n    if v &lt; L[mid]:\n        return binarysearch(L , v , low , mid-1)\n    else:\n        return binarysearch(L , v , mid+1 , high)\n</code></pre> <pre><code>low = 0 \nhigh = len(L)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(binarysearch(L, V , low , high))\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>True\ntime taken:7.534401083830744e-05\n</code></pre> <pre><code>def binarysearch(L,v):\n    if L == []:\n        return(False)\n    mid = len(L)//2\n    if v == L[mid]:\n        return mid\n    if v &lt; L[mid]:\n        return(binarysearch(L[:mid],v))\n    else:\n        return(binarysearch(L[mid+1:],v))\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(binarysearch(L, V ))\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>0\ntime taken:0.00010571499296929687\n</code></pre>"},{"location":"week2/rev/#selection-sort","title":"Selection sort","text":"<pre><code>def selection_sort(L):\n\n    n = len(L)\n\n    if n &lt;=1 :\n        return L\n    for i in range(n): # n \n        minpos = i \n        for j in range(i+1, n): # n (n-1)\n            if L[j] &lt; L[minpos]:\n                minpos = j \n        L[i] , L[minpos] = L[minpos] , L[i]\n\n    return L \n</code></pre> <pre><code>L = [random.randint(a=1, b = 100000) for i in range(10000)]\n</code></pre> <pre><code>T = TimerError()\nT.start()\nJ.sort()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:0.0008929939940571785\n</code></pre> <pre><code>J = L.copy()\n</code></pre> <pre><code>T = TimerError()\nT.start()\n_ = selection_sort(J)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:0.9937963989941636\n</code></pre>"},{"location":"week2/rev/#insert-sort","title":"insert sort","text":"<pre><code>def Insertsort(L):\n    n = len(L)\n    if n &lt;=1:\n        return L\n    for i in range(n):\n        j = i \n        while (j&gt;0 ) and L[j] &lt; L[j-1]:\n            L[j] , L[j-1] = L[j-1] , L[j]\n            j-=1\n    return L \n</code></pre> <pre><code>J = L.copy()\nT = TimerError()\nT.start()\n_ = Insertsort(J)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.605617697990965\n</code></pre> <pre><code>def merge_1(A,B): # Merge two sorted list A and B\n    (m,n) = (len(A),len(B))\n    (C,i,j) = ([],0,0)\n\n    #Case 1 :- When both lists A and B have elements for comparing\n    while i &lt; m and j &lt; n:\n        if A[i] &lt;= B[j]:\n            C.append(A[i])\n            i += 1\n        else:\n            C.append(B[j])\n            j += 1\n\n    #Case 2 :- If list B is over, shift all elements of A to C \n    while i &lt; m:\n        C.append(A[i])\n        i += 1\n\n    #Case 3 :- If list A is over, shift all elements of B to C \n    while j &lt; n:\n        C.append(B[j])\n        j += 1\n\n    # Return sorted merged list   \n    return C\n\n\n\n# Recursively divide the problem into sub-problems to sort the input list L    \ndef mergesort_1(L): \n    n = len(L)\n    if n &lt;= 1: #If the list contains only one element or is empty return the list.\n        return(L)\n    Left_Half = mergesort_1(L[:n//2]) #Recursively sort the left half of the list\n    Right_Half = mergesort_1(L[n//2:]) #Recursively sort the rightt half of the list\n    Sorted_Merged_List = merge_1(Left_Half, Right_Half) # Merge two sorted list Left_Half and Right_Half\n    return(Sorted_Merged_List)\n</code></pre> <pre><code>J = L.copy()\nT = TimerError()\nT.start()\n_ = mergesort(J)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:0.015720170005806722\n</code></pre> <pre><code>J = L.copy()\nT = TimerError()\nT.start()\n_ = mergesort_1(J)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:0.008167273001163267\n</code></pre> <pre><code>def merge_1(A,B): \n    (m,n) = (len(A),len(B))\n    (C,i,j) = ([],0,0)\n    global count \n    #Case 1 :- When both lists A and B have elements for comparing\n    while i &lt; m and j &lt; n:\n        count +=1 \n        if A[i] &lt;= B[j]:\n            C.append(A[i])\n            i += 1\n        else:\n            C.append(B[j])\n            j += 1\n\n    #Case 2 :- If list B is over, shift all elements of A to C \n    while i &lt; m:\n        count +=1\n        C.append(A[i])\n        i += 1\n\n    #Case 3 :- If list A is over, shift all elements of B to C \n    while j &lt; n:\n        count +=1\n        C.append(B[j])\n        j += 1\n\n    # Return sorted merged list   \n    return C\n\n\ncount = 0 \n\nL = [1,2,3]\nJ = [4,5, 6]\n\nmerge_1(L, J)\n\nprint(len(L), len(J), count )\n</code></pre> <pre><code>3 3 6\n</code></pre> <pre><code>def Insertsort(L):\n    global count \n    n = len(L)\n    if n &lt;=1:\n        return L\n    for i in range(n):\n        j = i \n        while (j&gt;0 ) and L[j] &lt; L[j-1]:\n            L[j] , L[j-1] = L[j-1] , L[j]\n            count +=1\n            j-=1\n    return L \n\ncount = 0 \nL = [38, 28, 43, 22, 112, 33, 39]\n\nInsertsort(L)\n</code></pre> <pre><code>[22, 28, 33, 38, 39, 43, 112]\n</code></pre> <pre><code>count\n</code></pre> <pre><code>9\n</code></pre> <pre><code>def merge_1(A,B): \n    (m,n) = (len(A),len(B))\n    (C,i,j) = ([],0,0)\n    global count \n    #Case 1 :- When both lists A and B have elements for comparing\n    while i &lt; m and j &lt; n:\n        count +=1 \n        if A[i] &lt;= B[j]:\n            C.append(A[i])\n            i += 1\n        else:\n            C.append(B[j])\n            j += 1\n\n    #Case 2 :- If list B is over, shift all elements of A to C \n    while i &lt; m:\n        C.append(A[i])\n        i += 1\n\n    #Case 3 :- If list A is over, shift all elements of B to C \n    while j &lt; n:\n        C.append(B[j])\n        j += 1\n\n    # Return sorted merged list   \n    return C\n\ncount = 0 \n\nL1 =[4,5,6]\nL2=[1,2,3]\nL3 = [7,9,11]\nL4 = [8,10,12] \n\nmerge_1(merge_1(L1, L2), merge_1(L3, L4))\n\nprint(count )\n</code></pre> <pre><code>14\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/selection_sort_2_5/","title":"Selection sort 2 5","text":"<pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\n# lg.add(sys.stdout, colorize=True)\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 18:59:53.053[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m38[0m - [1mtime taken:1.0107993148267269e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(1000000)]\n</code></pre> <pre><code>def SelectionSort(L):\n    n = len(L)\n    if n &lt;= 1:\n        return L\n    for i in range(n):\n        # Assume L[:i] is sorted\n        mpos = i\n        # mpos: position of minimum in L[i:]\n        for j in range(i + 1, n):\n            if L[j] &lt; L[mpos]:\n                mpos = j\n                # L[mpos] : smallest value in L[i:]\n                # # Exchange L[mpos] and L[i]\n                (L[i], L[mpos]) = (L[mpos], L[i])\n                # Now L[:i+1] is sorted\n                return L\n</code></pre> \\[T(n) =  O(N^{2})\\] <pre><code>T = TimerError()\nT.start()\nSelectionSort(L)\nend_time_1 = T.elapsed()\nlg.info(f\"time taken:{end_time_1}\")\n</code></pre> <pre><code>[32m2024-05-08 19:01:03.132[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:2.2412044927477837e-05[0m\n</code></pre> <pre><code>def sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nsort_list(L)\nend_time_2 = T.elapsed()\nlg.info(f\"time taken:{end_time_2}\")\n</code></pre> <pre><code>[32m2024-05-08 19:01:42.396[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:1.7496046359883621[0m\n</code></pre>"},{"location":"week2/ta_session_sat/","title":"Ta session sat","text":"<p>$ T(n) = 2*T(n-1) + 1 $</p> <p>$ T (n-1) = 2*[2T(n-2) + 1 ] +1  $</p> <p>$ T(n) = 2^k + k *1 $</p> <p>when k = n </p> <p>$ recurrence = 2T(n-1) + 1$</p> <p>$ O(2^n)$</p> <p></p> <p>first loop # $ \\frac{n}{2}$</p> <p>second loop = $ log\\ (n)$</p> <p>recurrence relationship = $  \\frac{n}{2}* log\\ (n) $</p> <p>$ O (n\\ log\\ (n))$</p> <p></p> <p>e , c , </p>"},{"location":"week2/week%20summary/","title":"Week summary","text":"<pre><code>import sys\n\nsys.setrecursionlimit(2**31 - 1)\n</code></pre> <pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:37.997[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m38[0m - [1mtime taken:1.1069001629948616e-05[0m\n</code></pre> <pre><code>random.seed(1965)\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(10000)]\n</code></pre> <pre><code>v = random.randint(1, 1000000)\n</code></pre>"},{"location":"week2/week%20summary/#naive-approach","title":"Naive Approach","text":"<pre><code>def naive_search(V, L):\n    for x in L:\n        if V == x:\n            return True\n    else:\n        return False\n</code></pre> <p>complexity = O(n)</p>"},{"location":"week2/week%20summary/#binary-search","title":"binary search","text":""},{"location":"week2/week%20summary/#sorting-function","title":"sorting function","text":"<pre><code>def sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n</code></pre> <pre><code>midpoint = len(L) // 2\nmid_value = L[midpoint]\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nsort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.066[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.011552168987691402[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def sort_list(L: list) -&gt; list:\n    \"\"\"Sorts a list of numbers in ascending order using Quicksort algorithm.\n\n    Args:\n        L: The list to be sorted.\n\n    Returns:\n        A new list containing the sorted elements of the original list.\n    \"\"\"\n\n    if len(L) &lt;= 1:\n        return L\n\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = sort_list([low for low in L if low &lt; mid_value])\n    upper_list = sort_list([upper for upper in L if upper &gt; mid_value])\n    mid_list = [mid for mid in L if mid == mid_value]\n    return lower_list + mid_list + upper_list\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nL = sort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.093[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.01215230894740671[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def binarysearch(v: int, L: list) -&gt; bool:\n\n    if not L:\n        return False\n    midpoint = len(L) // 2\n\n    if v == L[midpoint]:\n        return True\n    if v &lt; L[midpoint]:\n        return binarysearch(v, L[:midpoint])\n    else:\n        return binarysearch(v, L[midpoint + 1 :])\n</code></pre> <p>Complexity = O(logn)</p> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nend_time = T.elapsed()\nlg.info(f\"time taken naive :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.106[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken naive :0.0001515159965492785[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nprint(binarysearch(v, L))\nend_time = T.elapsed()\nlg.info(f\"time taken binary:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.112[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken binary:0.0001189609756693244[0m\n\n\nlength of L :10000\nFalse\n</code></pre> <pre><code>def SelectionSort(L):\n    n = len(L)\n    if n &lt;= 1:\n        return L\n    for i in range(n):\n        # Assume L[:i] is sorted\n        mpos = i\n        # mpos: position of minimum in L[i:]\n        for j in range(i + 1, n):\n            if L[j] &lt; L[mpos]:\n                mpos = j\n                # L[mpos] : smallest value in L[i:]\n                # # Exchange L[mpos] and L[i]\n                (L[i], L[mpos]) = (L[mpos], L[i])\n                # Now L[:i+1] is sorted\n                return L\n\n\nT = TimerError()\nT.start()\nSelectionSort(L)\nend_time_1 = T.elapsed()\nlg.info(f\"time taken SelectionSort:{end_time_1}\")\n\n\ndef sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n\n\nT = TimerError()\nT.start()\nsort_list(L)\nend_time_2 = T.elapsed()\nlg.info(f\"time taken sort_list:{end_time_2}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.914[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m21[0m - [1mtime taken SelectionSort:0.7941872259834781[0m\n[32m2024-05-08 23:58:38.922[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m35[0m - [1mtime taken sort_list:0.007573203009087592[0m\n</code></pre> <pre><code># insertion sort\ndef insertion_sort(L):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm.\n\n    Args:\n        L (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(L)\n\n    # If the list has 1 or fewer elements, it is already sorted\n    if n &lt;= 1:\n        return L\n\n    # Iterate through each element in the list\n    for i in range(n):\n        j = i\n\n        # Mo value_to_inserte the element at index j towards the beginning of the list\n        # until it's in the correct sorted position\n        while j &gt; 0 and L[j] &lt; L[j - 1]:\n            # Swap the current element with the prevalue_to_insertalue_to_insertious one if it's smaller\n            L[j], L[j - 1] = L[j - 1], L[j]\n            j -= (\n                1  # Decrement j to movalue_to_inserte towards the beginning of the list\n            )\n\n    return L\n\n\nT = TimerError()\nT.start()\ninsertion_sort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken insertion_sort:{end_time}\")\n\n\ndef Insert(List_to_sort, Value_to_insert):\n    \"\"\"\n    Inserts a value into a sorted list while maintaining the sorted order.\n\n    Args:\n        List_to_sort (list): The sorted list to insert the value into.\n        Value_to_insert (Any): The value to insert into the list.\n\n    Returns:\n        list: The sorted list after inserting the value.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list is empty, simply return the value as a single-element list\n    if n == 0:\n        return [Value_to_insert]\n\n    # If the value is greater than or equal to the last element in the list,\n    # append it to the end of the list\n    if Value_to_insert &gt;= List_to_sort[-1]:\n        return List_to_sort + [Value_to_insert]\n    else:\n        # Recursively insert the value into the sublist List_to_sort[:-1]\n        # and then append the last element of List_to_sort to the result\n        return Insert(List_to_sort[:-1], Value_to_insert) + List_to_sort[-1:]\n\n\ndef ISort(List_to_sort):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm recursively.\n\n    Args:\n        List_to_sort (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list has less than 1 element, it is already sorted\n    if n &lt; 1:\n        return List_to_sort\n\n    # Recursively sort the sublist List_to_sort[:-1]\n    # and then insert the last element of List_to_sort into the sorted sublist\n    L = Insert(ISort(List_to_sort[:-1]), List_to_sort[-1])\n\n    return L\n\n\nT = TimerError()\nT.start()\nISort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken merge Sort(:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.929[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m35[0m - [1mtime taken insertion_sort:0.0003439149586483836[0m\n[32m2024-05-08 23:58:39.333[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m89[0m - [1mtime taken merge Sort(:0.40309521002927795[0m\n</code></pre> <pre><code>def merge(A, B):\n    \"\"\"\n    Merge two sorted lists A and B into a single sorted list.\n\n    Args:\n        A (list): The first sorted list.\n        B (list): The second sorted list.\n\n    Returns:\n        list: The merged sorted list.\n    \"\"\"\n    C, i, j, k = [], 0, 0, 0\n    m, n = len(A), len(B)\n\n    while k &lt; m + n:\n        if i == m:\n            C.extend(B[j:])\n            k = k + (n - j)\n        elif j == n:\n            C.extend(A[i:])\n            k = k + (m - i)\n        elif A[i] &lt; B[j]:\n            C.append(A[i])\n            i, k = i + 1, k + 1\n        else:\n            C.append(B[j])\n            j, k = j + 1, k + 1\n\n    return C\n\n\ndef mergesort(A):\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    Args:\n        A (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(A)\n\n    # Base case: If the list has 0 or 1 element, it is already sorted\n    if n &lt;= 1:\n        return A\n\n    # Recursively split the list into two halves and sort each half\n    L = mergesort(A[: n // 2])\n    R = mergesort(A[n // 2 :])\n\n    # Merge the sorted halves\n    B = merge(L, R)\n\n    return B\n\n\nT = TimerError()\nT.start()\nmergesort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:39.347[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m64[0m - [1mtime taken merge sort :0.006971621012780815[0m\n</code></pre> <pre><code>T = TimerError()\nT.start()\n\nmergesort(list(range(1000000, 0, -1)))\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:40.284[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken merge sort :0.9263360829791054[0m\n</code></pre> <pre><code>T = TimerError()\nT.start()\n\nmergesort(list(range(1000000)))\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:41.205[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken merge sort :0.9164764899760485[0m\n</code></pre> <pre><code>L = [random.randint(1, 1000000) for i in range(1000000)]\nT = TimerError()\nT.start()\nmergesort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:59:49.059[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken merge sort :1.6022985609597526[0m\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/3_5lec/","title":"3 5lec","text":""},{"location":"week3/list%26dictionary_imp_3_9/","title":"List&dictionary imp 3 9","text":"<pre><code>import sys\nimport random\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:3.456299987192324e-05\n</code></pre> <pre><code>sys.setrecursionlimit(2**31 - 1)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range(10**7):\n    l.append(i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:0.7082312540001112\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range(10**5):\n    l.insert(0, i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.2863995140000952\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range((10**5) * 2):\n    l.insert(0, i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:4.889978135000092\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range((10**5) * 3):\n    l.insert(0, i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:15.133477557999868\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/list_implementation_3_6/","title":"List implementation 3 6","text":"<pre><code>import sys\nimport random\n\n\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nprint(f\" CWD : {os.getcwd()}\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code> CWD : /home/pk/Desktop/gitmaster/PDSA\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.9004004318267107e-05\n</code></pre> <pre><code>class Node:\n    def __init__(self, v=None):\n        self.value = v\n        self.next = None\n\n    def isempty(self):\n        return self.value is None\n\n    def append(self, value_to_append):\n        if self.isempty():\n            self.value = value_to_append\n        elif self.next is None:\n            self.next = Node(value_to_append)\n        else:\n            self.next.append(value_to_append)\n\n    def insert(self, value_to_insert):\n        new_node = Node(value_to_insert)\n        new_node.next = self.next\n        self.next = new_node\n        self.value, new_node.value = new_node.value, self.value\n\n    def delete(self, value_to_delete):\n        if self.isempty():\n            return\n\n        if self.value == value_to_delete:\n            if self.next is not None:\n                self.value = self.next.value\n                self.next = self.next.next\n            else:\n                self.value = None\n        else:\n            if self.next is not None:\n                self.next.delete(value_to_delete)\n\n    def __str__(self):\n        result = str(self.value)\n        if self.next:\n            result += \" -&gt; \" + str(self.next)\n        return result\n</code></pre> <pre><code>l1 = Node()\nl1.isempty()\n</code></pre> <pre><code>True\n</code></pre> <pre><code>l2 = Node(5)\nl2.isempty()\n</code></pre> <pre><code>False\n</code></pre> <pre><code># Creating a linked list with values 1, 2, 3\nhead = Node(1)\nhead.append(2)\nhead.append(3)\n# Output: 1 -&gt; 2 -&gt; 3\nprint(f\"Initial linked list:{head}\")\n\n# Inserting a new node with value 4 after the first node\nhead.insert(4)\nprint(f\"After inserting 4:{head}\")  # Output: 1 -&gt; 4 -&gt; 2 -&gt; 3\n\n# Deleting the node with value 2\nhead.delete(2)\nprint(f\"After deleting 2:{head}\")  # Output: 1 -&gt; 4 -&gt; 3\n</code></pre> <pre><code>Initial linked list:1 -&gt; 2 -&gt; 3\nAfter inserting 4:4 -&gt; 1 -&gt; 2 -&gt; 3\nAfter deleting 2:4 -&gt; 1 -&gt; 3\n</code></pre>"},{"location":"week3/listsinpython3_7/","title":"Listsinpython3 7","text":"<pre><code>import sys\nimport random\n\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.208100002259016e-05\n</code></pre> <pre><code>zerolist = [0, 0, 0]\n\nzeromatrix = [zerolist, zerolist, zerolist]\n\nzeromatrix[1][1] = 1\nprint(zeromatrix)\n</code></pre> <pre><code>[[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n</code></pre> <pre><code>zerolist = [0, 0, 0]\n\nzeromatrix = [zerolist, zerolist.copy(), zerolist]\n\nzeromatrix[1][1] = 1\n\nzeromatrix[0][1] = 2\n\nprint(zeromatrix)\n</code></pre> <pre><code>[[0, 2, 0], [0, 1, 0], [0, 2, 0]]\n</code></pre> <pre><code>import numpy as np\n\nzeromatrix = np.zeros((3, 3))\n\nzeromatrix\n</code></pre> <pre><code>array([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n</code></pre> <pre><code>np.arange(5)\n</code></pre> <pre><code>array([0, 1, 2, 3, 4])\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/ppa/","title":"Ppa","text":"<pre><code>class Node:\n  def __init__(self, data):\n    self.data = data\n    self.next = None\n    self.prev = None\nclass doubly_linked_list:\n  def __init__(self):\n    self.head = None\n    self.last = None\n    self.last = None\n  def insert_end(self, data):\n\n      if self.head is None:\n          self.head = Node(data)\n      elif self.last is None:\n          temp = Node(data)\n          self.head.next = temp \n          self.last = temp \n          self.last.prev = self.head\n      else:\n          temp = Node(data)\n          self.last.next = temp\n          temp.prev = self.last\n          self.last = temp \n  def delete_end(self):\n      if self.head is None :\n          return None \n      else:\n          self.last = self.last.prev\n          self.last.next = None \n</code></pre> <pre><code>def DishPrepareOrder(order_list):\n    order_count = {}\n    for order in order_list:\n        if order in order_count:\n            order_count[order] += 1 \n        else:\n            order_count[order] = 1\n    count_dic = {}\n\n    for key , value in order_count.items():\n        if value in count_dic:\n            count_dic[value].append(key)\n        else:\n            count_dic[value] = [key]\n    order_key = sorted(list(count_dic.keys()) , reverse=True )\n    result = []\n    for final_key in order_key:\n        print(final_key)\n        result.extend(sorted(count_dic.get(final_key) ,reverse=True))\n\n    return result\n</code></pre> <pre><code>l = [1006, 1008, 1009, 1008, 1007, 1005, 1008, 1001, 1003, 1009, 1006, 1003, 1004, 1002, 1008, 1005, 1004, 1007, 1006, 1002, 1002, 1001, 1004, 1001, 1003, 1007, 1007, 1005, 1004, 1002]\n</code></pre> <pre><code>di = DishPrepareOrder(l)\n</code></pre> <pre><code>4\n3\n2\n</code></pre> <pre><code>di\n</code></pre> <pre><code>[1008, 1007, 1004, 1002, 1006, 1005, 1003, 1001, 1009]\n</code></pre> <pre><code>[key for key, value in sorted(di.items(), key=lambda item: item[1])]\n</code></pre> <pre><code>[1009, 1006, 1005, 1001, 1003, 1008, 1007, 1004, 1002]\n</code></pre> <pre><code>sorted(di.items(), key=lambda item: item[1] , reverse=True)\n</code></pre> <pre><code>[(1008, 4),\n (1007, 4),\n (1004, 4),\n (1002, 4),\n (1006, 3),\n (1005, 3),\n (1001, 3),\n (1003, 3),\n (1009, 2)]\n</code></pre> <pre><code>from collections import stack\n</code></pre> <pre><code>---------------------------------------------------------------------------\n\nImportError                               Traceback (most recent call last)\n\nCell In[67], line 1\n----&gt; 1 from collections import stack\n\n\nImportError: cannot import name 'stack' from 'collections' (/home/pk/miniconda3/envs/pdsa_1/lib/python3.11/collections/__init__.py)\n</code></pre> <pre><code>class stack(object):\n    def __init__(self) -&gt; None:\n        self.data = []\n    def Push(self, data : any):\n        self.data.append(data)\n    def Pop(self):\n        if not self.Isempty():\n            return self.data.pop(-1)\n        else:\n            return None\n    def Isempty(self):\n        return self.data == []\n    def len(self):\n        return len(self.data) \n\ndef EvaluateExpression(string : str):\n    current_stack = stack()\n    operators = [\"+\", \"-\" , \"*\" , \"/\" , \"**\"]\n    for value in string.split(\" \"):\n        if not value in operators:\n            current_stack.Push(value)\n        else:\n            if current_stack.len() &gt; 1 :\n                B = int(current_stack.Pop())\n                A = int(current_stack.Pop())\n                current_stack.Push(evaluate(A, B , operation=value))\n            elif current_stack.len() == 1:\n                A = int(current_stack.Pop())\n                current_stack.Push(evaluate(A=0 , B = A , operation=value))\n\n    return current_stack.Pop()\n\ndef evaluate(A, B , operation):\n    if B == None:\n        return A * -1\n    else:\n        if operation == \"+\":\n            return A+B \n        elif operation == \"-\":\n            return A-B\n        elif operation == \"*\":\n            return A*B\n        elif operation == \"/\":\n            return A/B    \n        elif operation == \"**\":\n            return A**B       \n</code></pre> <pre><code>def EvaluateExpression(exp):\n    stack = []\n\n    # Split the expression into tokens\n    tokens = exp.split()\n\n    # Define the operators and their corresponding functions\n    operators = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: a / b,\n    }\n\n    # Scan each element in the given expression\n    for token in tokens:\n        if token.isdigit():  # if the token is an operand (assuming it's an integer)\n            stack.append(int(token))\n        elif token in operators:  # if the token is an operator\n            b = stack.pop()\n            a = stack.pop()\n            result = operators[token](a, b)\n            stack.append(result)\n        else:\n            raise ValueError(f\"Unexpected token: {token}\")\n\n    # The final result should be the only element left in the stack\n    if len(stack) != 1:\n        return None\n\n    return stack.pop()\n</code></pre> <pre><code>1 - 0\n</code></pre> <pre><code>1\n</code></pre> <pre><code>def eval(o,a,b) :\n  if o == '+' :\n    return str(float(a)+float(b))\n  if o == '-' :\n    return str(float(a)-float(b))\n  if o == '*' :\n    return str(float(a)*float(b))\n  if o == '/' :\n    return str(float(a)/float(b))\n  if o == '**' :\n    return str(float(a)**float(b))\n\ndef EvaluateExpression(exp) :\n  op = ['+','-','','/','*']\n  stack = list()\n  exp = exp + ' '\n  i = 0\n  while( i &lt; len(exp)) :\n    if exp[i] == ' ' :\n      pass\n    else :\n      j = i\n      while(exp[j] != ' ') :\n        j += 1\n      if exp[i:j] in op :\n        b = stack.pop(0)\n        a = stack.pop(0)\n        c = eval(exp[i:j],a,b)\n        stack.insert(0,c)\n        i = j+1\n      else:\n        stack.insert(0,exp[i:j])\n        i = j+1      \n  return stack[0]\n</code></pre> <pre><code>\" \".join([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"])\n</code></pre> <pre><code>'10 6 9 3 + -11 * / * 17 + 5 +'\n</code></pre> <pre><code>EvaluateExpression(\" \".join([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]))\n</code></pre> <pre><code>22\n</code></pre> <pre><code>class stack(object):\n    def __init__(self):\n        self.data = []\n    def Push(self, data):\n        self.data.append(data)\n    def Pop(self):\n        if not self.Isempty():\n            return self.data.pop(-1)\n        else:\n            return None\n    def Isempty(self):\n        return self.data == []\n    def len(self):\n        return len(self.data) \nclass Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        current_stack = stack()\n        operators = [\"+\", \"-\" , \"*\" , \"/\" , \"**\"]\n        for value in tokens:\n            if not value in operators:\n                current_stack.Push(value)\n            else:\n                if current_stack.len() &gt; 1 :\n                    B = int(current_stack.Pop())\n                    A = int(current_stack.Pop())\n                    current_stack.Push(int(self.evaluate(A, B , operation=value)))\n                elif current_stack.len() == 1:\n                    A = int(current_stack.Pop())\n                    current_stack.Push(int(self.evaluate(A=0 , B = A , operation=value)))\n\n        return current_stack.Pop()\n\n    def evaluate(self, A, B , operation):\n        if B == None:\n            return A * -1\n        else:\n            if operation == \"+\":\n                return A+B \n            elif operation == \"-\":\n                return A-B\n            elif operation == \"*\":\n                return A*B\n            elif operation == \"/\":\n                return A/B    \n            elif operation == \"**\":\n                return A**B       \n</code></pre> <pre><code>S = Solution()\n\nS.evalRPN([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"])\n</code></pre> <pre><code>22\n</code></pre> <pre><code>class stack(object):\n    def __init__(self) -&gt; None:\n        self.data = []\n    def Push(self, data : any):\n        self.data.append(data)\n    def Pop(self):\n        if not self.Isempty():\n            return self.data.pop(-1)\n        else:\n            return None\n    def Isempty(self):\n        return self.data == []\n    def len(self):\n        return len(self.data) \n\ndef EvaluateExpression(tokens ):\n    current_stack = stack()\n    operators = [\"+\", \"-\" , \"*\" , \"/\" , \"**\"]\n    for value in tokens:\n        if not value in operators:\n            current_stack.Push(value)\n        else:\n            if current_stack.len() &gt; 1 :\n                B = int(current_stack.Pop())\n                A = int(current_stack.Pop())\n                current_stack.Push(int(evaluate(A, B , operation=value)))\n            elif current_stack.len() == 1:\n                A = int(current_stack.Pop())\n                current_stack.Push(evaluate(A=0 , B = A , operation=value))\n\n    return current_stack.Pop()\n\ndef evaluate(A, B , operation):\n    if B == None:\n        return A * -1\n    else:\n        if operation == \"+\":\n            return A+B \n        elif operation == \"-\":\n            return A-B\n        elif operation == \"*\":\n            return A*B\n        elif operation == \"/\":\n            return A/B    \n        elif operation == \"**\":\n            return A**B       \n</code></pre> <pre><code>EvaluateExpression([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"])\n</code></pre> <pre><code>22\n</code></pre> <pre><code>def EvaluateRPN(tokens):\n    stack = []\n\n    # Define the operators and their corresponding functions\n    operators = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b)  # use int to truncate toward zero\n    }\n\n    # Scan each token in the given expression\n    for token in tokens:\n        if token.lstrip('-').isdigit():  # if the token is an operand (including negative numbers)\n            stack.append(int(token))\n        elif token in operators:  # if the token is an operator\n            b = stack.pop()\n            a = stack.pop()\n            result = operators[token](a, b)\n            stack.append(result)\n        else:\n            raise ValueError(f\"Unexpected token: {token}\")\n\n    # The final result should be the only element left in the stack\n    if len(stack) != 1:\n        raise ValueError(\"The input postfix expression is invalid.\")\n\n    return stack.pop()\n\n# Example usage:\ntokens1 = [\"2\", \"1\", \"+\", \"3\", \"*\"]\ntokens2 = [\"4\", \"13\", \"5\", \"/\", \"+\"]\ntokens3 = [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\n\nprint(EvaluateRPN(tokens1))  # Output: 9\nprint(EvaluateRPN(tokens2))  # Output: 6\nprint(EvaluateRPN(tokens3))  # Output: 22\n</code></pre> <pre><code>9\n6\n22\n</code></pre> <pre><code>int(6/-132)\n</code></pre> <pre><code>0\n</code></pre> <pre><code>[0, 17 ]\n</code></pre> <pre><code>class stack(object):\n    def __init__(self) -&gt; None:\n        self.data = []\n    def Push(self, data : any):\n        self.data.append(data)\n    def Pop(self):\n        if not self.Isempty():\n            return self.data.pop(-1)\n        else:\n            return None\n    def Isempty(self):\n        return self.data == []\n    def len(self):\n        return len(self.data) \n\ndef EvaluateExpression(string : str):\n    current_stack = stack()\n    operators = [\"+\", \"-\" , \"*\" , \"/\" , \"**\"]\n    for value in string.split(\" \"):\n        if not value in operators:\n            current_stack.Push(value)\n        else:\n            if current_stack.len() &gt; 1 :\n                B = int(current_stack.Pop())\n                A = int(current_stack.Pop())\n                current_stack.Push(int(evaluate(A, B , operation=value)))\n            elif current_stack.len() == 1:\n                A = int(current_stack.Pop())\n                current_stack.Push(int(evaluate(A=0 , B = A , operation=value)))\n\n    return current_stack.Pop()\n\ndef evaluate(A, B , operation):\n    if B == None:\n        return A * -1\n    else:\n        if operation == \"+\":\n            return A+B \n        elif operation == \"-\":\n            return A-B\n        elif operation == \"*\":\n            return A*B\n        elif operation == \"/\":\n            return A/B    \n        elif operation == \"**\":\n            return A**B       \n\n\n\n\nprint(float(EvaluateExpression(input())))\n</code></pre> <pre><code>-4.0\n</code></pre> <pre><code>current=  stack()\n</code></pre> <pre><code>ex = iter([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"])\n</code></pre> <pre><code>value = ex.__next__()\n</code></pre> <pre><code>value\n</code></pre> <pre><code>'+'\n</code></pre> <pre><code>current.Push(value)\n</code></pre> <pre><code>current.Pop()\n</code></pre> <pre><code>0\n</code></pre> <pre><code>b = int(current.Pop())\na = int(current.Pop())\n</code></pre> <pre><code>a, b\n</code></pre> <pre><code>(0, 17)\n</code></pre> <pre><code>current.Push(0+17)\n</code></pre> <pre><code>class Solution:\n    def resolves(self, a, b, Operator):\n        if Operator == '+':\n            return a + b\n        elif Operator == '-':\n            return a - b\n        elif Operator == '*':\n            return a * b\n        return int(a / b)\n\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if len(token) == 1 and ord(token) &lt; 48:\n                integer2 = stack.pop()\n                integer1 = stack.pop()\n                operator = token\n                resolved_ans = self.resolves(integer1, integer2, operator)\n                stack.append(resolved_ans)\n            else:\n                stack.append(int(token))\n        return stack.pop()\n</code></pre> <pre><code>\n</code></pre> <pre><code>import math \n\nmath.ceil(-0.4)\n</code></pre> <pre><code>0\n</code></pre> <pre><code>class stack(object):\n    def __init__(self) -&gt; None:\n        self.data = []\n    def Push(self, data : any):\n        self.data.append(data)\n    def Pop(self):\n        if not self.Isempty():\n            return self.data.pop(-1)\n        else:\n            return None\n    def Isempty(self):\n        return self.data == []\n    def len(self):\n        return len(self.data) \n\ndef EvaluateExpression(string : str):\n    current_stack = stack()\n    operators = [\"+\", \"-\" , \"*\" , \"/\" , \"**\"]\n    for value in string.split(\" \"):\n        if value in operators:\n            B = current_stack.Pop()\n            A = current_stack.Pop()\n            value_to_append = evaluate(A=A , B= B , operation=value)\n            current_stack.Push(value_to_append)\n        else:\n            current_stack.Push(int(value))\n\n\n\n    return current_stack.Pop()\n\ndef evaluate(A, B , operation):\n    if B == None:\n        return A * -1\n    else:\n        if operation == \"+\":\n            return A+B \n        elif operation == \"-\":\n            return A-B\n        elif operation == \"*\":\n            return A*B\n        elif operation == \"/\":\n            return int(A/B)    \n        elif operation == \"**\":\n            return A**B       \n\n\n\n\nprint(float(EvaluateExpression(input())))\n</code></pre> <pre><code>def reverse(root):\n    prev = None \n    while root.value is not None:\n        next = root.next \n        root.next = prev\n        root.value = next \n    root.value = prev\n    return root\n</code></pre> <pre><code>def reverse(root):\n    prev = None \n    while root is not None:\n        next_value = root.next \n        root.next = prev\n        prev = root \n        root = next_value\n\n\n    return prev\n</code></pre> <pre><code>8//2\n</code></pre> <pre><code>4\n</code></pre> <pre><code>class Node(object):\n    def __init__(self , v = None ) -&gt; None:\n        self.value = v \n        self.next = None \n\n    def isempty(self):\n        return self.value == None \nclass Linklist(object):\n    def __init__(self) -&gt; None:\n        self.head = None \n    def insert_at_last(self, data ):\n        new_node = Node(data)\n        if self.head == None:\n            self.head = new_node \n        else:\n            current = self.head \n            while current.next is not None:\n                current = current.next \n            current.next = new_node\n    def print_list(self):\n        \"\"\"\n        Prints the contents of the linked list.\n        \"\"\"\n        current = self.head\n        while current is not None:\n            print(current.value, end=\" -&gt; \")\n            current = current.next\n        print(\"None\")\n</code></pre> <pre><code>import random \n\nl = [random.randint(1,100) for _ in range(7)]\n</code></pre> <pre><code>link_list = Linklist()\n\nfor j in l:\n    link_list.insert_at_last(j)\n</code></pre> <pre><code>link_list.print_list()\n</code></pre> <pre><code>37 -&gt; 2 -&gt; 80 -&gt; 92 -&gt; 97 -&gt; 19 -&gt; 10 -&gt; None\n</code></pre> <pre><code>def deleteMiddle(head):\n    size = 0 \n    curr = head \n    while curr:\n        size +=1 \n        curr = curr.next\n    curr = head \n    for _ in range(1,size//2):\n        curr = curr.next \n    curr.next = curr.next.next \n</code></pre> <pre><code>deleteMiddle(link_list.head)\n</code></pre> <pre><code>link_list.print_list()\n</code></pre> <pre><code>8 -&gt; 32 -&gt; 57 -&gt; 85 -&gt; 22 -&gt; 68 -&gt; None\n</code></pre> <pre><code>def deleteMiddle(head):\n    curr = currFast = head\n    currPrev = None\n    flag = False\n    while (currFast):\n        if (flag):\n            currPrev = curr\n            curr =  curr.next\n        currFast = currFast.next\n        flag = not flag\n    currPrev.next = currPrev.next.next\n</code></pre> <pre><code>deleteMiddle(link_list.head)\n</code></pre> <pre><code>link_list.print_list()\n</code></pre> <pre><code>37 -&gt; 2 -&gt; 80 -&gt; 97 -&gt; 19 -&gt; 10 -&gt; None\n</code></pre> <pre><code>class Hashing:\n    def __init__(self,c1,c2,m):\n        self.hashtable = []\n        for i in range(m):\n            self.hashtable.append(None)     \n        self.c1 = c1\n        self.c2 = c2\n        self.m = m\n\n    def hashfunction(self, data  ):\n        i = 0 \n        key = (data%self.m + self.c1*i+self.c2*(i**2))%self.m \n        while self.hashtable[key] != None and i&lt; self.m:\n            key = (data%self.m + self.c1*i+ self.c2*(i**2))%self.m \n            i+=1\n        return key \n\n    def store_data(self, data):\n        if self.hashtable.count(None) !=0: \n            key = self.hashfunction(data=data)\n            self.hashtable[key] = data \n        else:\n            print(\"Hast table is full\")\n    def display_hashtable(self):\n        return self.hashtable\n</code></pre> <pre><code>c1 = 1\nc2 = 1\nm = 11\ndata= [22,44,35,54,36,27]\nA = Hashing(c1,c2,m)\nfor i in data:\n    A.store_data(i)\nprint(A.display_hashtable())\n</code></pre> <pre><code>0\n2\n2\n4\n[22, None, 44, 36, 35, 27, None, None, None, None, 54]\n</code></pre> <pre><code>[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 10] == [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 10]\n</code></pre> <pre><code>True\n</code></pre> <pre><code>[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 10]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/quick_sort_3_1/","title":"Quick sort 3 1","text":"<pre><code>import sys\nfrom loguru import logger\nimport random\nimport time\n\nlogger.remove()\nlogger.add(\n    sys.stdout, colorize=True, format=\"&lt;level&gt;{level}&lt;/level&gt; | &lt;blue&gt;{message}&lt;/blue&gt;\"\n)\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlogger.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[1mINFO[0m | [34mtime taken:1.1410999832150992e-05[0m\n</code></pre> <p>Merge needs to create a new list to hold the merged elements - No obvious way to efficiently merge two lists in place - Extra storage can be costly Inherently recursive - Recursive calls and returns are expensive</p>"},{"location":"week3/quick_sort_3_1/#quick-sorting","title":"quick sorting","text":"<ol> <li>select the median </li> <li>recursively sort the left and right   </li> </ol> <p>how to find the median ?</p> <p>choose a pivot element </p> <ul> <li>[C.A.R Hoare]</li> </ul> <pre><code>def quicksort(L: list, lower_index: int, upper_index: int):\n    \"\"\"\n    Sorts a list using the Quicksort algorithm.\n\n    Parameters:\n        L (list): The list to be sorted.\n        lower_index (int): The lower index of the sublist to be sorted (default is 0).\n        upper_index (int): The upper index of the sublist to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    if upper_index - lower_index &lt;= 1:\n        return L\n\n    pivot = L[lower_index]\n    lower = lower_index + 1\n    upper = lower_index + 1\n\n    for i in range(lower_index + 1, upper_index):\n        if L[i] &gt; pivot:\n            upper += 1\n        else:\n            L[i], L[lower] = L[lower], L[i]\n            lower += 1\n            upper +=1\n\n    # Move pivot between lower and upper\n    L[lower - 1], L[lower_index] = L[lower_index], L[lower - 1]\n\n    # Recursive calls\n    quicksort(L, lower_index=lower_index, upper_index=lower - 1)\n    quicksort(L, lower_index=lower, upper_index=upper)\n\n    return L\n</code></pre> <p></p> <pre><code>L = [random.randint(1, 100) for i in range(100000)]\nV = random.randint(1, 100)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nquicksort(L, 0, len(L))\nend_time = T.elapsed()\nlogger.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[1mINFO[0m | [34mtime taken:2.749621214000399[0m\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/quicksort_anaylsis_3.2/","title":"Quicksort anaylsis 3.2","text":"<pre><code>import sys\nfrom loguru import logger\nimport random\nimport time\n\nlogger.remove()\nlogger.add(\n    sys.stdout, colorize=True, format=\"&lt;level&gt;{level}&lt;/level&gt; | &lt;blue&gt;{message}&lt;/blue&gt;\"\n)\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlogger.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[1mINFO[0m | [34mtime taken:1.97930057765916e-05[0m\n</code></pre>"},{"location":"week3/quicksort_anaylsis_3.2/#choose-the-pivot-element-randomly","title":"choose the pivot element - randomly","text":"<ul> <li>uniformly disturbed between 0 to (n-1) where n is the number of elements </li> </ul>"},{"location":"week3/rev/","title":"Quick Sort Algo","text":""},{"location":"week3/rev/#quick-sort-algo","title":"Quick Sort Algo","text":"<pre><code>def quicksort(List_to_sort , lower_index , upper_index ):\n    if upper_index - lower_index &lt;= 1: # base case \n        return List_to_sort\n\n    pivot = List_to_sort[lower_index]\n    lower = lower_index+1\n    upper = upper_index-1\n\n    while lower &lt;= upper:\n        if List_to_sort[lower] &lt;= pivot:\n            lower+=1\n        else:\n            List_to_sort[lower] , List_to_sort[upper] = List_to_sort[upper] , List_to_sort[lower]\n            upper -=1\n    List_to_sort[lower_index], List_to_sort[upper] = List_to_sort[upper], List_to_sort[lower_index]\n    quicksort(List_to_sort, lower_index=lower_index, upper_index=upper)\n    quicksort(List_to_sort , lower_index=upper+1 , upper_index=upper_index)\n    return List_to_sort\n</code></pre> <pre><code>import sys\nimport random\n\n\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>import random \n\nL = [random.randint(a=1, b = 100000) for i in range(1000000)]\n</code></pre> <pre><code>J = L.copy()\nZ = L.copy()\n</code></pre> <pre><code>T = TimerError()\nT.start()\nJ.sort()\nend_time_1 = T.elapsed()\nprint(f\"time taken:{end_time_1}\")\n</code></pre> <pre><code>time taken:0.22359681299985823\n</code></pre> <pre><code>T = TimerError()\nT.start()\nquicksort(L, 0 , len(L))\nend_time_1 = T.elapsed()\nprint(f\"time taken:{end_time_1}\")\n</code></pre> <pre><code>time taken:1.6058930050003255\n</code></pre> <pre><code>def quicksort(List_to_sort, lower_index, upper_index):\n    if upper_index- lower_index &lt;=1:\n        return List_to_sort \n\n    pivot , lower, upper = List_to_sort[lower_index] , lower_index+1 , lower_index+1\n\n    for i in range(lower_index+1 , upper_index):\n        if List_to_sort[i] &lt; pivot:\n            List_to_sort[i] , List_to_sort[lower] = List_to_sort[lower] , List_to_sort[i]\n            lower+=1 \n            upper+=1\n        else:\n            upper+=1\n\n        List_to_sort[lower-1] , List_to_sort[lower_index] = List_to_sort[lower_index], List_to_sort[lower-1]\n\n        quicksort(L, lower_index=lower_index, upper_index=lower-1)\n        quicksort(L, lower_index= lower , upper_index=upper)\n        return List_to_sort\n</code></pre> <pre><code>T = TimerError()\nT.start()\nquicksort(Z, 0 , len(L))\nend_time_1 = T.elapsed()\nprint(f\"time taken:{end_time_1}\")\n</code></pre> <pre><code>time taken:2.754399974946864e-05\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/BFS_4_3%20_/","title":"BFS 4 3","text":"<pre><code>import os\nimport numpy as np\n</code></pre>"},{"location":"week4/BFS_4_3%20_/#queue","title":"Queue","text":"<pre><code>class Queue:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty queue.\n        The queue is represented as a list.\n        \"\"\"\n        self.queue = []\n\n    def Equeue(self, v):\n        \"\"\"\n        Adds an element 'v' to the end of the queue.\n\n        Parameters:\n        v: The element to be added to the queue.\n        \"\"\"\n        self.queue.append(v)\n\n    def Dqueue(self):\n        \"\"\"\n        Removes and returns the element at the front of the queue.\n\n        Returns:\n        The element at the front of the queue if the queue is not empty,\n        otherwise None.\n        \"\"\"\n        v = None\n        if not self.isempty():\n            v = self.queue[0]  \n            self.queue = self.queue[1:]  \n        return v\n\n    def isempty(self):\n        \"\"\"\n        Checks if the queue is empty.\n\n        Returns:\n        True if the queue is empty, otherwise False.\n        \"\"\"\n        return self.queue == []\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the queue.\n\n        Returns:\n        A string representation of the queue list.\n        \"\"\"\n        return str(self.queue)\n</code></pre> <pre><code>AMat = np.array(\n    [\n        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0, 1, 0, 0, 0, 1],\n        [0, 0, 0, 1, 1, 0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    ]\n)\n</code></pre> <pre><code>def BFSMat( AMat , source_vertex ):\n\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    Source_vertex : int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited: dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n        \"\"\"\n    rows , cols = AMat.shape\n    visited = {i : False for i in range(rows)\n               }\n    visited[source_vertex] = True \n\n    q = Queue()\n    q.Equeue(source_vertex)\n    while not q.isempty():\n        to_explore = q.Dqueue()\n        for neighbour in neighbours(AMat=AMat , to_explore=to_explore):\n            if not visited[neighbour]:\n                visited[neighbour] = True \n                q.Equeue(neighbour)\n    return visited\n\n\n\n# Define the neighbours function\ndef neighbours(AMat, to_explore):\n    \"\"\"\n    Finds the neighbors of a given vertex in a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    j: int\n        The vertex for which to find the neighbors.\n\n    Returns:\n    list:\n        A list of neighbors of vertex j.\n    \"\"\"\n    neighbors = []\n    for i in range(AMat.shape[1]):\n        if AMat[to_explore, i] == 1:  # Assuming 1 indicates an edge/connection\n            neighbors.append(i)\n    return neighbors\n</code></pre> <pre><code>AMat = np.array([[0, 1, 0, 0],\n                 [1, 0, 1, 0], \n                 [0, 1, 0, 1], \n                 [0, 0, 1, 0]])\n\n# Starting vertex\nv = 0\n\n# Perform BFS\nvisited = BFSMat(AMat, v)\nprint(visited)\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True}\n</code></pre> <pre><code>def create_Alist(AMat):\n    AList = {}\n    for  parent in range(AMat.shape[0]):\n        neighbours = []\n        for neighbour in range(AMat.shape[1]):\n            if AMat[parent, neighbour] ==1 :\n                neighbours.append(neighbour)\n        AList[parent] = neighbours\n    return AList\n</code></pre> <pre><code>def BFSAlist( AList , source_vertex ):\n\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    Source_vertex : int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited: dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n        \"\"\"\n    visited = {i : False for i in AList.keys() }\n    visited[source_vertex] = True \n\n    q = Queue()\n    q.Equeue(source_vertex)\n    while not q.isempty():\n        to_explore = q.Dqueue()\n        for neighbour in AList[to_explore]:\n            if not visited[neighbour]:\n                visited[neighbour] = True \n                q.Equeue(neighbour)\n    return visited\n</code></pre> <pre><code>Alist = create_Alist(AMat)\n</code></pre> <pre><code>Alist\n</code></pre> <pre><code>{0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}\n</code></pre> <pre><code>BFSAlist(Alist,source_vertex=v)\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True}\n</code></pre> <pre><code>class Queue:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty queue.\n        The queue is represented as a list.\n        \"\"\"\n        self.queue = []\n\n    def Enqueue(self, v):\n        \"\"\"\n        Adds an element 'v' to the end of the queue.\n\n        Parameters:\n        v: The element to be added to the queue.\n        \"\"\"\n        self.queue.append(v)\n\n    def Dequeue(self):\n        \"\"\"\n        Removes and returns the element at the front of the queue.\n\n        Returns:\n        The element at the front of the queue if the queue is not empty,\n        otherwise None.\n        \"\"\"\n        v = None\n        if not self.isempty():\n            v = self.queue[0]  \n            self.queue = self.queue[1:]  \n        return v\n\n    def isempty(self):\n        \"\"\"\n        Checks if the queue is empty.\n\n        Returns:\n        True if the queue is empty, otherwise False.\n        \"\"\"\n        return self.queue == []\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the queue.\n\n        Returns:\n        A string representation of the queue list.\n        \"\"\"\n        return str(self.queue)\n</code></pre> <pre><code>def BFSAlistPath(AList, source_vertex):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency list.\n\n    Parameters:\n    AList : dict\n        The adjacency list representing the graph. It's a dictionary where keys are vertices\n        and values are lists of adjacent vertices.\n    source_vertex : int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited : dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the BFS tree, or -1 if no parent (for the source vertex).\n\n    Note:\n    This function assumes the existence of a Queue data structure with methods `enqueue`\n    (to add an item) and `dequeue` (to remove and return the next item), as used in BFS.\n    \"\"\"\n    visited = {}\n    parent = {}\n\n    # Initialize visited and parent dictionaries\n    for vertex in AList.keys():\n        visited[vertex] = False\n        parent[vertex] = -1\n\n    # Mark the source vertex as visited\n    visited[source_vertex] = True\n\n    # Initialize a queue for BFS\n    q = Queue()\n    q.Enqueue(source_vertex)\n\n    # Perform BFS\n    while not q.isempty():\n        current_vertex = q.Dequeue()\n        for neighbour in AList[current_vertex]:\n            if not visited[neighbour]:\n                visited[neighbour] = True\n                parent[neighbour] = current_vertex\n                q.Enqueue(neighbour)\n\n    return visited, parent\n</code></pre> <pre><code>BFSAlistPath(AList=Alist , source_vertex=v)\n</code></pre> <pre><code>({0: True, 1: True, 2: True, 3: True}, {0: -1, 1: 0, 2: 1, 3: 2})\n</code></pre> <pre><code>def BFSAlistPathLevel(AList, source_vertex):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency list,\n    and computes the level (distance from the source vertex) for each vertex.\n\n    Parameters:\n    AList : dict\n        The adjacency list representing the graph. It's a dictionary where keys are vertices\n        and values are lists of adjacent vertices.\n    source_vertex : int\n        The starting vertex for the BFS.\n\n    Returns:\n    level : dict\n        A dictionary where keys are the vertices and values are integers indicating\n        the level (distance from the source vertex) of each vertex.\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the BFS tree, or -1 if no parent (for the source vertex).\n\n    Note:\n    This function assumes the existence of a Queue data structure with methods `enqueue`\n    (to add an item) and `dequeue` (to remove and return the next item), as used in BFS.\n    \"\"\"\n    level = {}\n    parent = {}\n\n    # Initialize level and parent dictionaries\n    for vertex in AList.keys():\n        level[vertex] = -1  # -1 indicates vertex has not been visited or reached\n        parent[vertex] = -1\n\n    # Mark the source vertex with level 0\n    level[source_vertex] = 0 \n\n    # Initialize a queue for BFS\n    q = Queue()\n    q.Enqueue(source_vertex)\n\n    # Perform BFS\n    while not q.isempty():\n        current_vertex = q.Dequeue()\n        for neighbour in AList[current_vertex]:\n            if level[neighbour] == -1:  # Check if neighbour has not been visited\n                level[neighbour] = level[current_vertex] + 1\n                parent[neighbour] = current_vertex\n                q.Enqueue(neighbour)\n    print(\"Level\" , level)\n    print(\"parent\" , parent)\n    return level, parent\n</code></pre> <pre><code>BFSAlistPathLevel(Alist, v)\n</code></pre> <pre><code>Level {0: 0, 1: 1, 2: 2, 3: 3}\nparent {0: -1, 1: 0, 2: 1, 3: 2}\n\n\n\n\n\n({0: 0, 1: 1, 2: 2, 3: 3}, {0: -1, 1: 0, 2: 1, 3: 2})\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/BFS_4_3/","title":"BFS 4 3","text":"<pre><code>import os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.6460999177070335e-05\n</code></pre> <pre><code>class Queue:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty queue.\n        The queue is represented as a list.\n        \"\"\"\n        self.queue = []\n\n    def addq(self, v):\n        \"\"\"\n        Adds an element 'v' to the end of the queue.\n\n        Parameters:\n        v: The element to be added to the queue.\n        \"\"\"\n        self.queue.append(v)\n\n    def delq(self):\n        \"\"\"\n        Removes and returns the element at the front of the queue.\n\n        Returns:\n        The element at the front of the queue if the queue is not empty,\n        otherwise None.\n        \"\"\"\n        v = None\n        if not self.isempty():\n            v = self.queue[0]  # Get the first element in the queue\n            self.queue = self.queue[1:]  # Remove the first element by slicing\n        return v\n\n    def isempty(self):\n        \"\"\"\n        Checks if the queue is empty.\n\n        Returns:\n        True if the queue is empty, otherwise False.\n        \"\"\"\n        return self.queue == []\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the queue.\n\n        Returns:\n        A string representation of the queue list.\n        \"\"\"\n        return str(self.queue)\n\n\n# Example usage\nq = Queue()\nq.addq(1)\nq.addq(2)\nq.addq(3)\nprint(q)  # Output: [1, 2, 3]\nprint(q.delq())  # Output: 1\nprint(q)  # Output: [2, 3]\nprint(q.isempty())  # Output: False\nq.delq()\nq.delq()\nprint(q.isempty())  # Output: True\nprint(q.delq())  # Output: None\n</code></pre> <pre><code>[1, 2, 3]\n1\n[2, 3]\nFalse\nTrue\nNone\n</code></pre> <pre><code>q = Queue()\nfor i in range(3):\n    q.addq(i)\nprint(q)\nprint(q.isempty())\nfor j in range(3):\n    print(q.delq(), q)\nprint(q.isempty())\n</code></pre> <pre><code>[0, 1, 2]\nFalse\n0 [1, 2]\n1 [2]\n2 []\nTrue\n</code></pre> <pre><code>def BFS(AMat, v):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    v: int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited: dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    \"\"\"\n\n    # Get the number of rows (and columns) in the adjacency matrix\n    (rows, cols) = AMat.shape\n\n    # Initialize a dictionary to keep track of visited vertices\n    visited = {}\n    for i in range(rows):\n        visited[i] = False\n\n    # Initialize the queue for BFS\n    q = Queue()\n\n    # Mark the starting vertex as visited and enqueue it\n    visited[v] = True\n    q.addq(v)\n\n    # Perform BFS\n    while not q.isempty():\n        # Dequeue a vertex from the queue\n        j = q.delq()\n\n        # Get all the neighbors of the dequeued vertex j\n        for k in neighbours(AMat, j):\n            # If the neighbor has not been visited, mark it as visited and enqueue it\n            if not visited[k]:\n                visited[k] = True\n                q.addq(k)\n\n    # Return the dictionary of visited vertices\n    return visited\n\n\n# Define the neighbours function\ndef neighbours(AMat, j):\n    \"\"\"\n    Finds the neighbors of a given vertex in a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    j: int\n        The vertex for which to find the neighbors.\n\n    Returns:\n    list:\n        A list of neighbors of vertex j.\n    \"\"\"\n    neighbors = []\n    for i in range(AMat.shape[1]):\n        if AMat[j, i] == 1:  # Assuming 1 indicates an edge/connection\n            neighbors.append(i)\n    return neighbors\n\n\nimport numpy as np\n\n# Example adjacency matrix\nAMat = np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]])\n\n# Starting vertex\nv = 0\n\n# Perform BFS\nvisited = BFS(AMat, v)\nprint(visited)  # Output will show which vertices were visited\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True}\n</code></pre> <pre><code>AMat = np.array(\n    [\n        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0, 1, 0, 0, 0, 1],\n        [0, 0, 0, 1, 1, 0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    ]\n)\n</code></pre> <pre><code># Starting vertex\nv = 0\n\n# Perform BFS\nvisited = BFS(AMat, v)\nprint(visited)\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\n</code></pre> <pre><code>def BFSListPath(AList, v):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency list.\n\n    Parameters:\n    AList: dict\n        The adjacency list representing the graph, where keys are vertices and values are lists of adjacent vertices.\n    v: int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited: dict\n        A dictionary where keys are vertices and values are booleans indicating whether the vertex has been visited.\n    parent: dict\n        A dictionary where keys are vertices and values are the parent of that vertex in the BFS tree.\n    \"\"\"\n\n    # Initialize the visited dictionary and parent dictionary\n    visited, parent = {}, {}\n    for i in AList.keys():\n        visited[i] = False\n        parent[i] = -1\n\n    # Initialize the queue for BFS\n    q = Queue()\n\n    # Mark the starting vertex as visited and enqueue it\n    visited[v] = True\n    q.addq(v)\n\n    # Perform BFS\n    while not q.isempty():\n        # Dequeue a vertex from the queue\n        j = q.delq()\n\n        # Get all the neighbors of the dequeued vertex j\n        for k in AList[j]:\n            # If the neighbor has not been visited, mark it as visited and set its parent\n            if not visited[k]:\n                visited[k] = True\n                parent[k] = j\n                q.addq(k)\n\n    # Return the visited dictionary and the parent dictionary\n    return visited, parent\n\n\n# Example usage\nAList = {\n    0: [1, 2],\n    1: [0, 3],\n    2: [0, 4],\n    3: [1, 5, 6],\n    4: [2, 5, 9],\n    5: [3, 4, 7],\n    6: [3],\n    7: [5, 8],\n    8: [7],\n    9: [4],\n}\n\n# Starting vertex\nv = 0\n\n# Perform BFS\nvisited, parent = BFSListPath(AList, v)\nprint(\"Visited:\", visited)\nprint(\"Parent:\", parent)\n</code></pre> <pre><code>Visited: {0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\nParent: {0: -1, 1: 0, 2: 0, 3: 1, 4: 2, 5: 3, 6: 3, 7: 5, 8: 7, 9: 4}\n</code></pre> <pre><code>def BFSListPathLevel(AList, v):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented as an adjacency list,\n    starting from vertex `v`. Computes the level (distance from the start vertex)\n    and parent (preceding vertex in the BFS tree) for each vertex in the graph.\n\n    Parameters:\n    AList (dict): Adjacency list representation of the graph.\n                  Keys are vertices, values are lists of adjacent vertices.\n    v (int): The starting vertex for BFS.\n\n    Returns:\n    tuple: A tuple containing two dictionaries:\n           - level (dict): Maps each vertex to its level (distance from `v`).\n           - parent (dict): Maps each vertex to its parent in the BFS tree.\n                            The parent of the starting vertex `v` is set to -1.\n\n    Example usage:\n    AList = {\n        0: [1, 2],\n        1: [0, 3, 4],\n        2: [0, 5],\n        3: [1],\n        4: [1],\n        5: [2]\n    }\n    level, parent = BFSListPathLevel(AList, 0)\n    print(\"Levels:\", level)\n    print(\"Parents:\", parent)\n    \"\"\"\n\n    level = {}\n    parent = {}\n\n    # Initialize level and parent for each node\n    for i in AList.keys():\n        level[i] = -1\n        parent[i] = -1\n\n    # Create a queue and enqueue the starting vertex\n    q = Queue()\n    level[v] = 0\n    q.addq(v)\n\n    # BFS algorithm\n    while not q.isempty():\n        j = q.delq()\n        for k in AList[j]:\n            if level[k] == -1:  # If k is not visited\n                level[k] = level[j] + 1\n                parent[k] = j\n                q.addq(k)\n\n    return level, parent\n\n\n# Example usage\nAList = {0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2]}\n\nlevel, parent = BFSListPathLevel(AList, 0)\nprint(\"Levels:\", level)\nprint(\"Parents:\", parent)\n</code></pre> <pre><code>Levels: {0: 0, 1: 1, 2: 1, 3: 2, 4: 2, 5: 2}\nParents: {0: -1, 1: 0, 2: 0, 3: 1, 4: 1, 5: 2}\n</code></pre>"},{"location":"week4/DFS/","title":"DFS","text":"<pre><code>import os \nimport numpy as np \n</code></pre>"},{"location":"week4/DFS/#first-approach","title":"first approach","text":"<pre><code># Define the neighbours function\ndef neighbours(AMat, to_explore):\n    \"\"\"\n    Finds the neighbors of a given vertex in a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    j: int\n        The vertex for which to find the neighbors.\n\n    Returns:\n    list:\n        A list of neighbors of vertex j.\n    \"\"\"\n    neighbors = []\n    for i in range(AMat.shape[1]):\n        if AMat[to_explore, i] == 1:  # Assuming 1 indicates an edge/connection\n            neighbors.append(i)\n    return neighbors\n</code></pre> <pre><code>def DFSinit(AMat):\n    \"\"\"\n    Initializes the visited and parent dictionaries for Depth-First Search (DFS).\n\n    Parameters:\n    AMat : numpy.ndarray\n        The adjacency matrix representing the graph.\n\n    Returns:\n    visited : dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the DFS tree, or -1 if no parent (for the starting vertex).\n    \"\"\"\n    rows = AMat.shape[0]\n    visited = {}\n    parent = {}\n\n    for i in range(rows):\n        visited[i] = False\n        parent[i] = -1\n\n    return visited, parent\n\n\n\ndef DFSAmat(Amat , visited  , parent , source_vertex):\n    \"\"\"\n    Performs Depth-First Search (BFS) on a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat : list of list\n        The adjacency matrix representing the graph.\n    visited : dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the BFS tree, or -1 if no parent (for the source vertex).\n    source_vertex : int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited : dict\n        Updated dictionary indicating which vertices have been visited after BFS.\n    parent : dict\n        Updated dictionary representing the parent vertices after BFS.\n    \"\"\"\n    visited[source_vertex] = True \n\n    for neighbour in neighbours(AMat=Amat, to_explore=source_vertex):\n        if not visited[neighbour]: \n            parent[neighbour] = source_vertex\n            visited , parent = DFSAmat(Amat=Amat, visited=visited,parent=parent, source_vertex=neighbour )\n    return visited , parent\n</code></pre> <pre><code>adj_matrix =np.array( [\n    [0, 1, 1, 1, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 1, 0, 0, 0],\n    [1, 0, 0, 0, 0, 0, 1, 0, 0],\n    [1, 0, 0, 0, 0, 0, 0, 1, 1],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0]\n])\n</code></pre> <pre><code>visited , parent = DFSinit(AMat=adj_matrix) \nDFSAmat(adj_matrix, visited , parent , 0 )\n</code></pre> <pre><code>visited , parent\n</code></pre> <pre><code>({0: False,\n  1: False,\n  2: False,\n  3: False,\n  4: False,\n  5: False,\n  6: False,\n  7: False,\n  8: False},\n {0: -1, 1: -1, 2: -1, 3: -1, 4: -1, 5: -1, 6: -1, 7: -1, 8: -1})\n</code></pre> <pre><code>DFSAmat(adj_matrix, visited , parent , 0 )\n</code></pre> <pre><code>({0: True,\n  1: True,\n  2: True,\n  3: True,\n  4: True,\n  5: True,\n  6: True,\n  7: True,\n  8: True},\n {0: -1, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 2, 7: 3, 8: 3})\n</code></pre> <pre><code>del visited\ndel parent\n</code></pre> <pre><code>visited = {}\nparent = {}\ndef DFSinit(AMat):\n    \"\"\"\n    Initializes the visited and parent dictionaries for Depth-First Search (DFS).\n\n    Parameters:\n    AMat : numpy.ndarray\n        The adjacency matrix representing the graph.\n\n    Returns:\n    visited : dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the DFS tree, or -1 if no parent (for the starting vertex).\n    \"\"\"\n    rows = AMat.shape[0]\n    global visited\n    global parent \n\n    for i in range(rows):\n        visited[i] = False\n        parent[i] = -1\n\n    return visited, parent\n\n\n\ndef DFSAmat(Amat ,source_vertex):\n    \"\"\"\n    Performs Depth-First Search (BFS) on a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat : list of list\n        The adjacency matrix representing the graph.\n    visited : dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the BFS tree, or -1 if no parent (for the source vertex).\n    source_vertex : int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited : dict\n        Updated dictionary indicating which vertices have been visited after BFS.\n    parent : dict\n        Updated dictionary representing the parent vertices after BFS.\n    \"\"\"\n    global visited\n    global parent \n    visited[source_vertex] = True \n\n    for neighbour in neighbours(AMat=Amat, to_explore=source_vertex):\n        if not visited[neighbour]: \n            parent[neighbour] = source_vertex\n            visited , parent = DFSAmat(Amat=Amat, source_vertex=neighbour )\n    return visited , parent\n</code></pre> <pre><code>visited , parent = DFSinit(AMat=adj_matrix) \nDFSAmat(adj_matrix, 0 )\n</code></pre> <pre><code>({0: True,\n  1: True,\n  2: True,\n  3: True,\n  4: True,\n  5: True,\n  6: True,\n  7: True,\n  8: True},\n {0: -1, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 2, 7: 3, 8: 3})\n</code></pre> <pre><code>del visited\ndel parent\n</code></pre> <pre><code>def create_Alist(AMat):\n    AList = {}\n    for  parent in range(AMat.shape[0]):\n        neighbours = []\n        for neighbour in range(AMat.shape[1]):\n            if AMat[parent, neighbour] ==1 :\n                neighbours.append(neighbour)\n        AList[parent] = neighbours\n    return AList\n</code></pre> <pre><code>Alist = create_Alist(adj_matrix)\n</code></pre> <pre><code>visited = {}\nparent = {}\ndef DFSinit(AList):\n    \"\"\"\n    Initializes the visited and parent dictionaries for Depth-First Search (DFS).\n\n    Parameters:\n    AMat : numpy.ndarray\n        The adjacency matrix representing the graph.\n\n    Returns:\n    visited : dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the DFS tree, or -1 if no parent (for the starting vertex).\n    \"\"\"\n    global visited\n    global parent \n\n    for i in AList.keys():\n        visited[i] = False\n        parent[i] = -1\n\n    return visited, parent\n\n\n\ndef DFSList(AList ,source_vertex):\n    \"\"\"\n    Performs Depth-First Search (BFS) on a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat : list of list\n        The adjacency matrix representing the graph.\n    visited : dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    parent : dict\n        A dictionary where keys are the vertices and values are integers representing\n        the parent vertex in the BFS tree, or -1 if no parent (for the source vertex).\n    source_vertex : int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited : dict\n        Updated dictionary indicating which vertices have been visited after BFS.\n    parent : dict\n        Updated dictionary representing the parent vertices after BFS.\n    \"\"\"\n    global visited\n    global parent \n    visited[source_vertex] = True \n\n    for neighbour in  AList[source_vertex]:\n        if not visited[neighbour]: \n            parent[neighbour] = source_vertex\n            visited , parent = DFSAmat(AList=AList, source_vertex=neighbour )\n    return visited , parent\n</code></pre> <pre><code>visited , parent = DFSinit(AList=Alist)\n\nDFSList(AList=Alist , source_vertex=0 )\n</code></pre> <pre><code>({0: True,\n  1: True,\n  2: True,\n  3: True,\n  4: True,\n  5: True,\n  6: True,\n  7: True,\n  8: True},\n {0: -1, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 2, 7: 3, 8: 3})\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/DFS_4_4/","title":"DFS 4 4","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.3529000170819927e-05\n</code></pre> <pre><code>def DFSInitList(AList):\n    \"\"\"\n    Initializes the visited and parent dictionaries for each node in the graph.\n\n    Parameters:\n        AList (dict): The adjacency list representation of the graph.\n\n    Returns:\n        tuple: A tuple containing two dictionaries:\n               - visited: A dictionary to track visited nodes, initialized to False.\n               - parent: A dictionary to track parent nodes, initialized to -1.\n    \"\"\"\n    visited = {}\n    parent = {}\n    for i in AList.keys():\n        visited[i] = False\n        parent[i] = -1\n    return (visited, parent)\n\n\ndef DFSList(AList, visited, parent, v):\n    \"\"\"\n    Performs Depth-First Search (DFS) traversal recursively starting from node v.\n\n    Parameters:\n        AList (dict): The adjacency list representation of the graph.\n        visited (dict): A dictionary to track visited nodes.\n        parent (dict): A dictionary to track parent nodes.\n        v (hashable): The current node being visited.\n\n    Returns:\n        tuple: A tuple containing two dictionaries:\n               - visited: Updated dictionary with visited nodes.\n               - parent: Updated dictionary with parent nodes.\n    \"\"\"\n    visited[v] = True\n    for k in AList[v]:\n        if not visited[k]:\n            parent[k] = v\n            DFSList(AList, visited, parent, k)\n    return (visited, parent)\n\n\ndef DFSGlobal(AList, k):\n    \"\"\"\n    Initializes DFS and starts DFS traversal from node k in the graph.\n\n    Parameters:\n        AList (dict): The adjacency list representation of the graph.\n        k (hashable): The starting node for DFS traversal.\n\n    Returns:\n        tuple: A tuple containing two dictionaries:\n               - visited: Dictionary with visited nodes after DFS traversal.\n               - parent: Dictionary with parent nodes after DFS traversal.\n    \"\"\"\n    (visited, parent) = DFSInitList(AList)\n    (visited, parent) = DFSList(AList, visited, parent, k)\n    return (visited, parent)\n\n\n# Example usage:\nAList = {\n    \"A\": [\"B\", \"C\"],\n    \"B\": [\"A\", \"D\", \"E\"],\n    \"C\": [\"A\", \"F\"],\n    \"D\": [\"B\"],\n    \"E\": [\"B\", \"F\"],\n    \"F\": [\"C\", \"E\"],\n}\n\n# Starting node\nstart_node = \"A\"\nvisited, parent = DFSGlobal(AList, start_node)\nprint(\"Visited nodes:\", visited)\nprint(\"Parent nodes:\", parent)\n</code></pre> <pre><code>Visited nodes: {'A': True, 'B': True, 'C': True, 'D': True, 'E': True, 'F': True}\nParent nodes: {'A': -1, 'B': 'A', 'C': 'F', 'D': 'B', 'E': 'B', 'F': 'E'}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/","title":"Lecture 4.1 - Introduction to graphs_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#lecture-41-introduction-to-graphs_pdf-pdf-file","title":"Lecture 4.1 - Introduction to graphs_.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#introduction-to-graphs","title":"Introduction to Graphs","text":"<p>Definition: A graph is a data structure that represents a set of objects (called vertices or nodes) and a set of relationships (called edges) between those objects.</p> <p>Components: * Vertices: Entities or objects of interest. * Edges: Connections or relationships between vertices.</p> <p>Types of Graphs:</p> <ul> <li>Directed graphs: Edges have a direction, indicating a one-way relationship between vertices.</li> <li>Undirected graphs: Edges do not have a direction, indicating a bidirectional relationship between vertices.</li> </ul>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#paths-and-reachability","title":"Paths and Reachability","text":"<p>Path: A sequence of vertices connected by edges.</p> <p>Reachability: Determining whether there exists a path from one vertex to another in a directed graph.</p>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#graph-applications","title":"Graph Applications","text":"<p>Graphs are widely used in various applications, including:</p> <ul> <li>Map coloring: Determining the minimum number of colors needed to color a map without adjacent regions having the same color.</li> <li>Vertex cover: Finding the minimum number of vertices that cover all edges in a graph.</li> <li>Independent set: Identifying a subset of vertices that are not connected by any edges.</li> <li>Matching: Assigning pairs of vertices (e.g., people, projects) based on compatibility or availability.</li> </ul>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#graph-representation-in-python","title":"Graph Representation in Python","text":"<p>In Python, graphs can be represented using various data structures, including:</p> <ul> <li>Adjacency list: A dictionary where each key represents a vertex and the corresponding value is a list of adjacent vertices.</li> <li>Adjacency matrix: A 2D array where the rows and columns represent vertices, and a non-zero value indicates an edge between the corresponding vertices.</li> <li>NetworkX library: A dedicated library for graph manipulation and analysis.</li> </ul>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#graph-traversal-and-search","title":"Graph Traversal and Search","text":"<p>Depth-first search (DFS): Traverses a graph by following edges until a dead end is reached, then backtracking to explore other paths.</p> <p>Breadth-first search (BFS): Traverses a graph by visiting all vertices at the same level before moving to the next level.</p>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#minimum-spanning-tree","title":"Minimum Spanning Tree","text":"<p>A minimum spanning tree is a subgraph of a connected graph that includes all vertices but has the minimum possible total edge weight.</p>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#shortest-path","title":"Shortest Path","text":"<p>Finding the shortest path between two vertices in a graph is a fundamental graph problem with numerous applications, such as route planning and network optimization.</p>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#graph-optimization-problems","title":"Graph Optimization Problems","text":"<p>Graphs can also be used to solve optimization problems, such as:</p> <ul> <li>Maximum flow: Determining the maximum amount of flow that can pass through a network.</li> <li>Minimum cut: Partitioning a graph into two disjoint sets while minimizing the number of edges between them.</li> <li>Traveling salesman problem: Finding the shortest possible path that visits a set of cities and returns to the starting city. Lec file</li> </ul>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#lecture-41-introduction-to-graphs_pdf-pdf-file_1","title":"Lecture 4.1 - Introduction to graphs_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.2%20-%20Representing%20Graphs_/","title":"Lecture 4.2 - Representing Graphs_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.2%20-%20Representing%20Graphs_/#lecture-42-representing-graphs_pdf-pdf-file","title":"Lecture 4.2 - Representing Graphs_.pdf (PDF file)","text":"<p>Summary Graph Representation</p> <p>A graph is a data structure that consists of nodes or vertices connected by edges. In computer science, graphs are used to represent various types of relationships and networks, such as social networks, transportation systems, and computer networks.</p> <p>Adjacency Matrix Representation</p> <p>An adjacency matrix is a two-dimensional square matrix used to represent a graph. The rows and columns of the matrix correspond to the vertices of the graph. The value of the element at the intersection of row i and column j indicates whether there is an edge between vertex i and vertex j. A value of 1 typically represents an edge, while a value of 0 represents the absence of an edge.</p> <p>Advantages of Adjacency Matrix Representation:</p> <ul> <li>Easy to implement and understand.</li> <li>Efficient for dense graphs (graphs with a high number of edges).</li> <li>Allows for constant-time lookup to determine if there is an edge between two vertices.</li> </ul> <p>Disadvantages of Adjacency Matrix Representation:</p> <ul> <li>Requires O(V^2) space, where V is the number of vertices in the graph.</li> <li>Not efficient for sparse graphs (graphs with a low number of edges) due to the large amount of unused space.</li> </ul> <p>Adjacency List Representation</p> <p>An adjacency list is a collection of lists, where each list represents the set of vertices that are adjacent to a particular vertex. The index of each list corresponds to a vertex in the graph. The elements of each list are the vertices that are connected to the vertex at the corresponding index.</p> <p>Advantages of Adjacency List Representation:</p> <ul> <li>Requires O(V + E) space, where V is the number of vertices and E is the number of edges in the graph.</li> <li>Efficient for sparse graphs as it only stores the existing edges.</li> <li>Easy to add and remove edges dynamically.</li> </ul> <p>Disadvantages of Adjacency List Representation:</p> <ul> <li>Less efficient for dense graphs due to the need to iterate over all adjacent vertices.</li> <li>May require additional data structures to store edge weights or other edge-related information.</li> </ul> <p>Choosing the Right Representation</p> <p>The choice of graph representation depends on the specific requirements and characteristics of the graph. For dense graphs, the adjacency matrix representation may be more efficient due to its constant-time lookup capability. For sparse graphs, the adjacency list representation is typically preferred due to its space efficiency.</p> <p>Other Graph Representations</p> <p>Besides adjacency matrix and adjacency list representations, there are other graph representations that may be suitable for specific applications, such as:</p> <ul> <li>Edge List Representation: Stores edges as a list of tuples, where each tuple represents an edge between two vertices.</li> <li>Incidence Matrix Representation: A binary matrix that indicates the incidence of edges with vertices.</li> <li>Incidence List Representation: Similar to an adjacency list, but maintains a list of edges incident on each vertex.</li> </ul> <p>Applications of Graphs</p> <p>Graphs have numerous applications in various domains, including:</p> <ul> <li>Social Network Analysis: Modeling relationships between individuals in a social network.</li> <li>Transportation Systems: Representing road networks, flight routes, or public transportation systems.</li> <li>Computer Networks: Modeling network topologies and routing protocols.</li> <li>Data Structures: Representing hierarchical data structures or complex relationships between data items.</li> <li>Scientific Computing: Modeling physical systems, chemical structures, or biological networks.</li> </ul> <p>Understanding the different graph representations and their respective advantages and disadvantages is essential for selecting the appropriate representation for the task at hand and effectively working with graphs in various applications.</p>"},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_/","title":"Lecture 4.3 - Breadth First Search (BFS)_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_/#lecture-43-breadth-first-search-bfs_pdf-pdf-file","title":"Lecture 4.3 - Breadth First Search (BFS)_.pdf (PDF file)","text":"<p>Summary Breadth First Search</p> <p>Reachability in a graph - Mark source vertex as reachable - Systematically mark neighbours of marked vertices - Stop when target becomes marked</p> <p>Choose an appropriate representation - Adjacency matrix - Adjacency list</p> <p>Strategies for systematic exploration - Breadth first \u2014 propagate marks in \u201clayers\u201d - Depth first \u2014 explore a path till it dies out, then backtrack</p> <p>Breadth First Search (BFS) - Explore the graph level by level - First visit vertices one step away - Then two steps away - . . . - Each visited vertex has to be explored</p> <p>Breadth first search (BFS) - Assume V = {0, 1, . . . , n \u2212 1} -visited : V \u2192 {True, False} tells us whether v \u2208 V has been visited -Initially, visited(v) = False for all v \u2208 V -Maintain a sequence of visited vertices yet to be explored -A queue \u2014 first in, first out</p> <p>Exploring a vertex i - For each edge (i, j), if visited(j) is False, - Set visited(j) to True - Append j to the queue</p> <p>BFS . . . -Assume V = {0, 1, . . . , n \u2212 1} -visited : V \u2192 {True, False} tells us whether v \u2208 V has been visited -Initially, visited(v) = False for all v \u2208 V -Maintain a sequence of visited vertices yet to be explored -A queue \u2014 first in, first out -Exploring a vertex i - For each edge (i, j), if visited(j) is False, - Set visited(j) to True - Append j to the queue</p> <p>BFS . . . - q = Queue() -for i in range(3): - q.addq(i) -print(q) -print(q.isempty()) -for j in range(3): - print(q.delq(),q) -print(q.isempty())</p> <p>BFS . . . -Initially -visited(v) = False for all v \u2208 V -Queue of vertices to be explored is empty -Start BFS from vertex j -Set visited(j) = True -Add j to the queue -Remove and explore vertex i at head of queue -For each edge (i, j), if visited(j) is False, - Set visited(j) to True - Append j to the queue -Stop when queue is empty</p> <p>BFS from vertex 7 -Visited 0 False 1 False 2 False 3 False 4 False 5 False 6 False 7 False 8 False 9 False -To explore queue -Mark 7 and add to queue</p> <p>BFS from vertex 7 -Visited 0 True 1 False 2 False 3 False 4 False 5 False 6 False 7 True 8 False 9 False -To explore queue -7</p> <p>BFS from vertex 7 -Visited 0 True 1 False 2 False 3 False 4 True 5 True 6 False 7 True 8 True 9 False -To explore queue -4 5 8</p> <p>BFS from vertex 7 -Visited 0 True 1 False 2 False 3 True 4 True 5 True 6 False 7 True 8 True 9 False -To explore queue -5 8 0 3</p> <p>BFS from vertex 7 -Visited 0 True 1 False 2 False 3 True 4 True 5 True 6 True 7 True 8 True 9 False -To explore queue -8 0 3 6</p> <p>BFS from vertex 7 -Visited 0 True 1 True 2 True 3 True 4 True 5 True 6 True 7 True 8 True 9 False -To explore queue -0 3 6 9</p> <p>BFS from vertex 7 -Visited 0 True 1 True 2 True 3 True 4 True 5 True 6 True 7 True 8 True 9 True -To explore queue -3 6 9 1 2</p> <p>BFS from vertex 7 -Visited 0 True 1 True 2 True 3 True 4 True 5 True 6 True 7 True 8 True 9 True -To explore queue -6 9 1 2</p> <p>BFS from vertex 7 -Visited 0 True 1 True 2 True 3 True 4 True 5 True 6 True 7 True 8 True 9 True -To explore queue -9 1 2</p> <p>BFS from vertex 7 -Visited 0 True 1 True 2 True 3 True 4 True 5 True 6 True 7 True 8 True 9 True -To explore queue -1 2</p> <p>BFS from vertex 7 -Visited 0 True 1 True 2 True 3 True 4 True 5 True 6 True 7 True 8 True 9 True -To explore queue -2</p> <p>BFS from vertex 7 -Visited 0 True 1 True 2 True 3 True 4 True 5 True 6 True 7 True 8 True 9 True -To explore queue</p> <p>Complexity of BFS -G = (V, E) -|V| = n -|E| = m -If G is connected, m can vary from n \u2212 1 to n(n \u2212 1)/2 -In BFS, each reachable vertex is processed exactly once -Visit the vertex: add to queue -Explore the vertex: remove from queue -Visit and explore at most n vertices -Exploring a vertex -Check all outgoing edges -How long does this take?</p> <p>Complexity of BFS -G = (V, E) -|V| = n -|E| = m -If G is connected, m can vary from n \u2212 1 to n(n \u2212 1)/2 -In BFS, each reachable vertex is processed exactly once -Visit the vertex: add to queue -Explore the vertex: remove from queue -Visit and explore at most n vertices -Exploring a vertex -Check all outgoing edges -How long does this take?</p> <p>Complexity of BFS -G = (V, E) -|V| = n -|E| = m -If G is connected, m can vary from n \u2212 1 to n(n \u2212 1)/2 -In BFS, each reachable vertex is processed exactly once -Visit the vertex: add to queue -Explore the vertex: remove from queue -Visit and explore at most n vertices -Exploring a vertex -Check all outgoing edges -How long does this take?</p> <p>Complexity of BFS -Adjacency matrix -To explore i, scan neighbours(i) -Look up n entries in row i, regardless of degree(i)</p> <p>Complexity of BFS -Adjacency matrix -To explore i, scan neighbours(i) -Look up n entries in row i, regardless of degree(i) -Adjacency list -List neighbours(i) is directly available -Time to explore i is degree(i) -Degree varies across vertices</p> <p>Complexity of BFS -BFS with adjacency matrix -n steps to initialize each vertex -n steps to explore each vertex -Overall time is O(n\\r\\n2\\r\\n)</p> <p>Complexity of BFS -BFS with adjacency matrix -n steps to initialize each vertex -n steps to explore each vertex -Overall time is O(n\\r\\n2\\r\\n) -BFS with adjacency list -n steps to initialize each vertex -2m steps (sum of degrees) to explore all vertices -An example of amortized analysis -Overall time is O(n + m)</p> <p>Complexity of BFS -If m \\x1c n\\r\\n2\\r\\n, working with adjacency lists is much more efficient -This is why we treat m and n as separate parameters -For graphs, O(m + n) is typically the best possible complexity -Need to see each each vertex and edge at least once -Linear time</p> <p>Enhancing BFS to record paths -If BFS from i sets visited(k) = True, we know that k is reachable from i -How do we recover a path from i to k? -visited(k) was set to True when exploring some vertex j -Record parent(k) = j -From k, follow parent links to trace back a path to i</p> <p>Enhancing BFS to record paths -If BFS from i sets visited(k) = True, we know that k is reachable from i -How do we recover a path from i to k? -visited(k) was set to True when exploring some vertex j -Record parent(k) = j -From k, follow parent links to trace back a path to i</p> <p>**</p>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/","title":"Lecture 4.4 - Depth First Search (DFS)_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#lecture-44-depth-first-search-dfs_pdf-pdf-file","title":"Lecture 4.4 - Depth First Search (DFS)_.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#depth-first-search-dfs","title":"Depth First Search (DFS)","text":"<p>DFS is a systematic strategy to explore a graph. It starts from a vertex, visits an unexplored neighbor, suspends the exploration of the current vertex, and explores the neighbor instead. It continues until it reaches a vertex with no unexplored neighbors. DFS then backtracks to the nearest suspended vertex that still has an unexplored neighbor.</p>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#key-concepts","title":"Key Concepts","text":"<ul> <li>Stack: DFS uses a stack to store suspended vertices. The most recently suspended vertex is checked first.</li> <li>Visited: A boolean array to mark visited vertices.</li> <li>Parent: An array that stores the parent of each vertex.</li> </ul>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#implementation","title":"Implementation","text":"<p>DFS can be implemented using recursion or iteration.</p> <p>Recursive Implementation:</p> <pre><code>def DFS(AMat, visited, parent, v):\n  visited[v] = True\n  for k in neighbors(AMat, v):\n    if not visited[k]:\n      parent[k] = v\n      DFS(AMat, visited, parent, k)\n</code></pre> <p>Iterative Implementation:</p> <pre><code>def DFS(AMat, visited, parent, v):\n  stack = [v]\n  while stack:\n    v = stack.pop()\n    if not visited[v]:\n      visited[v] = True\n      for k in neighbors(AMat, v):\n        if not visited[k]:\n          parent[k] = v\n          stack.append(k)\n</code></pre>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#complexity","title":"Complexity","text":"<p>The complexity of DFS is:</p> <ul> <li>O(n\u00b2) using an adjacency matrix.</li> <li>O(m + n) using an adjacency list.</li> </ul>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#applications","title":"Applications","text":"<p>DFS is used in:</p> <ul> <li>Finding connected components in a graph.</li> <li>Finding cycles in a graph.</li> <li>Topological sorting.</li> <li>Finding the minimum spanning tree of a graph.</li> <li>Solving mazes.</li> <li>Detecting deadlocks in multithreaded programs.</li> </ul>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#advantages","title":"Advantages","text":"<ul> <li>DFS is easy to implement.</li> <li>DFS can explore graphs with cycles.</li> <li>DFS can find the shortest path between two vertices.</li> </ul>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#disadvantages","title":"Disadvantages","text":"<ul> <li>DFS can produce non-optimal solutions.</li> <li>DFS can require more memory than BFS.</li> <li>DFS can get stuck in deep paths.</li> </ul>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/","title":"Lecture 4.5 - Applications of BFS and DFS.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#lecture-45-applications-of-bfs-and-dfspdf-pdf-file","title":"Lecture 4.5 - Applications of BFS and DFS.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#applications-of-breadth-first-search-and-depth-first-search","title":"Applications of Breadth First Search and Depth First Search","text":"<p>Breadth First Search (BFS) and Depth First Search (DFS) are two fundamental graph traversal algorithms. They can be used to solve a variety of problems, including finding connected components, detecting cycles, and finding the shortest path between two vertices.</p>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#connectivity","title":"Connectivity","text":"<p>BFS and DFS can be used to identify connected components in both undirected and directed graphs. A connected component is a set of vertices that are all reachable from each other. In an undirected graph, a connected component is simply a set of vertices that are connected by edges. In a directed graph, a connected component is a set of vertices that are all reachable from each other by following the direction of the edges.</p> <p>To find the connected components in a graph, you can use the following algorithm:</p> <ol> <li>Start at any vertex in the graph.</li> <li>Perform a BFS or DFS traversal of the graph, starting from the current vertex.</li> <li>Add all of the vertices that are visited during the traversal to the current connected component.</li> <li>Repeat steps 1-3 until all of the vertices in the graph have been visited.</li> </ol> <p>The output of the algorithm will be a set of connected components. Each connected component will be represented by a set of vertices.</p>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#cycles","title":"Cycles","text":"<p>BFS and DFS can be used to detect cycles in both undirected and directed graphs. A cycle is a path that starts and ends at the same vertex. In an undirected graph, a cycle is simply a set of edges that form a closed loop. In a directed graph, a cycle is a set of edges that form a closed loop and follow the direction of the edges.</p> <p>To detect cycles in a graph, you can use the following algorithm:</p> <ol> <li>Start at any vertex in the graph.</li> <li>Perform a DFS traversal of the graph, starting from the current vertex.</li> <li>If you visit a vertex that has already been visited, then there is a cycle in the graph.</li> </ol> <p>The output of the algorithm will be a set of cycles. Each cycle will be represented by a set of edges.</p>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#shortest-path","title":"Shortest Path","text":"<p>BFS can be used to find the shortest path between two vertices in an undirected graph. The shortest path between two vertices is the path with the fewest number of edges.</p> <p>To find the shortest path between two vertices in an undirected graph, you can use the following algorithm:</p> <ol> <li>Start at the source vertex.</li> <li>Perform a BFS traversal of the graph, starting from the source vertex.</li> <li>Keep track of the distance from the source vertex to each vertex that is visited.</li> <li>The shortest path to the destination vertex is the path with the smallest distance.</li> </ol> <p>The output of the algorithm will be the shortest path between the source vertex and the destination vertex. The shortest path will be represented by a set of edges.</p>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#other-applications","title":"Other Applications","text":"<p>BFS and DFS can be used to solve a variety of other problems, including:</p> <ul> <li>Finding articulation points (cut vertices) and bridges (cut edges)</li> <li>Finding topological order in a directed acyclic graph</li> <li>Finding the minimum spanning tree of a graph</li> <li>Finding the maximum flow in a network</li> </ul> <p>BFS and DFS are powerful algorithms that can be used to solve a wide variety of problems. They are essential tools for any programmer who works with graphs.</p>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#summary","title":"Summary","text":"<p>The following table summarizes the key features of BFS and DFS:</p> Feature BFS DFS Traversal order Level-by-level Depth-first Space complexity O(V) O(V) Time complexity O(E) O(E) Applications Finding connected components, detecting cycles, finding shortest path Finding articulation points, bridges, topological order"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#example","title":"Example","text":"<p>The following Python code shows how to use BFS and DFS to find the connected components in a graph:</p> <pre><code>from collections import deque\n\ndef bfs(graph, start):\n  \"\"\"\n  Perform a BFS traversal of the graph starting from the given start vertex.\n\n  Args:\n    graph: The graph to traverse.\n    start: The start vertex.\n\n  Returns:\n    A set of connected components.\n  \"\"\"\n\n  visited = set()\n  components = []\n\n  queue = deque([start])\n\n  while queue:\n    vertex = queue.popleft()\n    if vertex not in visited:\n      visited.add(vertex)\n      components.append({vertex})\n      for neighbor in graph[vertex]:\n        if neighbor not in visited:\n          queue.append(neighbor)\n\n  return components\n\n\ndef dfs(graph, start):\n  \"\"\"\n  Perform a DFS traversal of the graph starting from the given start vertex.\n\n  Args:\n    graph: The graph to traverse.\n    start: The start vertex.\n\n  Returns:\n    A set of connected components.\n  \"\"\"\n\n  visited = set()\n  components = []\n\n  stack = [start]\n\n  while stack:\n    vertex = stack.pop()\n    if vertex not in visited:\n      visited.add(vertex)\n      components.append({vertex})\n      for neighbor in graph[vertex]:\n        if neighbor not in visited:\n          stack.append(neighbor)\n\n  return components\n\n\nif __name__ == \"__main__\":\n  graph = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1, 3],\n    3: [2]\n  }\n\n  bfs_components = bfs(graph, 0)\n  print(\"BFS components:\", bfs_components)\n\n  dfs_components = dfs(graph, 0)\n  print(\"DFS components:\", dfs_components)\n</code></pre> <p>The output of the code is:</p> <pre><code>BFS components: [{0, 1, 2, 3}]\nDFS components: [{0, 1, 2, 3}]\n</code></pre> <p>As you can see, both BFS and DFS found the same connected component in the graph.</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/","title":"Lecture 4.6 - Introduction to Directed Acyclic Graph (DAG).pdf (PDF file)","text":""},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#lecture-46-introduction-to-directed-acyclic-graph-dagpdf-pdf-file","title":"Lecture 4.6 - Introduction to Directed Acyclic Graph (DAG).pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#directed-acyclic-graphs-dags","title":"Directed Acyclic Graphs (DAGs)","text":""},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#introduction","title":"Introduction","text":"<p>Directed Acyclic Graphs (DAGs) are a specialized type of graph used to represent dependencies or constraints in a system. Unlike their more general counterparts, directed graphs, DAGs do not contain any cycles or loops, meaning that it is impossible to move from one node to another while staying on the same edge.</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#representing-dependencies-as-a-dag","title":"Representing Dependencies as a DAG","text":"<p>DAGs are commonly used to represent constraints or dependencies between tasks or events. Each node in the graph represents a task or event, while the edges represent the dependencies between them. If task A must be completed before task B can start, an edge will be drawn from A to B.</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#scheduling-tasks-with-dags","title":"Scheduling Tasks with DAGs","text":"<p>One of the main applications of DAGs is scheduling tasks while respecting the dependencies between them. A valid schedule is one that follows the order specified by the DAG, ensuring that all dependencies are met.</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#topological-sorting","title":"Topological Sorting","text":"<p>Topological sorting is a technique used to find an ordering of the nodes in a DAG that respects the dependencies between them. This ordering can be used to create a schedule or to determine the overall duration of a project.</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#longest-path-in-a-dag","title":"Longest Path in a DAG","text":"<p>In some cases, we are interested in finding the longest path in a DAG. This represents the critical path, the sequence of tasks that determines the overall duration of the project.</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#summary","title":"Summary","text":"<p>DAGs are a powerful tool for representing dependencies and constraints in a system. They are used in various applications, including scheduling, task management, and project planning. Key problems that can be solved using DAGs include topological sorting and finding the longest path.</p>"},{"location":"week4/Lecture%204.7%20-%20Topological%20Sorting/","title":"Lecture 4.7 - Topological Sorting.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.7%20-%20Topological%20Sorting/#lecture-47-topological-sortingpdf-pdf-file","title":"Lecture 4.7 - Topological Sorting.pdf (PDF file)","text":"<p>Summary Topological Sorting</p> <p>Topological sorting is a technique used to order the vertices of a directed acyclic graph (DAG) in a way that respects the dependencies between the vertices. A DAG is a directed graph with no directed cycles, meaning that there is no path from any vertex back to itself.</p> <p>Applications of Topological Sorting</p> <p>Topological sorting has many applications in computer science, including:</p> <ul> <li>Scheduling tasks that have dependencies</li> <li>Finding the order of compilation for a set of source files</li> <li>Determining the order of execution for a set of instructions in a program</li> <li>Resolving conflicts in version control systems</li> </ul> <p>Algorithm for Topological Sorting</p> <p>There are several different algorithms for performing topological sorting. One common algorithm works as follows:</p> <ol> <li>Start with an empty list of sorted vertices.</li> <li>Find a vertex with no incoming edges (i.e., a vertex with an indegree of 0).</li> <li>Add the vertex to the sorted list.</li> <li>Delete the vertex and all of its outgoing edges from the graph.</li> <li>Repeat steps 2-4 until all vertices have been added to the sorted list.</li> </ol> <p>Complexity of Topological Sorting</p> <p>The time complexity of topological sorting is O(V + E), where V is the number of vertices in the graph and E is the number of edges.</p> <p>Proof of Correctness</p> <p>The topological sorting algorithm is correct because it maintains the following invariant:</p> <ul> <li>The sorted list contains a subset of the vertices in the graph.</li> <li>The vertices in the sorted list are ordered in such a way that there are no edges from any vertex in the sorted list to any vertex that is not in the sorted list.</li> </ul> <p>This invariant is established by the following steps in the algorithm:</p> <ul> <li>When a vertex with no incoming edges is added to the sorted list, it is added to the end of the list. This ensures that there are no edges from any vertex in the sorted list to the newly added vertex.</li> <li>When a vertex is deleted from the graph, all of its outgoing edges are also deleted. This ensures that there are no edges from any vertex in the sorted list to any vertex that is not in the sorted list.</li> </ul> <p>Example</p> <p>Consider the following DAG:</p> <pre><code>A -&gt; B\nB -&gt; C\nC -&gt; D\nD -&gt; E\n</code></pre> <p>The following is a topological sort of this DAG:</p> <pre><code>[A, B, C, D, E]\n</code></pre> <p>Additional Notes</p> <ul> <li>Topological sorting is not unique. There may be multiple different topological sorts of the same DAG.</li> <li>The choice of which vertex to add to the sorted list in step 2 of the algorithm is arbitrary. Any vertex with an indegree of 0 can be added.</li> <li>Topological sorting can be used to detect cycles in a directed graph. If the algorithm is unable to find a vertex with an indegree of 0, then the graph contains a cycle.</li> </ul>"},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/","title":"Lecture 4.8 - Longest Path in DAGs.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/#lecture-48-longest-path-in-dagspdf-pdf-file","title":"Lecture 4.8 - Longest Path in DAGs.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/#longest-paths-in-dags","title":"Longest Paths in DAGs","text":"<p>Directed acyclic graphs (DAGs) are a special type of graph that does not contain any cycles. This makes them a natural way to representdependencies, such as in a prerequisite graph or a job dependency graph.</p> <p>One important problem that arises in the context of DAGs is finding the longest path from a given source vertex to a given destination vertex. The longest path problem can be used to determine the minimum number of steps required to complete a task, or the longest possible sequence of events that can occur in a system.</p> <p>Topological sorting is an algorithm that can be used to find a linear ordering of the vertices in a DAG. This ordering is such that, for any edge (u, v) in the DAG, u comes before v in the ordering. Topological sorting can be used to find the longest path in a DAG by starting at the source vertex and following the edges in the topological order. The longest path will be the path that ends at the destination vertex.</p> <p>The following pseudocode implements a topological sort algorithm:</p> <pre><code>def topological_sort(G):\n  \"\"\"\n  Perform topological sort on a DAG.\n\n  Args:\n    G: A DAG.\n\n  Returns:\n    A list of vertices in topological order.\n  \"\"\"\n\n  # Initialize a stack to store the vertices.\n  stack = []\n\n  # Initialize a set to store the visited vertices.\n  visited = set()\n\n  # Iterate over the vertices in the graph.\n  for v in G.vertices:\n    # If the vertex has not been visited, perform a topological sort on it.\n    if v not in visited:\n      topological_sort_helper(v, stack, visited)\n\n  # Return the stack.\n  return stack\n\n\ndef topological_sort_helper(v, stack, visited):\n  \"\"\"\n  Helper function for topological sort.\n\n  Args:\n    v: The vertex to perform topological sort on.\n    stack: The stack to store the vertices.\n    visited: The set to store the visited vertices.\n  \"\"\"\n\n  # Mark the vertex as visited.\n  visited.add(v)\n\n  # Iterate over the edges in the graph.\n  for (v, w) in G.edges:\n    # If the edge has not been visited, perform a topological sort on it.\n    if (v, w) not in visited:\n      topological_sort_helper(w, stack, visited)\n\n  # Push the vertex onto the stack.\n  stack.append(v)\n</code></pre> <p>Once the topological sort has been performed, the longest path can be found by starting at the source vertex and following the edges in the topological order. The longest path will be the path that ends at the destination vertex.</p> <p>The following pseudocode implements an algorithm to find the longest path in a DAG:</p> <pre><code>def longest_path(G, source, destination):\n  \"\"\"\n  Find the longest path from a source vertex to a destination vertex in a DAG.\n\n  Args:\n    G: A DAG.\n    source: The source vertex.\n    destination: The destination vertex.\n\n  Returns:\n    The length of the longest path.\n  \"\"\"\n\n  # Perform topological sort on the graph.\n  topological_order = topological_sort(G)\n\n  # Initialize a dictionary to store the longest paths.\n  longest_paths = {}\n\n  # Iterate over the vertices in the topological order.\n  for v in topological_order:\n    # If the vertex is the source vertex, set the longest path to 0.\n    if v == source:\n      longest_paths[v] = 0\n\n    # Otherwise, iterate over the edges in the graph.\n    else:\n      longest_paths[v] = max([longest_paths[u] + 1 for (u, v) in G.edges if u in longest_paths])\n\n  # Return the longest path to the destination vertex.\n  return longest_paths[destination]\n</code></pre> <p>The time complexity of the longest path algorithm is O(m + n), where m is the number of edges in the DAG and n is the number of vertices in the DAG.</p>"},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/#applications-of-longest-paths-in-dags","title":"Applications of Longest Paths in DAGs","text":"<p>The longest path problem has a number of applications in computer science. Some of these applications include:</p> <ul> <li>Scheduling: The longest path problem can be used to find the minimum number of steps required to complete a task. This can be used to schedule tasks in a way that minimizes the overall completion time.</li> <li>Job dependency: The longest path problem can be used to find the longest possible sequence of events that can occur in a system. This can be used to identify potential bottlenecks in the system and to improve the system's performance.</li> <li>Critical path analysis: The longest path problem can be used to find the critical path in a project. The critical path is the sequence of tasks that must be completed on time in order for the project to be completed on time.</li> </ul>"},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/#conclusion","title":"Conclusion","text":"<p>The longest path problem is a fundamental problem in computer science. It has a number of applications in scheduling, job dependency, and critical path analysis. There are a number of algorithms that can be used to solve the longest path problem, including the topological sort algorithm and the longest path algorithm.</p>"},{"location":"week4/longest_path4_8/","title":"Longest path4 8","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.27989999075362e-05\n</code></pre> <pre><code>from queue import Queue\n\n\ndef longestpathlist(AList):\n    \"\"\"\n    Computes the longest path in a directed acyclic graph (DAG) using an adjacency list.\n\n    Parameters:\n    AList (dict): Adjacency list representing the graph, where keys are nodes and values are lists of adjacent nodes.\n\n    Returns:\n    dict: A dictionary where keys are nodes and values are the lengths of the longest paths ending at those nodes.\n    \"\"\"\n\n    # Initialize indegree and longest path length dictionaries\n    indegree = {}\n    lpath = {}\n    for u in AList.keys():\n        indegree[u] = 0\n        lpath[u] = 0\n\n    # Compute indegree for each node\n    for u in AList.keys():\n        for v in AList[u]:\n            indegree[v] += 1\n\n    # Initialize the zero degree queue\n    zerodegreeq = Queue()\n    for u in AList.keys():\n        if indegree[u] == 0:\n            zerodegreeq.put(u)\n\n    # Process nodes with zero indegree\n    while not zerodegreeq.empty():\n        j = zerodegreeq.get()\n\n        for k in AList[j]:\n            indegree[k] -= 1\n            lpath[k] = max(lpath[k], lpath[j] + 1)\n            if indegree[k] == 0:\n                zerodegreeq.put(k)\n\n    return lpath\n\n\n# Example usage:\nAList = {\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}\n\n# Prints the longest path lengths from each node\nprint(longestpathlist(AList))\n</code></pre> <pre><code>{'A': 0, 'B': 1, 'C': 1, 'D': 2, 'E': 3}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/pending/","title":"Pending","text":"<ul> <li>[X] 4.1</li> <li>[X] 4.2</li> <li>[X] 4.3</li> <li>[X] 4.4</li> <li>[X] 4.5</li> <li>[X] 4.6</li> <li>[X] 4.7</li> <li>[X] 4.8</li> </ul>"},{"location":"week4/possible_degree/","title":"Possible degree","text":"<p>To determine a possible listing of the degrees of vertices in an undirected graph with 7 vertices, we need to consider some fundamental properties and constraints of graphs:</p> <ol> <li>Handshaking Lemma: The sum of the degrees of all vertices in an undirected graph is twice the number of edges. This implies that the sum of the degrees must be even.</li> <li>Degree Sequence: A sequence is a degree sequence if it can be realized as the degree sequence of some graph. The sequence must satisfy the Erd\u0151s\u2013Gallai theorem, which provides a necessary and sufficient condition for a sequence to be graphical.</li> </ol> <p>Given these properties, let's evaluate each of the provided degree sequences.</p>"},{"location":"week4/possible_degree/#checking-each-sequence","title":"Checking Each Sequence","text":"<ol> <li> <p>Sequence: 6, 6, 5, 4, 3, 2, 1</p> </li> <li> <p>Sum of degrees = 6 + 6 + 5 + 4 + 3 + 2 + 1 = 27</p> </li> <li>Sum is odd, so this cannot be a valid degree sequence.</li> <li> <p>Sequence: 5, 5, 5, 4, 3, 2, 2</p> </li> <li> <p>Sum of degrees = 5 + 5 + 5 + 4 + 3 + 2 + 2 = 26</p> </li> <li>Sum is even. Now we need to check if it satisfies the Erd\u0151s\u2013Gallai conditions:<ul> <li>\\( k = 1 \\): \\( 5 \\leq 6 \\) (6 is the sum of the smallest 6 degrees)</li> <li>\\( k = 2 \\): \\( 10 \\leq 10 \\) (10 is the sum of the smallest 5 degrees)</li> <li>\\( k = 3 \\): \\( 15 \\leq 15 \\) (15 is the sum of the smallest 4 degrees)</li> <li>\\( k = 4 \\): \\( 19 \\leq 19 \\) (19 is the sum of the smallest 3 degrees plus the number of edges formed by them)</li> <li>\\( k = 5 \\): \\( 22 \\leq 23 \\) (22 is the sum of the smallest 2 degrees plus the number of edges formed by them)</li> <li>\\( k = 6 \\): \\( 24 \\leq 26 \\) (24 is the sum of the smallest 1 degree plus the number of edges formed by them)</li> </ul> </li> <li>Since all conditions are satisfied, this is a possible degree sequence.</li> <li> <p>Sequence: 6, 6, 6, 3, 2, 1, 1</p> </li> <li> <p>Sum of degrees = 6 + 6 + 6 + 3 + 2 + 1 + 1 = 25</p> </li> <li>Sum is odd, so this cannot be a valid degree sequence.</li> <li> <p>Sequence: 4, 4, 4, 4, 3, 3, 2</p> </li> <li> <p>Sum of degrees = 4 + 4 + 4 + 4 + 3 + 3 + 2 = 24</p> </li> <li>Sum is even. Now we need to check if it satisfies the Erd\u0151s\u2013Gallai conditions:<ul> <li>\\( k = 1 \\): \\( 4 \\leq 6 \\)</li> <li>\\( k = 2 \\): \\( 8 \\leq 10 \\)</li> <li>\\( k = 3 \\): \\( 12 \\leq 13 \\)</li> <li>\\( k = 4 \\): \\( 16 \\leq 16 \\)</li> <li>\\( k = 5 \\): \\( 19 \\leq 19 \\)</li> <li>\\( k = 6 \\): \\( 22 \\leq 24 \\)</li> </ul> </li> <li>Since all conditions are satisfied, this is a possible degree sequence.</li> <li> <p>Sequence: 5, 5, 4, 4, 3, 2, 1</p> </li> <li> <p>Sum of degrees = 5 + 5 + 4 + 4 + 3 + 2 + 1 = 24</p> </li> <li>Sum is even. Now we need to check if it satisfies the Erd\u0151s\u2013Gallai conditions:<ul> <li>\\( k = 1 \\): \\( 5 \\leq 6 \\)</li> <li>\\( k = 2 \\): \\( 10 \\leq 10 \\)</li> <li>\\( k = 3 \\): \\( 14 \\leq 13 \\) (Fails here)</li> </ul> </li> <li>Since one condition fails, this is not a possible degree sequence.</li> </ol>"},{"location":"week4/possible_degree/#conclusion","title":"Conclusion","text":"<p>Based on the evaluation, the possible listings of degrees are:</p> <ul> <li>5, 5, 5, 4, 3, 2, 2</li> <li>4, 4, 4, 4, 3, 3, 2</li> </ul> <p>So, the sequences \\( \\boxed{5, 5, 5, 4, 3, 2, 2} \\) and \\( \\boxed{4, 4, 4, 4, 3, 3, 2} \\) are possible listings of the degrees.</p>"},{"location":"week4/redo/","title":"Redo","text":"<pre><code>import numpy as np \nimport os \nfrom IPython.display import display, Markdown, Image\n\nos.chdir(\"..\")\nos.chdir(\"..\")\n\nfrom driver_folder.shared.graph import plot_graph_from_adj_list\n</code></pre>"},{"location":"week4/redo/#queue","title":"Queue","text":"<pre><code>class Queue:\n    def __init__(self):\n        self.queue = []\n\n    def addq(self , value_to_add):\n        self.queue.append(value_to_add)\n\n    def delq(self):\n        v = None \n        if not self.is_empty(): \n            v = self.queue.pop(0)\n        return v\n\n    def is_empty(self):\n        return self.queue == []\n\n    def __str__(self):\n        return str(self.queue)\n</code></pre> <pre><code>q = Queue()\nfor i in range(3):\n    q.addq(i)\nprint(q)\nprint(q.is_empty())\nfor j in range(3):\n    print(q.delq(),q)\nprint(q.is_empty())\n</code></pre> <pre><code>[0, 1, 2]\nFalse\n0 [1, 2]\n1 [2]\n2 []\nTrue\n</code></pre> <pre><code>AMat = np.array([\n    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 1, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 1, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]\n])\n</code></pre> <pre><code>fig = plot_graph_from_adj_list(adj_list=AMat)\n</code></pre> <pre><code># Save the graph as an image\nfig.write_image(\"graph_image.png\")\n\n# Display the plot\ndisplay(Image(filename=\"graph_image.png\"))\n</code></pre>"},{"location":"week4/redo/#bfs-using-adjacency-matrix","title":"BFS using Adjacency Matrix","text":"<pre><code>def neighbours(AMat , j):\n    neighbour = []\n    for col in range(AMat.shape[1]):\n        if AMat[j,col] ==1:\n            neighbour.append(col)\n    return neighbour    \n</code></pre> <pre><code>def BFS( AMat : np.array , V : int ):\n\n\n    rows , cols = AMat.shape \n\n    visited = {}\n\n    for node in range(rows):\n        visited[node] = False\n\n    queue= Queue()\n    visited[V] = True \n\n    queue.addq(V)\n\n    while not queue.is_empty():\n        j = queue.delq()\n        for N in neighbours(AMat=AMat, j = j):\n            if not visited[N]:\n                queue.addq(N)\n                visited[N] = True \n    return visited\n</code></pre> <pre><code>start_vertex = 0\nvisited = BFS(AMat, start_vertex)\nprint(visited)\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\n</code></pre>"},{"location":"week4/redo/#bfs-using-adjacency-list","title":"BFS using Adjacency list","text":"<pre><code>def adj_matrix_to_list(AMat):\n    Alist = {}\n    rows, cols = AMat.shape\n    for i in range(rows):\n        Alist[i] = []\n        for j in range(cols):\n            if AMat[i, j] == 1:\n                Alist[i].append(j)\n    return Alist\n</code></pre> <pre><code>AList = adj_matrix_to_list(AMat=AMat)\n</code></pre> <pre><code>def BFSListPath(Alist : dict , start_vertex : int ):\n\n    visited , parent = {} , {}\n\n    for row in Alist.keys():\n        visited[row] = False\n        parent[row] = -1 \n    queue = Queue()\n    visited[start_vertex] = True \n    queue.addq(start_vertex)\n\n    while not queue.is_empty():\n        parent_node = queue.delq()\n        for child in Alist[parent_node]:\n            if not visited[child]:\n                queue.addq(child)\n                visited[child] = True \n                parent[child] = parent_node\n    return visited, parent  \n</code></pre> <pre><code># Starting vertex\nv = 0\n\n# Perform BFS\nvisited, parent = BFSListPath(AList, v)\nprint(\"Visited:\", visited)\nprint(\"Parent:\", parent)\n</code></pre> <pre><code>Visited: {0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\nParent: {0: -1, 1: 0, 2: 0, 3: 1, 4: 2, 5: 3, 6: 3, 7: 5, 8: 7, 9: 4}\n</code></pre>"},{"location":"week4/redo/#dfs-using-global-parent-visited","title":"DFS using Global Parent &amp; Visited","text":"<pre><code>PARENT , VISITED = {} , {}\n\ndef DFS_Init_Global(AMat):\n\n    rows , cols = AMat.shape\n\n    for node in range(rows):\n        PARENT[node] = -1 \n        VISITED[node] = False\n\ndef DFS_Global(AMat, V):\n    VISITED[V] = True \n    for child in neighbours(AMat=AMat, j=V):\n        if not VISITED[child]:\n            PARENT[child] = V\n            DFS_Global(AMat=AMat,V=child)\n    return\n</code></pre> <pre><code># Starting node\nstart_node = 0\nDFS_Init_Global(AMat=AMat)\nDFS_Global(AMat=AMat, V= start_node)\nprint(\"Visited nodes:\", VISITED)\nprint(\"Parent nodes:\", PARENT)\n</code></pre> <pre><code>Visited nodes: {0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\nParent nodes: {0: -1, 1: 0, 2: 4, 3: 1, 4: 5, 5: 3, 6: 3, 7: 5, 8: 7, 9: 4}\n</code></pre> <pre><code>#Application Of BFS and DFS\n</code></pre> <pre><code>def Components(AList):\n    component = {}\n    for row in AList.keys():\n        component[row] = -1 \n    comp_id , seen = 0,0 \n    while seen &lt;= max(AList.keys()):\n        start_vertex_depth = min([i for i in AList.keys() if component[i] == -1])\n        visited , _ = BFSListPath(AList, start_vertex_depth)\n        for node in visited.keys():\n            if visited[node]:\n                seen += 1\n                component[node] = comp_id\n        comp_id += 1\n\n    return component\n</code></pre> <pre><code>def Components(AList):\n    component = {}\n    for i in AList.keys():\n        component[i] = -1\n    (compid,seen) = (0,0)\n    while seen &lt;= max(AList.keys()):\n        startv = min([i for i in AList.keys()\n                      if component[i] == -1])\n        visited , _ = BFSListPath(AList,startv)\n        for i in visited.keys():\n            if visited[i]:\n                seen = seen + 1\n                component[i] = compid\n        compid = compid + 1\n    return(component)\n</code></pre> <pre><code>Components(AList)\n</code></pre> <pre><code>{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}\n</code></pre> <pre><code>Amat = np.array([\n[0,1,1,0,0,0,0,0,0,0,0],\n    [1,0,1,0,0,0,0,0,0,0,0], \n    [1,1,0,0,0,0,0,0,0,0,0],\n    [0,0,0,0,1,0,0,0,0,0 ,0],\n    [0,0,0,1,0,1,0,0,0,0,0],\n    [0,0,0,0,1,0,1,0,0,0,0],\n    [0,0,0,0,0,1,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,1,1,1],\n    [0,0,0,0,0,0,0,1,0,0,0],\n    [0,0,0,0,0,0,0,1,0,0,0],\n    [0,0,0,0,0,0,0,1,0,0,0]])\n</code></pre> <pre><code>adj_list = adj_matrix_to_list(Amat)\n</code></pre> <pre><code>fig = plot_graph_from_adj_list(adj_list)\n</code></pre> <pre><code># Save the graph as an image\nfig.write_image(\"graph_image1.png\")\n\n# Display the plot\ndisplay(Image(filename=\"graph_image1.png\"))\n</code></pre> <pre><code>Components(adj_list)\n</code></pre> <pre><code>{0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1, 6: 1, 7: 2, 8: 2, 9: 2, 10: 2}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/represntinggraph4.2/","title":"Represntinggraph4.2","text":"<pre><code>import sys\nimport random\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.3933000445831567e-05\n</code></pre> <pre><code>edges = [\n    (0, 1),\n    (0, 4),\n    (1, 2),\n    (2, 0),\n    (3, 4),\n    (3, 6),\n    (4, 0),\n    (4, 3),\n    (4, 7),\n    (5, 3),\n    (5, 7),\n    (6, 5),\n    (7, 4),\n    (7, 8),\n    (8, 5),\n    (8, 9),\n    (9, 8),\n]\n</code></pre> <pre><code>import numpy as np\n</code></pre> <pre><code>A = np.zeros(shape=(10, 10))\n</code></pre> <pre><code>for i, j in edges:\n    A[i, j] = 1\n</code></pre> <pre><code>A\n</code></pre> <pre><code>array([[0., 1., 0., 0., 1., 0., 0., 0., 0., 0.],\n       [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n       [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 0., 1., 0., 0., 0.],\n       [1., 0., 0., 1., 0., 0., 0., 1., 0., 0.],\n       [0., 0., 0., 1., 0., 0., 0., 1., 0., 0.],\n       [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 0., 1., 0., 0., 0., 1.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.]])\n</code></pre> <pre><code>def neighbours(AMat, i):\n    nbrs = []\n    (rows, cols) = AMat.shape\n    for j in range(cols):\n        if AMat[i, j] == 1:\n            nbrs.append(j)\n            return nbrs\n</code></pre> <pre><code>neighbours(A, 7)\n</code></pre> <pre><code>[4]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/topologoical_sorting/","title":"Topologoical sorting","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.2519000026477443e-05\n</code></pre> <pre><code>import numpy as np\n\n\ndef toposort(AMat):\n    \"\"\"\n    Performs a topological sort on a directed acyclic graph (DAG) using an adjacency matrix.\n\n    Parameters:\n    AMat (np.ndarray): Adjacency matrix representing the graph, where AMat[i][j] == 1 indicates an edge from node i to node j.\n\n    Returns:\n    list: A list of nodes in topologically sorted order.\n    \"\"\"\n\n    # Get the number of rows and columns from the adjacency matrix\n    rows, cols = AMat.shape\n\n    # Initialize the indegree dictionary and the list to store the topological sort result\n    indegree = {}\n    toposortlist = []\n\n    # Step 1: Initialize all nodes' indegree to 0\n    for c in range(cols):\n        indegree[c] = 0\n\n    # Step 2: Compute indegree for each node\n    for r in range(rows):\n        for c in range(cols):\n            if AMat[r, c] == 1:\n                indegree[c] += 1\n\n    # Step 3: Perform the topological sort\n    for _ in range(cols):\n        # Find a node with zero indegree\n        zero_indegree_nodes = [k for k in range(cols) if indegree[k] == 0]\n        if not zero_indegree_nodes:\n            raise ValueError(\"Graph has at least one cycle\")\n\n        # Select the first node with zero indegree\n        j = zero_indegree_nodes[0]\n        toposortlist.append(j)\n\n        # Set the indegree of this node to -1 to mark it as processed\n        indegree[j] = -1\n\n        # Decrease the indegree of all nodes that this node points to\n        for k in range(cols):\n            if AMat[j, k] == 1:\n                indegree[k] -= 1\n\n    return toposortlist\n\n\n# Example usage:\nAMat = np.array(\n    [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0],\n    ]\n)\n\nprint(toposort(AMat))\n</code></pre> <pre><code>[0, 1, 2, 3, 4]\n</code></pre> <pre><code>from queue import Queue\n\n\ndef toposortlist(AList):\n    \"\"\"\n    Performs a topological sort on a directed acyclic graph (DAG) using Kahn's algorithm.\n\n    Parameters:\n    AList (dict): Adjacency list representing the graph, where keys are nodes and values are lists of adjacent nodes.\n\n    Returns:\n    list: A list of nodes in topologically sorted order.\n    \"\"\"\n\n    # Initialize the indegree dictionary and the list to store the topological sort result\n    indegree = {}\n    toposortlist = []\n\n    # Step 1: Initialize all nodes' indegree to 0\n    for u in AList.keys():\n        indegree[u] = 0\n\n    # Step 2: Compute indegree for each node\n    for u in AList.keys():\n        for v in AList[u]:\n            indegree[v] = indegree[v] + 1\n\n    # Step 3: Initialize the queue with nodes having zero indegree\n    zerodegreeq = Queue()\n    for u in AList.keys():\n        if indegree[u] == 0:\n            zerodegreeq.put(u)\n\n    # Step 4: Perform the topological sort\n    while not zerodegreeq.empty():\n        # Dequeue a node with zero indegree\n        j = zerodegreeq.get()\n        # Append it to the topological sort list\n        toposortlist.append(j)\n\n        # Decrease the indegree of all its adjacent nodes\n        for k in AList[j]:\n            indegree[k] = indegree[k] - 1\n            # If the indegree of any adjacent node becomes zero, enqueue it\n            if indegree[k] == 0:\n                zerodegreeq.put(k)\n\n    return toposortlist\n\n\n# Example usage:\nAList = {\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}\n\n# Prints the topological sort of the graph\nprint(toposortlist(AList))\n</code></pre> <pre><code>['A', 'B', 'C', 'D', 'E']\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/Lecture%205.1%20-%20Shortest%20Paths%20in%20Weighted%20Graphs_annotated/","title":"Lecture 5.1 - Shortest Paths in Weighted Graphs_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.1%20-%20Shortest%20Paths%20in%20Weighted%20Graphs_annotated/#lecture-51-shortest-paths-in-weighted-graphs_annotatedpdf-pdf-file","title":"Lecture 5.1 - Shortest Paths in Weighted Graphs_annotated.pdf (PDF file)","text":"<p>Summary Introduction to Weighted Graphs</p> <p>Weighted graphs extend the concept of unweighted graphs by assigning a weight or cost to each edge. This weight can represent various metrics such as distance, time, cost, etc. By considering edge weights, we can compute shortest paths that minimize the total cost or distance traveled.</p> <p>Single Source Shortest Paths</p> <p>One of the fundamental problems in weighted graphs is finding the shortest paths from a single source vertex to all other vertices. This problem arises in various applications, such as finding the shortest route on a road network or delivering goods from a distribution center to multiple locations.</p> <p>Dijkstra's Algorithm</p> <p>Dijkstra's algorithm is a widely used method for solving the single source shortest path problem. It maintains a set of vertices whose shortest paths from the source have been determined and iteratively updates its estimate of the shortest paths until it reaches all vertices.</p> <p>Implementation of Dijkstra's Algorithm</p> <p>The following steps describe the implementation of Dijkstra's algorithm:</p> <ol> <li>Initialize a distance array that stores the shortest distance from the source vertex to all other vertices. Initially, all distances are set to infinity except the distance to the source, which is set to 0.</li> <li>While there are still unvisited vertices:<ul> <li>Find the unvisited vertex with the smallest distance. This is the current vertex.</li> <li>For each neighbor of the current vertex:<ul> <li>Calculate the new distance to the neighbor via the current vertex.</li> <li>If this new distance is shorter than the current shortest distance to the neighbor, update the neighbor's distance and set its predecessor to the current vertex.</li> </ul> </li> </ul> </li> <li>Once all vertices have been visited, the distance array contains the shortest distances from the source to all other vertices.</li> </ol> <p>All Pairs Shortest Paths</p> <p>In some scenarios, we may need to compute the shortest paths between every pair of vertices in a graph. This problem is known as the all pairs shortest paths problem.</p> <p>Floyd-Warshall Algorithm</p> <p>The Floyd-Warshall algorithm is a widely used method for solving the all pairs shortest paths problem. It works by iteratively updating a distance matrix to store the shortest paths between all pairs of vertices.</p> <p>Implementation of Floyd-Warshall Algorithm</p> <p>The following steps describe the implementation of the Floyd-Warshall algorithm:</p> <ol> <li>Initialize a distance matrix that stores the shortest distance between all pairs of vertices. Initially, the distances are set to infinity, except for the distances between vertices and themselves, which are set to 0.</li> <li>For each possible intermediate vertex k:<ul> <li>For each pair of vertices i and j:<ul> <li>Calculate the new distance from i to j through k. This is the minimum of the current shortest distance from i to j and the sum of the shortest distances from i to k and from k to j.</li> <li>If the new distance is shorter than the current shortest distance from i to j, update the shortest distance and set the intermediate vertex to k.</li> </ul> </li> </ul> </li> <li>Once all intermediate vertices have been considered, the distance matrix contains the shortest distances between all pairs of vertices.</li> </ol> <p>Negative Edge Weights</p> <p>Negative edge weights introduce additional complexity to shortest path problems. Graphs with negative edge weights may contain negative cycles, which can lead to undefined shortest paths.</p> <p>Bellman-Ford Algorithm</p> <p>The Bellman-Ford algorithm is a modification of Dijkstra's algorithm that can handle negative edge weights. It iteratively updates its estimate of the shortest paths, allowing it to detect negative cycles. However, the Bellman-Ford algorithm is not as efficient as Dijkstra's algorithm for graphs without negative cycles.</p> <p>Applications of Shortest Path Algorithms</p> <p>Shortest path algorithms have numerous applications in various domains, including:</p> <ul> <li>Network routing: Finding the shortest path between routers or network devices.</li> <li>Transportation planning: Optimizing routes for vehicles, such as finding the shortest route from a warehouse to multiple delivery locations.</li> <li>Supply chain management: Determining the most efficient way to transport goods from suppliers to customers.</li> <li>Data analysis: Identifying the shortest paths in a network to analyze data flow or detect anomalies.</li> <li>Social network analysis: Finding the shortest paths between individuals or groups in social networks to measure influence or identify connections.</li> </ul>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/","title":"Lecture 5.3 - Single Source Shortest Paths with Negative Weights (Bellman-Ford Algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#lecture-53-single-source-shortest-paths-with-negative-weights-bellman-ford-algorithm_annotatedpdf-pdf-file","title":"Lecture 5.3 - Single Source Shortest Paths with Negative Weights (Bellman-Ford Algorithm)_annotated.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#single-source-shortest-paths-with-negative-weights","title":"Single Source Shortest Paths with Negative Weights","text":""},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#dijkstras-algorithm","title":"Dijkstra's Algorithm","text":"<p>Dijkstra's algorithm works by iteratively discovering the shortest paths from the source vertex to all other vertices in the graph. It maintains a set of vertices that have been visited and a set of vertices that have not yet been visited. At each iteration, it chooses the unvisited vertex with the smallest distance from the source vertex and adds it to the visited set. It then updates the distances to all of the neighbors of the newly visited vertex.</p> <p>Dijkstra's algorithm requires that all edge weights be non-negative. If there are negative edge weights, then the algorithm may not find the shortest path.</p>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#bellman-ford-algorithm","title":"Bellman-Ford Algorithm","text":"<p>The Bellman-Ford algorithm is a generalization of Dijkstra's algorithm that can handle negative edge weights. It works by iteratively relaxing all of the edges in the graph. Relaxation means updating the distance to a vertex to be the minimum of its current distance and the distance to the vertex plus the weight of the edge.</p> <p>The Bellman-Ford algorithm terminates after n iterations, where n is the number of vertices in the graph. If there are no negative cycles in the graph, then the algorithm will find the shortest path from the source vertex to all other vertices. If there is a negative cycle, then the algorithm will not terminate and will continue to relax the edges indefinitely.</p>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#complexity","title":"Complexity","text":"<p>The Bellman-Ford algorithm has a time complexity of O(mn), where m is the number of edges in the graph and n is the number of vertices. This is slower than Dijkstra's algorithm, which has a time complexity of O(n^2). However, the Bellman-Ford algorithm can handle negative edge weights, while Dijkstra's algorithm cannot.</p>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#applications","title":"Applications","text":"<p>The Bellman-Ford algorithm is used in a variety of applications, including:</p> <ul> <li>Finding the shortest path between two vertices in a graph with negative edge weights</li> <li>Finding the minimum cost cycle in a graph</li> <li>Finding the minimum cost flow in a network</li> </ul>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#example","title":"Example","text":"<p>Consider the following graph:</p> <pre><code>0 -&gt; 1: 1\n0 -&gt; 2: 2\n1 -&gt; 2: -1\n2 -&gt; 0: -2\n2 -&gt; 3: 1\n3 -&gt; 2: -1\n</code></pre> <p>The Bellman-Ford algorithm would start by initializing the distance to all vertices to infinity, except for the source vertex, which would be set to 0. It would then relax all of the edges in the graph.</p> <p>After the first iteration, the distances to vertices 1, 2, and 3 would be:</p> <pre><code>0 -&gt; 1: 1\n0 -&gt; 2: 2\n1 -&gt; 2: 0\n2 -&gt; 0: -2\n2 -&gt; 3: 1\n3 -&gt; 2: 0\n</code></pre> <p>After the second iteration, the distances to vertices 2 and 3 would be:</p> <pre><code>0 -&gt; 1: 1\n0 -&gt; 2: 2\n1 -&gt; 2: 0\n2 -&gt; 0: -2\n2 -&gt; 3: 0\n3 -&gt; 2: 0\n</code></pre> <p>After the third iteration, the distances to vertices 3 and 2 would be:</p> <pre><code>0 -&gt; 1: 1\n0 -&gt; 2: 2\n1 -&gt; 2: 0\n2 -&gt; 0: -2\n2 -&gt; 3: 0\n3 -&gt; 2: 0\n</code></pre> <p>The algorithm would then terminate, since there are no more edges to relax. The final distances to the vertices would be:</p> <pre><code>0 -&gt; 1: 1\n0 -&gt; 2: 2\n1 -&gt; 2: 0\n2 -&gt; 0: -2\n2 -&gt; 3: 0\n3 -&gt; 2: 0\n</code></pre>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#implementation","title":"Implementation","text":"<p>The following Python code implements the Bellman-Ford algorithm:</p> <pre><code>def bellman_ford(graph, source):\n  \"\"\"\n  Finds the shortest path from a source vertex to all other vertices in a graph with negative edge weights.\n\n  Args:\n    graph: A dictionary representing the graph. The keys are the vertices and the values are dictionaries representing the edges.\n    source: The source vertex.\n\n  Returns:\n    A dictionary representing the distances from the source vertex to all other vertices.\n  \"\"\"\n\n  # Initialize the distances to all vertices to infinity.\n  distances = {}\n  for vertex in graph:\n    distances[vertex] = float('inf')\n\n  # Set the distance to the source vertex to 0.\n  distances[source] = 0\n\n  # Relax all of the edges in the graph n times.\n  for i in range(len(graph)):\n    for vertex in graph:\n      for neighbor, weight in graph[vertex].items():\n        if distances[vertex] + weight &lt; distances[neighbor]:\n          distances[neighbor] = distances[vertex] + weight\n\n  # Check if there is a negative cycle.\n  for vertex in graph:\n    for neighbor, weight in graph[vertex].items():\n      if distances[vertex] + weight &lt; distances[neighbor]:\n        raise ValueError(\"There is a negative cycle in the graph.\")\n\n  # Return the distances.\n  return distances\n</code></pre>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#conclusion","title":"Conclusion","text":"<p>The Bellman-Ford algorithm is a powerful algorithm for finding the shortest path from a source vertex to all other vertices in a graph with negative edge weights. It is more complex than Dijkstra's algorithm, but it can handle a wider range of graphs.</p>"},{"location":"week5/Lecture%205.4%20-%20All%20Pairs%20Shortest%20Paths%20%28Floyd-Warshall%20algorithm%29_annotated/","title":"Lecture 5.4 - All Pairs Shortest Paths (Floyd-Warshall algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.4%20-%20All%20Pairs%20Shortest%20Paths%20%28Floyd-Warshall%20algorithm%29_annotated/#lecture-54-all-pairs-shortest-paths-floyd-warshall-algorithm_annotatedpdf-pdf-file","title":"Lecture 5.4 - All Pairs Shortest Paths (Floyd-Warshall algorithm)_annotated.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week5/Lecture%205.4%20-%20All%20Pairs%20Shortest%20Paths%20%28Floyd-Warshall%20algorithm%29_annotated/#all-pairs-shortest-paths","title":"All-Pairs Shortest Paths","text":"<p>Introduction:</p> <p>In weighted graphs, finding the shortest paths between every pair of vertices is a fundamental problem with applications in various domains, such as network routing, logistics, and social network analysis. This problem is known as the all-pairs shortest path problem.</p> <p>Single-Source Shortest Paths vs. All-Pairs Shortest Paths:</p> <p>Traditional shortest path algorithms like Dijkstra's algorithm and Bellman-Ford algorithm find the shortest paths from a single source vertex to all other vertices in a graph. In contrast, all-pairs shortest path algorithms determine the shortest paths between every pair of vertices in the graph.</p> <p>Transitive Closure:</p> <p>An alternative approach to finding all-pairs shortest paths is through the concept of transitive closure. The transitive closure of a graph is a matrix B, where B[i, j] = 1 if there is a path from vertex i to vertex j using any intermediate vertices.</p> <p>Warshall's Algorithm:</p> <p>Warshall's algorithm is a dynamic programming algorithm that computes the transitive closure of a graph. It iteratively updates the matrix B, starting with direct edges and considering longer paths through intermediate vertices.</p> <p>Floyd-Warshall Algorithm:</p> <p>The Floyd-Warshall algorithm is an adaptation of Warshall's algorithm for finding all-pairs shortest paths in weighted graphs. It maintains a matrix SP, where SP[i, j, k] represents the shortest path from vertex i to vertex j using vertices in the set {0, 1, ..., k-1} as intermediate vertices.</p> <p>Algorithm Steps:</p> <ol> <li>Initialize SP[i, j, 0] to the weight of the direct edge (i, j), or infinity if there is no direct edge.</li> <li>For each intermediate vertex k, iterate over all pairs of vertices i and j.</li> <li>If the path from i to j through k is shorter than the current shortest path from i to j, update SP[i, j, k].</li> <li>After considering all intermediate vertices, SP[i, j, n] contains the shortest path from i to j.</li> </ol> <p>Implementation:</p> <p>The Floyd-Warshall algorithm can be implemented using a straightforward nested loop. However, optimizing space usage is possible by maintaining only two \"slices\" of the SP matrix and reusing them for the next iteration.</p> <p>Time and Space Complexity:</p> <p>The time complexity of the Floyd-Warshall algorithm is O(n^3), where n is the number of vertices in the graph. The space complexity can be reduced to O(n^2) by reusing the SP matrix slices.</p> <p>Applications:</p> <p>The Floyd-Warshall algorithm has numerous applications, including:</p> <ul> <li>Finding optimal routes in transportation networks</li> <li>Computing distances between cities in a map</li> <li>Detecting negative cycles in a graph</li> <li>Solving the all-pairs maximum flow problem</li> </ul> <p>Summary:</p> <p>The Floyd-Warshall algorithm is an efficient and versatile algorithm for finding all-pairs shortest paths in weighted graphs. It works for both positive and negative edge weights, assuming no negative cycles. The algorithm's time complexity is O(n^3), but space usage can be optimized to O(n^2). Its simplicity and wide range of applications make it a valuable tool in various domains.</p>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/","title":"Lecture 5.5 - Minimum Cost Spanning Trees_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#lecture-55-minimum-cost-spanning-trees_annotatedpdf-pdf-file","title":"Lecture 5.5 - Minimum Cost Spanning Trees_annotated.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#minimum-cost-spanning-trees-mcsts","title":"Minimum Cost Spanning Trees (MCSTs)","text":""},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#overview","title":"Overview","text":"<p>In a network, a spanning tree is a subset of the edges that connects all the vertices without creating any cycles. When each edge has an associated cost, the goal of finding a minimum cost spanning tree (MCST) is to select the spanning tree with the lowest total cost.</p>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#applications","title":"Applications","text":"<p>MCSTs have numerous applications in real-world scenarios:</p> <ul> <li>Infrastructure planning: Designing road networks, power grids, or communication systems by minimizing the total cost of connecting all locations.</li> <li>Cable redundancy: Ensuring that there are redundant network connections by adding a minimum number of backup cables to an existing fiber optic network.</li> </ul>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#spanning-trees","title":"Spanning Trees","text":"<p>A spanning tree is a tree that connects all the vertices in a graph. Key facts about trees include:</p> <ul> <li>A tree with n vertices has exactly n-1 edges.</li> <li>Adding an edge to a tree creates a cycle.</li> <li>Every pair of vertices in a tree is connected by a unique path.</li> </ul>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#building-minimum-cost-spanning-trees","title":"Building Minimum Cost Spanning Trees","text":"<p>Two primary algorithms for finding MCSTs are:</p> <ol> <li>Prim's algorithm: Starts with the smallest edge and gradually adds edges that connect components without creating cycles.</li> <li>Kruskal's algorithm: Sorts edges in ascending order of weight and then connects components in that order, avoiding cycles.</li> </ol>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#prims-algorithm","title":"Prim's Algorithm","text":"<p>Steps:</p> <ol> <li>Initialize a set S to contain a single vertex.</li> <li>While S does not contain all vertices:<ul> <li>Find the lowest-cost edge (u, v) that connects a vertex in S to a vertex not in S.</li> <li>Add (u, v) to S.</li> </ul> </li> </ol>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#kruskals-algorithm","title":"Kruskal's Algorithm","text":"<p>Steps:</p> <ol> <li>Sort the edges in ascending order of weight.</li> <li>Create a set of disjoint sets, each containing a single vertex.</li> <li>For each edge (u, v) in order:<ul> <li>If u and v are in different sets:<ul> <li>Add (u, v) to the MCST.</li> <li>Merge the sets containing u and v.</li> </ul> </li> </ul> </li> </ol>"},{"location":"week5/Lecture%205.6%20-%20Minimum%20Cost%20Spanning%20Trees%20%28Prim_s%20Algorithm%29_annotated/","title":"Lecture 5.6 - Minimum Cost Spanning Trees (Prim_s Algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.6%20-%20Minimum%20Cost%20Spanning%20Trees%20%28Prim_s%20Algorithm%29_annotated/#lecture-56-minimum-cost-spanning-trees-prim_s-algorithm_annotatedpdf-pdf-file","title":"Lecture 5.6 - Minimum Cost Spanning Trees (Prim_s Algorithm)_annotated.pdf (PDF file)","text":"<p>Summary Minimum Cost Spanning Trees</p> <p>Definition: A Minimum Cost Spanning Tree (MCST) of a weighted, undirected graph is a spanning tree with the minimum possible total edge weight.</p> <p>Strategy: Prim's algorithm incrementally grows an MCST by adding the smallest edge from the current tree to a vertex not yet in the tree.</p> <p>Correctness: The Minimum Separator Lemma states that every MCST must include the minimum cost edge between any two non-empty subsets of vertices. Since Prim's algorithm always selects the smallest edge connecting the tree to outside vertices, it guarantees an MCST.</p> <p>Implementation:</p> <ul> <li>Initialize visited[v] to False and distance[v] to infinity for all vertices.</li> <li>Mark a starting vertex as visited and set its distance to 0.</li> <li>For each iteration:<ul> <li>Find the unvisited vertex with the smallest distance to the tree.</li> <li>Add that vertex to the tree and update the distances of its neighbors to the tree.</li> </ul> </li> <li>Return the edges in the spanning tree.</li> </ul> <p>Improved Implementation:</p> <ul> <li>Keep track of the nearest neighbor of each vertex in the tree.</li> <li>Scan all non-tree vertices to find the next vertex with minimum distance to the tree.</li> <li>This optimization reduces the complexity to O(n) per iteration.</li> </ul> <p>Complexity:</p> <ul> <li>The original implementation takes O(n^2) time.</li> <li>The improved implementation takes O(n^2) time with an adjacency matrix and O(n log n) time with an adjacency list.</li> </ul> <p>Summary:</p> <ul> <li>Prim's algorithm constructs an MCST incrementally.</li> <li>The Minimum Separator Lemma ensures its correctness.</li> <li>The improved implementation reduces the complexity to O(n^2) or O(n log n) depending on the data structure used.</li> <li>The bottleneck lies in efficiently identifying the vertex with the smallest distance to the tree.</li> </ul>"},{"location":"week5/bellman_ford_5_3/","title":"Bellman ford 5 3","text":"<pre><code>import os\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.5657998776296154e-05\n</code></pre> <pre><code># Number of nodes\nnum_nodes = 8\n\n# Initialize adjacency matrix with inf (representing no connection)\nadj_matrix = np.zeros((num_nodes, num_nodes, 2))\n\n# Define the edges and their weights\nedges = [\n    (0, 1, 10),\n    (0, 7, 8),\n    (1, 5, 2),\n    (2, 1, 1),\n    (2, 3, 1),\n    (3, 4, 3),\n    (4, 5, -1),\n    (5, 2, -2),\n    (6, 1, -4),\n    (6, 5, -1),\n    (7, 6, 1),\n]\n\n# Fill the adjacency matrix with the edge weights\nfor edge in edges:\n    u, v, weight = edge\n    adj_matrix[u, v] = [1, weight]\n\n# Create a NetworkX graph\nG = nx.DiGraph()\n\n# Add edges with weights to the graph\nfor u, v, weight in edges:\n    G.add_edge(u, v, weight=weight)\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\nplt.title(\"Graph with a Negative Cycle\")\nplt.show()\n</code></pre> <pre><code>def bellmanford(Wmat, source):\n    rows, cols, x = Wmat.shape\n    connection = 0\n    weights = 1\n    infinity = np.max(Wmat) * rows + 1\n    distance = {}\n\n    for vertex in range(rows):\n        distance[vertex] = infinity\n\n    distance[source] = 0\n    for _ in range(rows):\n        for vertex in range(rows):\n            for child in range(cols):\n                if Wmat[vertex, child, connection] == 1:\n                    distance[child] = min(\n                        distance[child], distance[vertex] + Wmat[vertex, child, weight]\n                    )\n    return distance\n</code></pre> <pre><code>distance = bellmanford(adj_matrix, source=0)\n</code></pre> <pre><code>distance\n</code></pre> <pre><code>{0: 0, 1: 5.0, 2: 5.0, 3: 6.0, 4: 9.0, 5: 7.0, 6: 9.0, 7: 8.0}\n</code></pre> <pre><code>G = nx.DiGraph()\n\n# Add edges with weights to the graph\nfor i in range(num_nodes):\n    for j in range(num_nodes):\n        if adj_matrix[i, j, 0] == 1:\n            G.add_edge(i, j, weight=adj_matrix[i, j, 1])\n\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(G, pos, with_labels=True, node_color=\"lightblue\", node_size=500, font_size=10)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\n# Add the distance information to the plot\nfor node, dist in distance.items():\n    plt.annotate(\n        f\"Dist: {dist}\",\n        xy=pos[node],\n        xytext=(5, 5),\n        textcoords=\"offset points\",\n        fontsize=10,\n        color=\"red\",\n    )\n\nplt.title(\"Weighted Graph with Distances\")\nplt.show()\n</code></pre> <pre><code>distance\n</code></pre> <pre><code>{0: 0, 1: 5.0, 2: 5.0, 3: 6.0, 4: 9.0, 5: 7.0, 6: 9.0, 7: 8.0}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/dijkstra_5_2/","title":"Dijkstra 5 2","text":"<pre><code>import os\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.2648000392800895e-05\n</code></pre> <pre><code># Define the number of nodes\nnum_nodes = 5\n\n# Create a three-dimensional adjacency matrix\n# The third dimension size 2: first for presence, second for weight\nadj_matrix = np.zeros((num_nodes, num_nodes, 2))\n\n# Define the edges and their weights\nedges = [(0, 1, 2), (0, 4, 1), (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 2)]\n\n# Fill the adjacency matrix with edge presence and weights\nfor edge in edges:\n    u, v, weight = edge\n    adj_matrix[u, v] = [1, weight]\n    adj_matrix[v, u] = [1, weight]  # Assuming the graph is undirected\n\n# Create a NetworkX graph\nG = nx.Graph()\n\n# Add edges with weights to the graph\nfor i in range(num_nodes):\n    for j in range(num_nodes):\n        if adj_matrix[i, j, 0] == 1:\n            G.add_edge(i, j, weight=adj_matrix[i, j, 1])\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(G, pos, with_labels=True, node_color=\"lightblue\", node_size=500, font_size=10)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\nplt.title(\"Weighted Graph\")\nplt.show()\n</code></pre> <pre><code>adj_matrix\n</code></pre> <pre><code>array([[[0., 0.],\n        [1., 2.],\n        [0., 0.],\n        [0., 0.],\n        [1., 1.]],\n\n       [[1., 2.],\n        [0., 0.],\n        [1., 3.],\n        [1., 2.],\n        [0., 0.]],\n\n       [[0., 0.],\n        [1., 3.],\n        [0., 0.],\n        [1., 4.],\n        [0., 0.]],\n\n       [[0., 0.],\n        [1., 2.],\n        [1., 4.],\n        [0., 0.],\n        [1., 5.]],\n\n       [[1., 1.],\n        [0., 0.],\n        [0., 0.],\n        [1., 5.],\n        [0., 0.]]])\n</code></pre> <pre><code>def dijkastra(WMat, s):\n    rows, cols, x = WMat.shape\n    infinity = np.max(WMat) * rows + 1  # set the max value as infinity\n    visited, distance = {}, {}  # dict to keep track of the distance and visited\n    for vertex in range(rows):\n        visited[vertex], distance[vertex] = False, infinity\n    # starting vertex\n    distance[s] = 0\n    for u in range(rows):\n        nextd = min([distance[v] for v in range(rows) if not visited[v]])\n        nextvlist = [\n            v for v in range(rows) if (not visited[v]) and distance[v] == nextd\n        ]\n        # print(nextvlist)\n        if nextvlist == []:\n            break\n        nextv = min(nextvlist)\n        visited[nextv] = True\n        for v in range(cols):\n            if WMat[nextv, v, 0] == 1 and not visited[v]:\n                distance[v] = min(distance[v], distance[nextv] + WMat[nextv, v, 1])\n    return distance\n</code></pre> <pre><code>distance = dijkastra(WMat=adj_matrix, s=0)\n</code></pre> <pre><code>plt.show()\n</code></pre> <pre><code>G = nx.Graph()\n\n# Add edges with weights to the graph\nfor i in range(num_nodes):\n    for j in range(num_nodes):\n        if adj_matrix[i, j, 0] == 1:\n            G.add_edge(i, j, weight=adj_matrix[i, j, 1])\n\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(G, pos, with_labels=True, node_color=\"lightblue\", node_size=500, font_size=10)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\n# Add the distance information to the plot\nfor node, dist in distance.items():\n    plt.annotate(\n        f\"Dist: {dist}\",\n        xy=pos[node],\n        xytext=(5, 5),\n        textcoords=\"offset points\",\n        fontsize=10,\n        color=\"red\",\n    )\n\nplt.title(\"Weighted Graph with Distances\")\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/floyd_warshall_5_4/","title":"Floyd warshall 5 4","text":"<pre><code>import os\nimport numpy as np\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.1470001481939107e-05\n</code></pre> <pre><code>def floydwarshall(WMat):\n\n    rows, cols, x = WMat.shape\n    # transitive closure matrix\n    SP = np.full((rows, cols, cols + 1), np.inf)\n    infinity = np.max(WMat) * rows * rows + 1\n    closure = 0\n    connection = 0\n    weight = 1\n    # for vertex in range(rows):\n    #     for child in range(cols):\n    #         SP[vertex,child, closure] = infinity\n\n    for vertex in range(rows):\n        for child in range(cols):\n            if WMat[vertex, child, connection] == 1:\n                SP[vertex, child, closure] = WMat[vertex, child, weight]\n    for closure_loop in range(1, cols + 1):\n        for vertex in range(rows):\n            for child in range(cols):\n                SP[vertex, child, closure_loop] = min(\n                    SP[vertex, child, closure_loop - 1],\n                    SP[vertex, closure_loop - 1, closure_loop - 1]\n                    + SP[closure_loop - 1, child, closure_loop - 1],\n                )\n    return SP[:, :, cols]\n</code></pre> <pre><code># Number of nodes\nnum_nodes = 8\n\n# Initialize adjacency matrix with inf (representing no connection)\nadj_matrix = np.zeros((num_nodes, num_nodes, 2))\n\n# Define the edges and their weights\nedges = [\n    (0, 1, 10),\n    (0, 7, 8),\n    (1, 5, 2),\n    (2, 1, 1),\n    (2, 3, 1),\n    (3, 4, 3),\n    (4, 5, -1),\n    (5, 2, -2),\n    (6, 1, -4),\n    (6, 5, -1),\n    (7, 6, 1),\n]\n\n# Fill the adjacency matrix with the edge weights\nfor edge in edges:\n    u, v, weight = edge\n    adj_matrix[u, v] = [1, weight]\n\n# Create a NetworkX graph\nG = nx.DiGraph()\n\n# Add edges with weights to the graph\nfor u, v, weight in edges:\n    G.add_edge(u, v, weight=weight)\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\nplt.title(\"Graph with a Negative Cycle\")\nplt.show()\n</code></pre> <pre><code>distance = floydwarshall(adj_matrix)\n</code></pre> <pre><code>distance\n</code></pre> <pre><code>array([[inf,  5.,  5.,  6.,  9.,  7.,  9.,  8.],\n       [inf,  1.,  0.,  1.,  4.,  2., inf, inf],\n       [inf,  1.,  1.,  1.,  4.,  3., inf, inf],\n       [inf,  1.,  0.,  1.,  3.,  2., inf, inf],\n       [inf, -2., -3., -2.,  1., -1., inf, inf],\n       [inf, -1., -2., -1.,  2.,  1., inf, inf],\n       [inf, -4., -4., -3.,  0., -2., inf, inf],\n       [inf, -3., -3., -2.,  1., -1.,  1., inf]])\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/kruskal/","title":"Kruskal","text":"<pre><code>import os\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.8425998860038817e-05\n</code></pre> <pre><code>def kruskal(adj_list):\n    \"\"\"\n    Implements Kruskal's algorithm to find the Minimum Spanning Tree (MST) of a graph.\n\n    Args:\n    adj_list (dict): A dictionary representing the adjacency list of the graph.\n\n    Returns:\n    list: A list of tuples representing the edges in the MST.\n    \"\"\"\n    edges = []\n    component = {}\n    mst_edges = []\n\n    # Convert adjacency list to a list of edges with weights\n    for node in adj_list.keys():\n        # Weight as the first component to sort easily\n        edges.extend(\n            [(weight, node, neighbor) for (neighbor, weight) in adj_list[node]]\n        )\n        component[node] = node\n\n    # Sort edges by weight\n    edges.sort()\n\n    # Iterate over sorted edges and construct MST\n    for weight, u, v in edges:\n        if component[u] != component[v]:\n            mst_edges.append((u, v))\n            old_component = component[u]\n            new_component = component[v]\n            for node in component.keys():\n                if component[node] == old_component:\n                    component[node] = new_component\n\n    return mst_edges\n</code></pre> <p>Certainly! Let's enhance your <code>kruskal</code> function by renaming the variables for better readability, formatting the code properly, adding comments for clarity, and providing a description. We'll also include the necessary functions to plot the original graph and the MST generated by Kruskal's algorithm.</p>"},{"location":"week5/kruskal/#enhanced-kruskal-function","title":"Enhanced <code>kruskal</code> Function","text":""},{"location":"week5/kruskal/#explanation-of-the-enhanced-code","title":"Explanation of the Enhanced Code:","text":"<ol> <li> <p>Function <code>kruskal</code>:</p> <ul> <li><code>adj_list</code>: The adjacency list of the graph.</li> <li><code>edges</code>: A list to store all edges with their weights.</li> <li><code>component</code>: A dictionary to track the component (connected component) of each node.</li> <li><code>mst_edges</code>: A list to store the edges of the Minimum Spanning Tree (MST).</li> <li>Converts the adjacency list to a list of edges with weights.</li> <li>Sorts the edges by weight.</li> <li>Iterates over the sorted edges to construct the MST, using the component dictionary to avoid cycles.</li> <li>Returns the list of MST edges.</li> </ul> </li> <li> <p>Graph Construction and Plotting:</p> <ul> <li>Constructs the original graph and MST using NetworkX.</li> <li>Plots the original graph and MST side-by-side with labeled nodes and edge weights using Matplotlib and NetworkX.</li> </ul> </li> </ol>"},{"location":"week5/kruskal/#output","title":"Output:","text":"<ul> <li>The code prints the edges in the MST.</li> <li>It displays two plots: the original graph and the Minimum Spanning Tree (MST).</li> </ul> <pre><code># Example usage\nweighted_adj_list = {\n    0: [(1, 10), (7, 8)],\n    1: [(0, 10), (2, 1), (5, 2)],\n    2: [(1, 1), (3, 1), (5, -2), (2, -4)],\n    3: [(2, 1), (4, 3)],\n    4: [(3, 3), (5, -1)],\n    5: [(4, -1), (6, -1), (2, -2)],\n    6: [(5, -1), (7, 1)],\n    7: [(6, 1), (0, 8)],\n}\n\nmst_edges = kruskal(weighted_adj_list)\nprint(\"MST Edges:\", mst_edges)\n</code></pre> <pre><code>MST Edges: [(2, 5), (4, 5), (5, 6), (1, 2), (2, 3), (6, 7), (0, 7)]\n</code></pre> <pre><code># Create a NetworkX graph for the original graph\nG = nx.DiGraph()\nfor u in weighted_adj_list.keys():\n    for v, weight in weighted_adj_list[u]:\n        G.add_edge(u, v, weight=weight)\n\n# Create a NetworkX graph for the MST\nMST = nx.Graph()\nfor u, v in mst_edges:\n    for neighbor, weight in weighted_adj_list[u]:\n        if neighbor == v:\n            MST.add_edge(u, v, weight=weight)\n            break\n\n# Plot the original graph\npos = nx.spring_layout(G)  # Positions for all nodes\nplt.figure(figsize=(12, 6))\n\nplt.subplot(121)\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\nplt.title(\"Original Graph\")\n\n# Plot the Minimum Spanning Tree\nplt.subplot(122)\nnx.draw(\n    MST, pos, with_labels=True, node_color=\"lightgreen\", node_size=500, font_size=10\n)\nmst_edge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in MST.edges(data=True)}\nnx.draw_networkx_edge_labels(MST, pos, edge_labels=mst_edge_labels, font_size=10)\nplt.title(\"Minimum Spanning Tree\")\n\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/prims/","title":"Prims","text":"<pre><code>import os\nimport numpy as np\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.317600253969431e-05\n</code></pre> <pre><code>def primlist(weighted_adj_list):\n    # Initialize the infinity value to a number greater than any edge weight\n    infinity = 1 + max(\n        [\n            weight\n            for u in weighted_adj_list.keys()\n            for (v, weight) in weighted_adj_list[u]\n        ]\n    )\n\n    # Initialize the visited dictionary to keep track of visited nodes\n    # Initialize the distance dictionary to store the minimum distance to each node\n    # Initialize the list to store the edges of the Minimum Spanning Tree (MST)\n    visited = {}\n    min_distance = {}\n    mst_edges = []\n\n    # Set all nodes as not visited and their initial distances to infinity\n    for node in weighted_adj_list.keys():\n        visited[node] = False\n        min_distance[node] = infinity\n\n    # Start with the first node (node 0)\n    visited[0] = True\n\n    # Update the distances for the adjacent nodes of node 0\n    for neighbor, weight in weighted_adj_list[0]:\n        min_distance[neighbor] = weight\n\n    # Loop to find the minimum distance edge connecting a visited node to an unvisited node\n    for _ in range(len(weighted_adj_list) - 1):\n        min_edge_weight = infinity\n        next_node = None\n        next_edge = None\n\n        # Find the minimum weight edge from the visited set to the unvisited set\n        for current_node in weighted_adj_list.keys():\n            for neighbor, weight in weighted_adj_list[current_node]:\n                if (\n                    visited[current_node]\n                    and not visited[neighbor]\n                    and weight &lt; min_edge_weight\n                ):\n                    min_edge_weight = weight\n                    next_node = neighbor\n                    next_edge = (current_node, neighbor)\n\n        # If no next node is found, the graph is disconnected\n        if next_node is None:\n            break\n\n        # Mark the next node as visited and add the edge to the MST\n        visited[next_node] = True\n        mst_edges.append(next_edge)\n\n        # Update the distances for the adjacent nodes of the newly visited node\n        for neighbor, weight in weighted_adj_list[next_node]:\n            if not visited[neighbor]:\n                min_distance[neighbor] = min(min_distance[neighbor], weight)\n\n    return mst_edges\n</code></pre>"},{"location":"week5/prims/#explanation","title":"Explanation:","text":"<ol> <li>Define the Three-Dimensional Array:</li> <li><code>adj_matrix</code> is a 3D NumPy array of shape <code>(num_nodes, num_nodes, 2)</code>.</li> <li> <p>The third dimension stores two values: <code>[presence, weight]</code>, where <code>presence</code> indicates the existence of an edge (1 for present, 0 for not present), and <code>weight</code> is the weight of the edge.</p> </li> <li> <p>Populate the Adjacency Matrix:</p> </li> <li> <p>For each edge, the matrix at position <code>[u, v]</code> is updated with the presence set to <code>1</code> and the weight.</p> </li> <li> <p>Create and Draw the Graph:</p> </li> <li>We use <code>nx.DiGraph()</code> to create a directed graph, which is important for handling negative cycles.</li> <li>Edges are added to the graph and it is drawn using NetworkX and Matplotlib.</li> <li> <p>The <code>spring_layout</code> is used for positioning the nodes.</p> </li> <li> <p>Detect Negative Cycle:</p> </li> <li>Using NetworkX's <code>find_negative_cycle</code> method (available from NetworkX version 2.6), we can detect and print any negative cycle present in the graph. If your NetworkX version does not support this method, you may need to implement a custom function or upgrade to a newer version.</li> </ol> <pre><code>weighted_adj_list = {\n    0: [(1, 10), (7, 8)],\n    1: [(0, 10), (2, 1), (5, 2)],\n    2: [(1, 1), (3, 1), (5, -2), (2, -4)],\n    3: [(2, 1), (4, 3)],\n    4: [(3, 3), (5, -1)],\n    5: [(4, -1), (6, -1), (2, -2)],\n    6: [(5, -1), (7, 1)],\n    7: [(6, 1), (0, 8)],\n}\n\nmst_edges = primlist(weighted_adj_list)\nprint(\"Minimum Spanning Tree Edges:\", mst_edges)\n</code></pre> <pre><code>Minimum Spanning Tree Edges: [(0, 7), (7, 6), (6, 5), (5, 2), (5, 4), (2, 1), (2, 3)]\n</code></pre> <pre><code># Create a NetworkX graph for the original graph\nG = nx.DiGraph()\nfor u in weighted_adj_list.keys():\n    for v, weight in weighted_adj_list[u]:\n        G.add_edge(u, v, weight=weight)\n\n# Create a NetworkX graph for the MST\nMST = nx.DiGraph()\nfor u, v in mst_edges:\n    for x, weight in weighted_adj_list[u]:\n        if x == v:\n            MST.add_edge(u, v, weight=weight)\n\n# Plot the original graph\npos = nx.spring_layout(G)  # Positions for all nodes\nplt.figure(figsize=(12, 6))\n\nplt.subplot(121)\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\nplt.title(\"Original Graph\")\n\n# Plot the Minimum Spanning Tree\nplt.subplot(122)\nnx.draw(\n    MST,\n    pos,\n    with_labels=True,\n    node_color=\"lightgreen\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nmst_edge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in MST.edges(data=True)}\nnx.draw_networkx_edge_labels(MST, pos, edge_labels=mst_edge_labels, font_size=10)\nplt.title(\"Minimum Spanning Tree\")\n\nplt.show()\n</code></pre> <p></p> <pre><code>def prim_mst(adj_list):\n\n    # Define infinity as a value larger than any edge weight\n    infinity = 1 + max(\n        [weight for node in adj_list.keys() for (neighbor, weight) in adj_list[node]]\n    )\n\n    # Initialize dictionaries to keep track of visited nodes, minimum distances, and parent nodes\n    visited = {}\n    min_distance = {}\n    parent = {}\n\n    # Set all nodes as not visited, their distances to infinity, and their parent to -1\n    for node in adj_list.keys():\n        visited[node] = False\n        min_distance[node] = infinity\n        parent[node] = -1\n\n    # Start with the first node (node 0)\n    visited[0] = True\n\n    # Update the distances and parents for the adjacent nodes of node 0\n    for neighbor, weight in adj_list[0]:\n        min_distance[neighbor] = weight\n        parent[neighbor] = 0\n\n    # Loop to find the minimum distance edge connecting a visited node to an unvisited node\n    for _ in range(1, len(adj_list.keys())):\n        # Find the smallest distance among the unvisited nodes\n        next_distance = min(\n            [min_distance[node] for node in adj_list.keys() if not visited[node]]\n        )\n        next_node_candidates = [\n            node\n            for node in adj_list.keys()\n            if not visited[node] and min_distance[node] == next_distance\n        ]\n\n        if not next_node_candidates:\n            break\n\n        # Choose the node with the smallest index among the candidates\n        next_node = min(next_node_candidates)\n        visited[next_node] = True\n\n        # Update the distances and parents for the adjacent nodes of the newly visited node\n        for neighbor, weight in adj_list[next_node]:\n            if not visited[neighbor] and weight &lt; min_distance[neighbor]:\n                min_distance[neighbor] = weight\n                parent[neighbor] = next_node\n\n    return parent\n</code></pre> <pre><code># Example usage\nweighted_adj_list = {\n    0: [(1, 10), (7, 8)],\n    1: [(0, 10), (2, 1), (5, 2)],\n    2: [(1, 1), (3, 1), (5, -2), (2, -4)],\n    3: [(2, 1), (4, 3)],\n    4: [(3, 3), (5, -1)],\n    5: [(4, -1), (6, -1), (2, -2)],\n    6: [(5, -1), (7, 1)],\n    7: [(6, 1), (0, 8)],\n}\n\nmst_parents = prim_mst(weighted_adj_list)\nprint(\"Parent nodes in MST:\", mst_parents)\n</code></pre> <pre><code>Parent nodes in MST: {0: -1, 1: 2, 2: 5, 3: 2, 4: 5, 5: 6, 6: 7, 7: 0}\n</code></pre> <pre><code>def create_mst_edges(parents):\n    \"\"\"\n    Creates a list of edges for the Minimum Spanning Tree (MST) from the parent node dictionary.\n\n    Args:\n    parents (dict): A dictionary where keys are nodes and values are their respective parent nodes in the MST.\n\n    Returns:\n    list: A list of tuples representing the edges in the MST.\n    \"\"\"\n    mst_edges = []\n    for child, parent in parents.items():\n        if parent != -1:\n            mst_edges.append((parent, child))\n    return mst_edges\n</code></pre> <pre><code>mst_edges = create_mst_edges(mst_parents)\nprint(\"MST Edges:\", mst_edges)\n\n# Create a NetworkX graph for the original graph\nG = nx.DiGraph()\nfor u in weighted_adj_list.keys():\n    for v, weight in weighted_adj_list[u]:\n        G.add_edge(u, v, weight=weight)\n\n# Create a NetworkX graph for the MST\nMST = nx.DiGraph()\nfor u, v in mst_edges:\n    for x, weight in weighted_adj_list[u]:\n        if x == v:\n            MST.add_edge(u, v, weight=weight)\n\n# Plot the original graph\npos = nx.spring_layout(G)  # Positions for all nodes\nplt.figure(figsize=(12, 6))\n\nplt.subplot(121)\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\nplt.title(\"Original Graph\")\n\n# Plot the Minimum Spanning Tree\nplt.subplot(122)\nnx.draw(\n    MST,\n    pos,\n    with_labels=True,\n    node_color=\"lightgreen\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nmst_edge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in MST.edges(data=True)}\nnx.draw_networkx_edge_labels(MST, pos, edge_labels=mst_edge_labels, font_size=10)\nplt.title(\"Minimum Spanning Tree\")\n\nplt.show()\n</code></pre> <pre><code>MST Edges: [(2, 1), (5, 2), (2, 3), (5, 4), (6, 5), (7, 6), (0, 7)]\n</code></pre> <p></p>"},{"location":"week5/prims/#explanation-of-the-updated-code","title":"Explanation of the Updated Code:","text":"<ol> <li>Function <code>prim_mst</code>:</li> <li><code>adj_list</code>: The adjacency list of the graph.</li> <li><code>infinity</code>: A large value greater than any edge weight.</li> <li><code>visited</code>: A dictionary to keep track of visited nodes.</li> <li><code>min_distance</code>: A dictionary to store the minimum distance from the MST to each node.</li> <li><code>parent</code>: A dictionary to store the parent node of each node in the MST.</li> <li>Initializes all nodes as not visited, sets their distances to infinity, and parents to -1.</li> <li>Starts with node <code>0</code>, marks it as visited, and updates distances and parents for its neighbors.</li> <li>Finds the minimum distance edge connecting a visited node to an unvisited node, updates distances and parents.</li> <li> <p>Returns the <code>parent</code> dictionary representing the parent of each node in the MST.</p> </li> <li> <p>Function <code>create_mst_edges</code>:</p> </li> <li><code>parents</code>: The parent dictionary returned by <code>prim_mst</code>.</li> <li>Constructs the MST edges using the parent dictionary.</li> <li> <p>Returns a list of MST edges.</p> </li> <li> <p>Graph Construction and Plotting:</p> </li> <li>Constructs the original graph and MST using NetworkX.</li> <li>Plots the original graph and MST side-by-side with labeled nodes and edge weights using Matplotlib and NetworkX.</li> </ol>"},{"location":"week5/prims/#output","title":"Output:","text":"<ul> <li>The code prints the parent nodes in the MST and the edges in the MST.</li> <li>It displays two plots: the original graph and the Minimum Spanning Tree (MST).</li> </ul>"},{"location":"week6/Lecture%206.1%20-%20Union-Find%20Data%20Structure/","title":"Lecture 6.1 - Union-Find Data Structure","text":""},{"location":"week6/Lecture%206.1%20-%20Union-Find%20Data%20Structure/#lecture-61-union-find-data-structure","title":"Lecture 6.1 - Union-Find Data Structure","text":"<p>Summary Introduction</p> <p>The Union-Find data structure is a fundamental algorithm used to manage and manipulate disjoint sets or partitions of elements. It efficiently performs two key operations: finding which set an element belongs to (Find) and merging sets containing specific elements (Union). This data structure finds applications in various algorithms and optimization problems, such as Kruskal's algorithm for minimum spanning trees and detecting connected components in graphs.</p> <p>Naive Implementation</p> <p>The naive implementation of the Union-Find data structure utilizes an array or dictionary called 'Component' to store the set to which each element belongs. The Find operation simply returns the value stored in 'Component' for the given element, which runs in O(1) time. The Union operation iterates over all elements in the set to which the first element belongs and updates their 'Component' values to match that of the second element, taking O(n) time, where 'n' is the number of elements in the set.</p> <p>Complexity:</p> <ul> <li>MakeUnionFind(S): O(n)</li> <li>Find(i): O(1)</li> <li>Union(i, j): O(n)</li> </ul> <p>Improved Implementation</p> <p>An improved version of the Union-Find data structure introduces an additional array or dictionary called 'Members', which stores the elements belonging to each set. It also maintains an array called 'Size' that keeps track of the number of elements in each set.</p> <p>Find(i): The Find operation returns the set to which element 'i' belongs by retrieving the value stored in 'Component' for 'i'.</p> <p>Union(i, j): The Union operation merges the sets containing elements 'i' and 'j'. It first checks if both elements belong to the same set. If not, it merges the smaller set into the larger one and updates the 'Component' values of the elements in the smaller set to match that of the larger set. It also updates the 'Size' array accordingly.</p> <p>Complexity:</p> <ul> <li>MakeUnionFind(S): O(n)</li> <li>Find(i): O(1)</li> <li>Union(i, j): O(Size[Component[i]])</li> </ul> <p>Amortized Analysis</p> <p>The improved implementation of the Union-Find data structure achieves an amortized complexity of O(log m) for the Union operation, where 'm' is the number of Union operations performed. This means that over a sequence of 'm' Union operations, the average time taken per operation is O(log m).</p> <p>This is achieved by always merging smaller sets into larger ones and ensuring that the size of a set at least doubles with each merge operation. As a result, the time taken to update the 'Component' and 'Size' arrays is bounded.</p> <p>Applications</p> <p>The Union-Find data structure has various applications in graph algorithms and optimization problems:</p> <ul> <li>Kruskal's Algorithm: Kruskal's algorithm finds the minimum spanning tree in a weighted graph. It uses the Union-Find data structure to merge components representing connected vertices in the graph, ensuring that the resulting tree is a minimum spanning tree.</li> <li>Cycle Detection in Graphs: The Union-Find data structure can be used to detect cycles in a graph. By maintaining sets of vertices that are connected by edges, it can quickly determine if two vertices belong to the same set, indicating the presence of a cycle.</li> <li>Disjoint Set Partitioning: The Union-Find data structure can be used to partition a set of elements into disjoint subsets, based on some criteria or relationship between the elements. This partitioning can be useful in various optimization problems and data analysis tasks.</li> </ul> <p>Summary</p> <p>The Union-Find data structure efficiently maintains disjoint sets of elements and supports the Find and Union operations. Its improved implementation, coupled with an amortized analysis, provides an efficient way to manage and manipulate sets, making it a valuable tool for solving a range of problems in computer science and algorithms.</p> <p>References</p> <ul> <li>Cormen, Thomas H., et al. \"Introduction to Algorithms, 3rd Edition.\" MIT Press, 2009.</li> <li>Skiena, Steven S. \"The Algorithm Design Manual, 2nd Edition.\" Springer, 2008.   Lec file</li> </ul>"},{"location":"week6/Lecture%206.1%20-%20Union-Find%20Data%20Structure/#lecture-61-union-find-data-structurepdf-pdf-file","title":"Lecture 6.1 - Union-Find Data Structure.pdf (PDF file)","text":""},{"location":"week6/Lecture%206.2%20-%20Priority%20Queues/","title":"Lecture 6.2 - Priority Queues.pdf (PDF file)","text":""},{"location":"week6/Lecture%206.2%20-%20Priority%20Queues/#lecture-62-priority-queuespdf-pdf-file","title":"Lecture 6.2 - Priority Queues.pdf (PDF file)","text":"<p>Summary Priority Queues</p> <p>Introduction</p> <p>A priority queue is a data structure that maintains a collection of elements, each with a priority. The operations on a priority queue are:</p> <ul> <li>insert(): Insert an element into the queue.</li> <li>delete max(): Remove and return the element with the highest priority from the queue.</li> </ul> <p>Applications</p> <p>Priority queues have a wide range of applications, including:</p> <ul> <li>Job scheduling: A job scheduler uses a priority queue to schedule jobs on a computer. The jobs with the highest priorities are scheduled first.</li> <li>Network routing: A network router uses a priority queue to route packets. The packets with the highest priorities are routed first.</li> <li>Event simulation: An event simulation uses a priority queue to simulate events. The events with the earliest time stamps are processed first.</li> </ul> <p>Implementing Priority Queues with One-Dimensional Structures</p> <p>One-dimensional structures, such as unsorted lists and sorted lists, can be used to implement priority queues. However, these implementations have limitations.</p> <p>Unsorted lists have O(n) insert() and delete max() operations, where n is the number of elements in the list. Sorted lists have O(1) delete max() operations, but O(n) insert() operations.</p> <p>Moving to Two Dimensions</p> <p>An alternative approach to implementing priority queues is to use two-dimensional structures. One implementation is to maintain a \u221aN \u00d7 \u221aN array, where each row is sorted in ascending order.</p> <ul> <li>insert(): Insert an element into the first row that has space.</li> <li>delete max(): Find the maximum element in the last column and delete it.</li> </ul> <p>This implementation has O(\u221aN) insert() and delete max() operations.</p> <p>Summary of Two-Dimensional Implementation</p> <ul> <li>2D \u221aN \u00d7 \u221aN array with sorted rows</li> <li>insert() is O(\u221aN)</li> <li>delete max() is O(\u221aN)</li> <li>Processing N items is O(N\u221aN)</li> </ul> <p>Can We Do Better?</p> <p>The two-dimensional implementation has a time complexity of O(\u221aN) for insert() and delete max() operations. Can we do better?</p> <p>Heaps</p> <p>A heap is a special binary tree that satisfies the following properties:</p> <ul> <li>The key of a node is greater than or equal to the keys of its children.</li> <li>The tree is complete, meaning that all levels are full except possibly the last level, which is filled from left to right.</li> </ul> <p>Heaps have the following performance characteristics:</p> <ul> <li>Height: O(log N)</li> <li>insert(): O(log N)</li> <li>delete max(): O(log N)</li> </ul> <p>Processing N Items with a Heap</p> <p>Using a heap to implement a priority queue, we can process N items in O(N log N) time. This is an improvement over the two-dimensional implementation, which takes O(N\u221aN) time.</p> <p>Summary of Heap Implementation</p> <ul> <li>Maintain a special binary tree \u2014 heap</li> <li>Height: O(log N)</li> <li>insert(): O(log N)</li> <li>delete max(): O(log N)</li> <li>Processing N items: O(N log N)</li> <li>Flexible \u2014 need not fix N in advance</li> </ul>"},{"location":"week6/Lecture%206.3%20-%20Heaps/","title":"Lecture 6.3 - Heaps.pdf (PDF file)","text":""},{"location":"week6/Lecture%206.3%20-%20Heaps/#lecture-63-heapspdf-pdf-file","title":"Lecture 6.3 - Heaps.pdf (PDF file)","text":"<p>Summary Heaps</p> <p>Introduction</p> <p>Heaps are a type of tree data structure that can be used to implement priority queues. A priority queue is a data structure that allows us to store and retrieve elements based on their priority. The element with the highest priority is always retrieved first.</p> <p>Binary Trees</p> <p>Heaps are implemented using binary trees. A binary tree is a tree data structure in which each node has at most two children. The left child is typically referred to as the left subtree, and the right child is referred to as the right subtree.</p> <p>Heap Property</p> <p>Heaps are binary trees that satisfy the heap property. The heap property states that the value of each node is greater than or equal to the value of its children. This property ensures that the element with the highest priority is always at the root of the heap.</p> <p>Types of Heaps</p> <p>There are two types of heaps:</p> <ul> <li>Max-heap: In a max-heap, the value of each node is greater than or equal to the value of its children.</li> <li>Min-heap: In a min-heap, the value of each node is less than or equal to the value of its children.</li> </ul> <p>Heap Operations</p> <p>The following are the \u043e\u0441\u043d\u043e\u0432\u043d\u0438 operations that can be performed on heaps:</p> <ul> <li>Insert: Inserts a new element into the heap.</li> <li>Delete: Deletes the element with the highest priority from the heap.</li> <li>Heapify: Builds a heap from an unsorted array.</li> </ul> <p>Complexity of Heap Operations</p> <p>The complexity of the heap operations is as follows:</p> <ul> <li>Insert: O(log N)</li> <li>Delete: O(log N)</li> <li>Heapify: O(N)</li> </ul> <p>Applications of Heaps</p> <p>Heaps can be used to solve a wide variety of problems, including:</p> <ul> <li>Priority queues: Heaps can be used to implement priority queues, which are used to store and retrieve elements based on their priority.</li> <li>Sorting: Heaps can be used to sort an array of elements in O(N log N) time.</li> <li>Selection: Heaps can be used to find the kth largest element in an array in O(N log k) time.</li> <li>Median: Heaps can be used to find the median of a set of numbers in O(N) time.</li> </ul> <p>Implementation</p> <p>Heaps can be implemented using a variety of data structures, including arrays and linked lists. The following is a simple implementation of a max-heap using an array:</p> <pre><code>class MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, value):\n        self.heap.append(value)\n        self._heapify_up(len(self.heap) - 1)\n\n    def delete_max(self):\n        if len(self.heap) == 0:\n            return None\n\n        max_value = self.heap[0]\n        self.heap[0] = self.heap[len(self.heap) - 1]\n        self.heap.pop()\n        self._heapify_down(0)\n\n        return max_value\n\n    def _heapify_up(self, index):\n        while index &gt; 0:\n            parent_index = (index - 1) // 2\n            if self.heap[index] &gt; self.heap[parent_index]:\n                self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n            index = parent_index\n\n    def _heapify_down(self, index):\n        while True:\n            left_child_index = (index * 2) + 1\n            right_child_index = (index * 2) + 2\n            largest_index = index\n\n            if left_child_index &lt; len(self.heap) and self.heap[left_child_index] &gt; self.heap[largest_index]:\n                largest_index = left_child_index\n\n            if right_child_index &lt; len(self.heap) and self.heap[right_child_index] &gt; self.heap[largest_index]:\n                largest_index = right_child_index\n\n            if largest_index == index:\n                break\n\n            self.heap[index], self.heap[largest_index] = self.heap[largest_index], self.heap[index]\n            index = largest_index\n</code></pre>"},{"location":"week6/Lecture%206.4%20-%20Using%20Heaps%20in%20Algorithms/","title":"Lecture 6.4 - Using Heaps in Algorithms.pdf (PDF file)","text":""},{"location":"week6/Lecture%206.4%20-%20Using%20Heaps%20in%20Algorithms/#lecture-64-using-heaps-in-algorithmspdf-pdf-file","title":"Lecture 6.4 - Using Heaps in Algorithms.pdf (PDF file)","text":"<p>Summary Heaps in Algorithms</p> <p>Priority Queues and Heaps</p> <p>Priority queues support the following operations:</p> <ul> <li>insert()</li> <li>delete max() or delete min()</li> </ul> <p>Heaps are a tree-based implementation of priority queues.</p> <ul> <li>insert(), delete max()/delete min() are both O(log n)</li> <li>heapify() builds a heap from a list/array in time O(n)</li> <li>Heap can be represented as a list/array</li> <li>Simple index arithmetic to find parent and children of a node</li> </ul> <p>To use a heap in an algorithm, we need:</p> <ul> <li>A way to locate the node to update</li> <li>A way to update the value of a node</li> </ul> <p>Updating Values in a Min-Heap</p> <ul> <li>Updating a value in a min-heap takes O(log n).</li> <li>Two additional dictionaries map vertices to heap positions and vice versa.</li> <li>Update VtoH and HtoV each time we swap values in the heap.</li> </ul> <p>Dijkstra's Algorithm</p> <p>Using Min-Heaps:</p> <ul> <li>Identifying the next vertex to visit is O(log n).</li> <li>Updating distance takes O(log n) per neighbor.</li> <li>Overall complexity: O((m+n) log n)</li> </ul> <p>Heap Sort</p> <ul> <li>Start with an unordered list.</li> <li>Build a heap \u2014 O(n).</li> <li>Call delete max() n times to extract elements in descending order \u2014 O(n log n).</li> <li>After each delete max(), the heap shrinks by 1.</li> <li>Store the maximum value at the end of the current heap.</li> <li>In-place O(n log n) sort.</li> </ul> <p>Summary</p> <ul> <li>Updating a value in a heap takes O(log n).</li> <li>Need to maintain additional pointers to map values to heap positions and vice versa.</li> <li>With this extended notion of heap, Dijkstra's algorithm complexity improves from O(n^2) to O((m+n) log n).</li> <li>In a similar way, improve Prim's algorithm to O((m+n) log n).</li> <li>Heaps can also be used to sort a list in place in O(n log n).</li> </ul>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/","title":"Lecture 6.5 - Search Trees.pdf (PDF file)","text":""},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#lecture-65-search-treespdf-pdf-file","title":"Lecture 6.5 - Search Trees.pdf (PDF file)","text":"<p>Summary</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#search-trees","title":"Search Trees","text":""},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#dynamic-sorted-data","title":"Dynamic Sorted Data","text":"<p>Dynamic sorted data is essential for efficient searching, especially when data changes dynamically with items being periodically inserted and deleted. Inserting or deleting an item from a sorted list takes O(n) time.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#binary-search-tree","title":"Binary Search Tree","text":"<p>A binary search tree (BST) is a tree data structure that maintains the property that all values in the left subtree of a node are less than the node's value, and all values in the right subtree are greater than the node's value.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#implementing-a-binary-search-tree","title":"Implementing a Binary Search Tree","text":"<p>Each node in a BST has a value and pointers to its children. To simplify implementation, an empty frontier is added with empty nodes filled with None values. The empty tree is a single empty node. Leaf nodes point to empty nodes. Implementing operations recursively becomes easier with this setup.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#inorder-traversal","title":"Inorder Traversal","text":"<p>Inorder traversal lists the values in a BST in sorted order by first listing the values in the left subtree, then the current node, and finally the values in the right subtree.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#find-a-value","title":"Find a Value","text":"<p>To find a value in a BST, start from the root node and compare the search value to the current node's value. If the search value is smaller, search the left subtree; if larger, search the right subtree. This process continues until the search value is found or the end of the tree is reached.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#minimum-and-maximum","title":"Minimum and Maximum","text":"<p>The minimum value in a BST is found in the leftmost node, and the maximum value is found in the rightmost node.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#insert-a-value","title":"Insert a Value","text":"<p>To insert a new value into a BST, first attempt to find it. If not found, insert it at the position where the search fails.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#delete-a-value","title":"Delete a Value","text":"<p>Deleting a value from a BST is more complex than insertion. If the value is not found, nothing is done. If the value is found in a leaf node, the node is simply made empty. If the value is found in a node with one child, the child is promoted to replace the node. If the value is found in a node with two children, the value is replaced with the maximum value of the left subtree, and that value is deleted from the left subtree.</p>"},{"location":"week6/Lecture%206.5%20-%20Search%20Trees/#complexity","title":"Complexity","text":"<p>The find(), insert(), and delete() operations in a BST all walk down a single path, resulting in a worst-case complexity of O(height of the tree). In an unbalanced tree with n nodes, the height can be O(n), leading to inefficient operations.</p> <p>However, balanced trees have a height of O(log n), ensuring that all operations remain efficient. Techniques for maintaining a balanced tree will be explored to guarantee O(log n) complexity for all operations.</p>"}]}