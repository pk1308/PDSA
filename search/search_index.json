{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-pdsa","title":"Welcome to PDSA","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":""},{"location":"#project-layout","title":"Project layout","text":""},{"location":"reference/priya_suggestion/","title":"Priya suggestion","text":"<pre><code>![Alt text](&lt;../artifacts/1.pdf&gt;){ type=application/pdf style=\"min-height:100vh;width:100%\" }\n</code></pre>"},{"location":"week1/Euclid%27s%20Algorithm/","title":"Euclid's Algorithm","text":"<p>Euclid's Algorithm</p> <p>Euclid's Algorithm is an efficient method for finding the greatest common divisor (GCD) of two positive integers. The GCD is the largest number that divides both integers without leaving a remainder.</p> <p>The Algorithm:</p> <ol> <li>Base Case: If one of the numbers is 0, the GCD is the other number.</li> <li>Recursive Step: While the second number is not 0:</li> <li>Divide the larger number by the smaller number and get the remainder.</li> <li>Set the larger number to the previous smaller number.</li> <li>Set the smaller number to the remainder obtained in the previous step.</li> <li>Return: Once the second number becomes 0, the GCD is the value stored in the first number (which was originally the larger number).</li> </ol> <p>Advantages:</p> <ul> <li>Efficient: Euclid's Algorithm has a time complexity of O(log(min(a, b))), where a and b are the two integers. This means it's relatively fast, especially for larger numbers.</li> <li>Simple to understand and implement.</li> </ul> <p>Python Implementation:</p> <pre><code>def gcd(a, b):\n  \"\"\"\n  This function implements Euclid's Algorithm to find the GCD of two positive integers.\n\n  Args:\n      a: The first positive integer.\n      b: The second positive integer.\n\n  Returns:\n      The GCD of a and b.\n  \"\"\"\n\n  a, b = max(a,b) , min(a,b)\n  while b != 0:\n    remainder = a % b\n    a = b\n    b = remainder\n  return a\n\n# Example usage\nnum1 = 97\nnum2 = 2\ngcd_result = gcd(num1, num2)\nprint(f\"The GCD of {num1} and {num2} is: {gcd_result}\")\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n  \"\"\"\n  This function implements Euclid's Algorithm to find the GCD of two positive integers.\n\n  Args:\n      m: The first positive integer.\n      n: The second positive integer.\n\n  Returns:\n      The GCD of m and n.\n  \"\"\"\n    (a, b) = (max(m,n) , min(m,n))\n    print(f\" a: {a} , b:{b}\")\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a%b)\n</code></pre> <p>This code defines a function <code>gcd</code> that takes two positive integers <code>a</code> and <code>b</code> as input and returns their GCD. It uses a loop to implement the recursive steps of Euclid's Algorithm. The example usage demonstrates how to call the function and print the result.</p>"},{"location":"week1/class%26object/","title":"Class&object","text":"<pre><code>class Stack:\n    \"\"\"\n    A Last-In-First-Out (LIFO) data structure implemented using a Python list.\n\n    Attributes:\n        __a (list): The internal list used to store the stack elements.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initializes an empty stack.\n        \"\"\"\n        self.__a = []\n\n    def pop(self):\n        \"\"\"\n        Removes and returns the element at the top of the stack (the last element added).\n\n        Returns:\n            The value at the top of the stack, or -1 if the stack is empty.\n        \"\"\"\n        if self.__a:\n            return self.__a.pop()\n        else:\n            return -1\n\n    def push(self, value):\n        \"\"\"\n        Adds a new element to the top of the stack.\n\n        Args:\n            value: The element to be pushed onto the stack.\n        \"\"\"\n        self.__a.append(value)\n\n    def peek(self):\n        \"\"\"\n        Returns the element at the top of the stack without removing it.\n\n        Returns:\n            The value at the top of the stack, or -1 if the stack is empty.\n        \"\"\"\n        if self.__a:\n            return self.__a[-1]\n        else:\n            return -1\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the stack (useful for debugging).\n\n        Returns:\n            A string representation of the stack contents.\n        \"\"\"\n        return str(self.__a)\n\n    def __dict__(self):\n        \"\"\"\n        Returns a dictionary representing the stack's attributes (for debugging).\n\n        Returns:\n            A dictionary containing the stack's attributes.\n        \"\"\"\n        return self.__dict__\n</code></pre> <pre><code>my_stack = Stack()\n\n# Push elements onto the stack\nmy_stack.push(10)\nmy_stack.push(20)\nmy_stack.push(30)\n\n# Get the top element without removing it\ntop_element = my_stack.peek()\nprint(f\"Top element: {top_element}\")  \n\n# Print the stack contents (for demonstration)\nprint(f\"Stack: {my_stack}\") \n</code></pre> <pre><code>Top element: 30\nStack: [10, 20, 30]\n</code></pre> <pre><code>value_removed = my_stack.pop()\nprint(f\"Valued removed : {value_removed}\")\n# Print the stack contents after removing the element \nprint(f\"Stack: {my_stack}\") \n</code></pre> <pre><code>Valued removed : 30\nStack: [10, 20]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week1/exception_handling/","title":"Exception handling","text":"<p>Exception Handling: Making Your Python Code Robust</p> <p>In Python programming, exceptions are events that disrupt the normal flow of your code's execution. These can arise from various situations, such as:</p> <ul> <li>Division by zero (e.g., <code>10 / 0</code>)</li> <li>Accessing elements outside a list's or array's index range (e.g., <code>my_list[10]</code> when the list has only 5 elements)</li> <li>File-related errors (e.g., trying to open a non-existent file)</li> <li>Network errors (e.g., attempting to connect to a unavailable server)</li> <li>User input errors (e.g., the user enters an invalid value)</li> </ul> <p>If left unhandled, exceptions can cause your program to crash abruptly, leading to a frustrating user experience. Exception handling provides a mechanism to gracefully manage these errors, making your code more robust and user-friendly.</p> <p>Core Constructs: <code>try</code>, <code>except</code>, and <code>finally</code></p> <p>Python offers three primary keywords for exception handling:</p> <ol> <li> <p><code>try</code> block: This block encloses the code that might potentially raise an exception.</p> </li> <li> <p><code>except</code> block: This block follows the <code>try</code> block and specifies how to handle exceptions that occur within the <code>try</code> block. You can have multiple <code>except</code> blocks to catch different types of exceptions:</p> </li> <li> <p>Bare <code>except</code>: Catches any exception type. Use this cautiously, as it can mask more specific errors.</p> </li> <li> <p><code>except ExceptionType</code>: Catches a specific exception type (e.g., <code>except ZeroDivisionError</code>).</p> </li> <li> <p><code>finally</code> block (optional): This block executes unconditionally, whether an exception occurs or not. It's often used for cleanup tasks like closing files or releasing resources.</p> </li> </ol> <p>Example:</p> <pre><code>def calculate_average(numbers):\n    try:\n        total = sum(numbers)\n        average = total / len(numbers)\n        return average\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero. Please provide a non-empty list.\")\n    finally:\n        print(\"Calculation completed.\")\n\n# Example usage\nnumbers = [1, 2, 3]\nresult = calculate_average(numbers)\nprint(result)  # Output: 2.0\n\nnumbers = []\nresult = calculate_average(numbers)  # Output: Error: Cannot divide by zero. Please provide a non-empty list.\n                                    #          Calculation completed.\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>calculate_average</code> function takes a list of numbers.</li> <li>The <code>try</code> block attempts to calculate the average.</li> <li>If a <code>ZeroDivisionError</code> occurs (division by zero), the corresponding <code>except</code> block prints an error message.</li> <li>The <code>finally</code> block always executes, regardless of exceptions, and prints a completion message.</li> </ul> <p>Key Points:</p> <ul> <li>Use specific exception types in <code>except</code> blocks for targeted handling.</li> <li><code>finally</code> is useful for essential cleanup tasks.</li> <li>Consider using <code>else</code> after the <code>try</code> block to execute code if no exception occurs.</li> <li>For more complex scenarios, you can nest <code>try...except</code> blocks.</li> </ul> <p>By effectively incorporating exception handling into your Python code, you can create more reliable and user-friendly applications.</p> <p>Python provides a rich set of built-in exceptions that cover various error conditions. Here's a comprehensive list of some common exceptions you'll encounter:</p> <p>Base Exceptions:</p> <ul> <li><code>BaseException</code>: The root class for all built-in exceptions. It's not meant to be directly used.</li> </ul> <p>Standard Exceptions:</p> <ul> <li><code>ArithmeticError</code>: Raised when an error occurs in arithmetic operations (e.g., division by zero).</li> <li><code>AssertionError</code>: Raised when an <code>assert</code> statement fails.</li> <li><code>AttributeError</code>: Raised when an attribute reference or assignment fails.</li> <li><code>EOFError</code>: Raised when <code>input()</code> hits the end-of-file (EOF) condition.</li> <li><code>FloatingPointError</code>: Raised when a result is too large or too small for a floating-point representation.</li> <li><code>GeneratorExit</code>: Raised when <code>next()</code> is called on a generator that has finished executing.</li> <li><code>ImportError</code>: Raised when importing a module fails.</li> <li><code>IndexError</code>: Raised when the index of a sequence is out of range.</li> <li><code>KeyError</code>: Raised when a key is not found in a dictionary.</li> <li><code>KeyboardInterrupt</code>: Raised when the user interrupts the program with Ctrl+C or Delete.</li> <li><code>LookupError</code>: Raised when a lookup operation (e.g., <code>x in y</code>) fails. This is the base class for <code>IndexError</code> and <code>KeyError</code>.</li> <li><code>MemoryError</code>: Raised when an operation runs out of memory.</li> <li><code>NameError</code>: Raised when a variable is not found in local or global scope.</li> <li><code>NotImplementedError</code>: Raised when an abstract method or requested operation isn't implemented.</li> <li><code>OSError</code>: Raised when a system-related operation causes an error. This is the base class for numerous OS-specific exceptions.</li> <li><code>OverflowError</code>: Raised when the result of an arithmetic operation is too large to be represented.</li> <li><code>RuntimeError</code>: Raised when some error occurs during runtime that doesn't fall into another category.</li> <li><code>StopIteration</code>: Raised by the <code>next()</code> function when there are no more elements in an iterator.</li> <li><code>SyntaxError</code>: Raised when a syntax error (invalid code) is encountered.</li> <li><code>SystemError</code>: Raised when an internal interpreter error occurs.</li> <li><code>SystemExit</code>: Raised by the <code>sys.exit()</code> function to exit the program.</li> <li><code>TabError</code>: Raised when inconsistent tabs and spaces are used for indentation.</li> <li><code>TypeError</code>: Raised when an operation or function receives an argument of an inappropriate type.</li> <li><code>ValueError</code>: Raised when an operation or function receives an argument that has an invalid value.</li> <li><code>Warning</code>: The base class for warning exceptions. It's not an error, but indicates a potential problem.</li> </ul> <p>Custom Exceptions:</p> <p>You can also define your own custom exceptions by subclassing the <code>Exception</code> class. This allows you to create specific exceptions for your application's needs.</p> <p>Remember that this list covers the most common built-in exceptions. The Python documentation provides a more exhaustive reference: https://docs.python.org/3/library/exceptions.html</p>"},{"location":"week1/time_it/","title":"Time it","text":"<pre><code>import time \n\nstart_time = time.perf_counter()\n</code></pre> <pre><code>end_time = time.perf_counter()\n</code></pre> <pre><code>start_time- end_time\n</code></pre> <pre><code>-0.250828417003504\n</code></pre> <pre><code>class TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None \n        self._stop_time = None \n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None \n    def elapsed(self):\n        if self.elapsed == None and self._start_time== None:\n            raise TimerError(\"the counter not running\")\n        elif self.elapsed == None and self._start_time != None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n    def __str__(self) -&gt; str:\n        return (str(self.elapsed_time))\n</code></pre> <pre><code>timer_obj =  TimerError()\n\nfor i in range(4,10):\n    timer_obj.start()\n    for j in range(10**i):\n        pass \n    print(f\" i: {i} time taken {timer_obj.elapsed()}\")\n</code></pre> <pre><code> i: 4 time taken 0.00022252700000535697\n i: 5 time taken 0.0022203449916560203\n i: 6 time taken 0.01746416199603118\n i: 7 time taken 0.14385948498966172\n i: 8 time taken 1.4716057649930008\n i: 9 time taken 14.134486352995737\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n    (a, b) = (max(m,n) , min(m,n))\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a-b)\ntimer_obj.start()\ngcd(9000,2)\ntimer_obj.elapsed()\n</code></pre> <pre><code>2.4133012630045414e-05\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n    (a, b) = (max(m,n) , min(m,n))\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a%b)\ntimer_obj.start()\ngcd(9000,2)\ntimer_obj.elapsed()\n</code></pre> <pre><code>2.3304994101636112e-05\n</code></pre>"},{"location":"week2/lec2.1/","title":"Lec2.1","text":"<p>Sim card vs Aadhar card example</p> <ul> <li>Naive</li> <li>smarter approach</li> </ul> <p>Main resources of interest</p> <ul> <li>running time</li> <li>space</li> </ul> <p>Time is depends on the processing power.</p> <ul> <li>10^6 operation for python</li> </ul> <p>Storage is limited by available.</p> <p>Running time depends on the input size.</p> <p>we will be measure time efficiency as a function of input size.</p> <ul> <li>input size n</li> <li>Running Time  t(n)</li> </ul> <p>$$ \\begin{array}{l} data\\ avaiable\\ of\\ Aadhaar\\ -\\ n\\ \\approx \\ 10^{9}\\ -\\ Naive\\ algorithin\\ t( n) \\ =\\ n^{2}\\</p> <p>-\\ clever\\ algo\\ t( n) \\ \\approx \\ n\\ \\log_{2} n \\end{array} $$</p> <p>Asymptotyic complexity</p> <ul> <li>means we will be ingonring the coinstants in the function as we will be looking at large value of n (input value )</li> <li>When comparingt(n), focus on orders of magnitudeIgnore constant factors.</li> </ul> <p></p> <p>Typically a natural parameter</p> <ul> <li>side of the list or array - sort / search</li> <li>number of objects we want to re arrange</li> <li>for graphs we will have two parameter</li> <li>vertices</li> <li>number of edge</li> </ul> <p>numeric problem </p> <ul> <li>magnitude of n is not the correct measure</li> <li>Arithmetic operations are performed digit by digitAddition with carry, subtraction with borrow, multiplication, long division .</li> </ul> <p>Ideally, want the \u201caverage\u201d behaviour</p> <ul> <li>Difficult to compute Average over what?</li> <li>Are all inputs equally likely?</li> <li>Need a probability distribution over inputs</li> </ul> <p>Instead, worst case input</p> <ul> <li>Input that forces algorithm to take longest possible time</li> <li>Search for a value that is not present in an unsorted list</li> <li>Must scan all elements</li> <li>Pessimistic \u2014 worst case may be rare</li> <li>Upper bound for worst case guarantees good performance.</li> </ul>"}]}