{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PDSA","text":""},{"location":"#welcome-to-pdsa","title":"Welcome to PDSA","text":""},{"location":"#pdsa-using-python","title":"PDSA using Python","text":"<p>This is an online textbook for the course Programming, Data Structures and Algorithms using Python (PDSA).</p> <p>Note to students : This book is meant to be used as a reference. You may find content that has not been covered in the video lectures. Likewise, there may be some content that is present in the lectures which is not covered here. Additional content appearing in this book will not be considered for grading. In summary, please refer to chapters that you feel are relevant for the course. But you are under no obligation to read the entire book cover to cover. Interested students are always welcome to read the entire thing!</p>"},{"location":"#index","title":"INDEX","text":"Week Content Summaryand Implementations link 1 Python recap, Why efficiency matters? Open 2 Algorithm analysis: Complexity and Notations, Searching algorithms:- Linear and Binary Search, Sorting algorithms:- Selection, Insertion and Merge Sort Open 3 Quick Sort, Data structures: Python List vs NumPy Array, Linked List, Hashing, Stack,Queue Open 4 Graph algorithms:- Introduction, Graph representation, BFS, DFS, Topological Sorting,Longest Path in DAG Open 5 Graph algorithms:- Shortest Path:- Dijkstra's, Bellman Ford and Floyd-Warshall Algorithm,Minimum Spanning Tree:- Prim's and Kruskal's Algorithm Open 6 Union-Find Data Structure, Data structures: Tree, Heap, Binary Search Tree Open 7 AVL Tree, Greedy Algorithm Open 8 Divide and Conquer Algorithm Open 9 Dynamic programming Open 10 String or Pattern Matching Algorithm and Regular Expressions Open 11 Complexity classes, Flow network and Linear programming"},{"location":"reference/book1/","title":"Book1","text":""},{"location":"reference/book2/","title":"Book2","text":""},{"location":"reference/book3/","title":"Book3","text":""},{"location":"reference/priya_suggestion/","title":"Priya suggestion","text":""},{"location":"week1/Euclid%27s%20Algorithm/","title":"Euclid's Algorithm","text":"<p>Euclid's Algorithm</p> <p>Euclid's Algorithm is an efficient method for finding the greatest common divisor (GCD) of two positive integers. The GCD is the largest number that divides both integers without leaving a remainder.</p> <p>The Algorithm:</p> <ol> <li>Base Case: If one of the numbers is 0, the GCD is the other number.</li> <li>Recursive Step: While the second number is not 0:</li> <li>Divide the larger number by the smaller number and get the remainder.</li> <li>Set the larger number to the previous smaller number.</li> <li>Set the smaller number to the remainder obtained in the previous step.</li> <li>Return: Once the second number becomes 0, the GCD is the value stored in the first number (which was originally the larger number).</li> </ol> <p>Advantages:</p> <ul> <li>Efficient: Euclid's Algorithm has a time complexity of O(log(min(a, b))), where a and b are the two integers. This means it's relatively fast, especially for larger numbers.</li> <li>Simple to understand and implement.</li> </ul> <p>Python Implementation:</p> <pre><code>def gcd(a, b):\n  \"\"\"\n  This function implements Euclid's Algorithm to find the GCD of two positive integers.\n\n  Args:\n      a: The first positive integer.\n      b: The second positive integer.\n\n  Returns:\n      The GCD of a and b.\n  \"\"\"\n\n  a, b = max(a,b) , min(a,b)\n  while b != 0:\n    remainder = a % b\n    a = b\n    b = remainder\n  return a\n\n# Example usage\nnum1 = 97\nnum2 = 2\ngcd_result = gcd(num1, num2)\nprint(f\"The GCD of {num1} and {num2} is: {gcd_result}\")\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n  \"\"\"\n  This function implements Euclid's Algorithm to find the GCD of two positive integers.\n\n  Args:\n      m: The first positive integer.\n      n: The second positive integer.\n\n  Returns:\n      The GCD of m and n.\n  \"\"\"\n    (a, b) = (max(m,n) , min(m,n))\n    print(f\" a: {a} , b:{b}\")\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a%b)\n</code></pre> <p>This code defines a function <code>gcd</code> that takes two positive integers <code>a</code> and <code>b</code> as input and returns their GCD. It uses a loop to implement the recursive steps of Euclid's Algorithm. The example usage demonstrates how to call the function and print the result.</p>"},{"location":"week1/class%26object/","title":"Class&object","text":"<pre><code>class Stack:\n    \"\"\"\n    A Last-In-First-Out (LIFO) data structure implemented using a Python list.\n\n    Attributes:\n        __a (list): The internal list used to store the stack elements.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initializes an empty stack.\n        \"\"\"\n        self.__a = []\n\n    def pop(self):\n        \"\"\"\n        Removes and returns the element at the top of the stack (the last element added).\n\n        Returns:\n            The value at the top of the stack, or -1 if the stack is empty.\n        \"\"\"\n        if self.__a:\n            return self.__a.pop()\n        else:\n            return -1\n\n    def push(self, value):\n        \"\"\"\n        Adds a new element to the top of the stack.\n\n        Args:\n            value: The element to be pushed onto the stack.\n        \"\"\"\n        self.__a.append(value)\n\n    def peek(self):\n        \"\"\"\n        Returns the element at the top of the stack without removing it.\n\n        Returns:\n            The value at the top of the stack, or -1 if the stack is empty.\n        \"\"\"\n        if self.__a:\n            return self.__a[-1]\n        else:\n            return -1\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the stack (useful for debugging).\n\n        Returns:\n            A string representation of the stack contents.\n        \"\"\"\n        return str(self.__a)\n\n    def __dict__(self):\n        \"\"\"\n        Returns a dictionary representing the stack's attributes (for debugging).\n\n        Returns:\n            A dictionary containing the stack's attributes.\n        \"\"\"\n        return self.__dict__\n</code></pre> <pre><code>my_stack = Stack()\n\n# Push elements onto the stack\nmy_stack.push(10)\nmy_stack.push(20)\nmy_stack.push(30)\n\n# Get the top element without removing it\ntop_element = my_stack.peek()\nprint(f\"Top element: {top_element}\")  \n\n# Print the stack contents (for demonstration)\nprint(f\"Stack: {my_stack}\") \n</code></pre> <pre><code>Top element: 30\nStack: [10, 20, 30]\n</code></pre> <pre><code>value_removed = my_stack.pop()\nprint(f\"Valued removed : {value_removed}\")\n# Print the stack contents after removing the element \nprint(f\"Stack: {my_stack}\") \n</code></pre> <pre><code>Valued removed : 30\nStack: [10, 20]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week1/exception_handling/","title":"Exception handling","text":"<p>Exception Handling: Making Your Python Code Robust</p> <p>In Python programming, exceptions are events that disrupt the normal flow of your code's execution. These can arise from various situations, such as:</p> <ul> <li>Division by zero (e.g., <code>10 / 0</code>)</li> <li>Accessing elements outside a list's or array's index range (e.g., <code>my_list[10]</code> when the list has only 5 elements)</li> <li>File-related errors (e.g., trying to open a non-existent file)</li> <li>Network errors (e.g., attempting to connect to a unavailable server)</li> <li>User input errors (e.g., the user enters an invalid value)</li> </ul> <p>If left unhandled, exceptions can cause your program to crash abruptly, leading to a frustrating user experience. Exception handling provides a mechanism to gracefully manage these errors, making your code more robust and user-friendly.</p> <p>Core Constructs: <code>try</code>, <code>except</code>, and <code>finally</code></p> <p>Python offers three primary keywords for exception handling:</p> <ol> <li> <p><code>try</code> block: This block encloses the code that might potentially raise an exception.</p> </li> <li> <p><code>except</code> block: This block follows the <code>try</code> block and specifies how to handle exceptions that occur within the <code>try</code> block. You can have multiple <code>except</code> blocks to catch different types of exceptions:</p> </li> <li> <p>Bare <code>except</code>: Catches any exception type. Use this cautiously, as it can mask more specific errors.</p> </li> <li> <p><code>except ExceptionType</code>: Catches a specific exception type (e.g., <code>except ZeroDivisionError</code>).</p> </li> <li> <p><code>finally</code> block (optional): This block executes unconditionally, whether an exception occurs or not. It's often used for cleanup tasks like closing files or releasing resources.</p> </li> </ol> <p>Example:</p> <pre><code>def calculate_average(numbers):\n    try:\n        total = sum(numbers)\n        average = total / len(numbers)\n        return average\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero. Please provide a non-empty list.\")\n    finally:\n        print(\"Calculation completed.\")\n\n# Example usage\nnumbers = [1, 2, 3]\nresult = calculate_average(numbers)\nprint(result)  # Output: 2.0\n\nnumbers = []\nresult = calculate_average(numbers)  # Output: Error: Cannot divide by zero. Please provide a non-empty list.\n                                    #          Calculation completed.\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>calculate_average</code> function takes a list of numbers.</li> <li>The <code>try</code> block attempts to calculate the average.</li> <li>If a <code>ZeroDivisionError</code> occurs (division by zero), the corresponding <code>except</code> block prints an error message.</li> <li>The <code>finally</code> block always executes, regardless of exceptions, and prints a completion message.</li> </ul> <p>Key Points:</p> <ul> <li>Use specific exception types in <code>except</code> blocks for targeted handling.</li> <li><code>finally</code> is useful for essential cleanup tasks.</li> <li>Consider using <code>else</code> after the <code>try</code> block to execute code if no exception occurs.</li> <li>For more complex scenarios, you can nest <code>try...except</code> blocks.</li> </ul> <p>By effectively incorporating exception handling into your Python code, you can create more reliable and user-friendly applications.</p> <p>Python provides a rich set of built-in exceptions that cover various error conditions. Here's a comprehensive list of some common exceptions you'll encounter:</p> <p>Base Exceptions:</p> <ul> <li><code>BaseException</code>: The root class for all built-in exceptions. It's not meant to be directly used.</li> </ul> <p>Standard Exceptions:</p> <ul> <li><code>ArithmeticError</code>: Raised when an error occurs in arithmetic operations (e.g., division by zero).</li> <li><code>AssertionError</code>: Raised when an <code>assert</code> statement fails.</li> <li><code>AttributeError</code>: Raised when an attribute reference or assignment fails.</li> <li><code>EOFError</code>: Raised when <code>input()</code> hits the end-of-file (EOF) condition.</li> <li><code>FloatingPointError</code>: Raised when a result is too large or too small for a floating-point representation.</li> <li><code>GeneratorExit</code>: Raised when <code>next()</code> is called on a generator that has finished executing.</li> <li><code>ImportError</code>: Raised when importing a module fails.</li> <li><code>IndexError</code>: Raised when the index of a sequence is out of range.</li> <li><code>KeyError</code>: Raised when a key is not found in a dictionary.</li> <li><code>KeyboardInterrupt</code>: Raised when the user interrupts the program with Ctrl+C or Delete.</li> <li><code>LookupError</code>: Raised when a lookup operation (e.g., <code>x in y</code>) fails. This is the base class for <code>IndexError</code> and <code>KeyError</code>.</li> <li><code>MemoryError</code>: Raised when an operation runs out of memory.</li> <li><code>NameError</code>: Raised when a variable is not found in local or global scope.</li> <li><code>NotImplementedError</code>: Raised when an abstract method or requested operation isn't implemented.</li> <li><code>OSError</code>: Raised when a system-related operation causes an error. This is the base class for numerous OS-specific exceptions.</li> <li><code>OverflowError</code>: Raised when the result of an arithmetic operation is too large to be represented.</li> <li><code>RuntimeError</code>: Raised when some error occurs during runtime that doesn't fall into another category.</li> <li><code>StopIteration</code>: Raised by the <code>next()</code> function when there are no more elements in an iterator.</li> <li><code>SyntaxError</code>: Raised when a syntax error (invalid code) is encountered.</li> <li><code>SystemError</code>: Raised when an internal interpreter error occurs.</li> <li><code>SystemExit</code>: Raised by the <code>sys.exit()</code> function to exit the program.</li> <li><code>TabError</code>: Raised when inconsistent tabs and spaces are used for indentation.</li> <li><code>TypeError</code>: Raised when an operation or function receives an argument of an inappropriate type.</li> <li><code>ValueError</code>: Raised when an operation or function receives an argument that has an invalid value.</li> <li><code>Warning</code>: The base class for warning exceptions. It's not an error, but indicates a potential problem.</li> </ul> <p>Custom Exceptions:</p> <p>You can also define your own custom exceptions by subclassing the <code>Exception</code> class. This allows you to create specific exceptions for your application's needs.</p> <p>Remember that this list covers the most common built-in exceptions. The Python documentation provides a more exhaustive reference: https://docs.python.org/3/library/exceptions.html</p>"},{"location":"week1/p_session/","title":"P session","text":"<pre><code>def shuffle(first_list : list , second_list : list )-&gt; list :\n\n    first_list_len , second_list_len = len(first_list) , len(second_list)\n\n    max_len = 0 \n    result = []\n    while max_len &lt; max(first_list_len, second_list_len) :\n        if max_len &lt; first_list_len:\n            result.append(first_list[max_len])\n        if max_len &lt; second_list_len:\n            result.append(second_list[max_len])\n        max_len+=1\n    return result\n</code></pre> <pre><code>def expanding(list_to_check : list ) -&gt; bool:\n\n    current_difference = -float(\"inf\")\n\n    for index in range(len(list_to_check)-1):\n        temp_difference = abs(list_to_check[index+1]-list_to_check[index])\n        if current_difference &gt;= temp_difference:\n            return False\n        else:\n            current_difference = temp_difference\n    return True \n</code></pre> <pre><code>L = [1,3,7,2,-3]\n</code></pre> <pre><code>expanding(L)\n</code></pre> <pre><code>2 3 1\n4 7 3\n5 2 7\n5 -3 2\n***************************\n5 -3 2\n\n\n\n\n\nFalse\n</code></pre> <pre><code>def sumsquare(list_of_value : list)-&gt; list:\n\n    odd = 0 \n    even = 0\n    for value in list_of_value:\n        if value%2==0:\n            even+= value**2\n        else:\n            odd += value**2\n    return [odd, even]\n</code></pre> <pre><code># write code here\ndef histogram(list_of_value : list )-&gt; list:\n    result_dic = {}\n    for i in list_of_value:\n        if i in result_dic:\n            result_dic[i]+=1\n        else:\n            result_dic[i] = 1 \n    return sorted(result_dic.items(), key=lambda item: (item[1], item[0]))\n</code></pre> <pre><code>histogram([7,12,11,13,7,11,13,14,12])\n</code></pre> <pre><code>[(14, 1), (7, 2), (11, 2), (12, 2), (13, 2)]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week1/ta_session_06_06/","title":"Ta session 06 06","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>25**.5==int(25)**0.5\n</code></pre> <pre><code>True\n</code></pre> <pre><code>def h(n):\n    return n**0.5 == int(n)**0.5\n</code></pre> <pre><code>h(24)\n</code></pre> <pre><code>True\n</code></pre> <pre><code>24**0.5\n</code></pre> <pre><code>4.898979485566356\n</code></pre> <pre><code>int(24)**0.5\n</code></pre> <pre><code>4.898979485566356\n</code></pre> <pre><code>def fun(m,n):\n    if m==n:\n        return n \n    else:\n        if m &gt; n:\n            return fun(m=m-n, n =n )\n        else:\n            return fun(m , n-m)\n</code></pre> <pre><code>fun(25,100)\n</code></pre> <pre><code>25\n</code></pre> <pre><code>def fun(N):\n    total  = 0 \n    for i in range(N//2, N ):\n        j = 2\n        while (j &lt;=N):\n            total = total + N/2\n            j = j * 2 \n    return total \n</code></pre> <pre><code>fun(1024)\n</code></pre> <pre><code>2621440.0\n</code></pre> <pre><code>import math \n</code></pre> <pre><code>(1024**2 * math.log2(1024) )/4\n</code></pre> <pre><code>2621440.0\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week1/time_it/","title":"Time it","text":"<pre><code>import time \n\nstart_time = time.perf_counter()\n</code></pre> <pre><code>end_time = time.perf_counter()\n</code></pre> <pre><code>start_time- end_time\n</code></pre> <pre><code>-0.250828417003504\n</code></pre> <pre><code>class TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None \n        self._stop_time = None \n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None \n    def elapsed(self):\n        if self.elapsed == None and self._start_time== None:\n            raise TimerError(\"the counter not running\")\n        elif self.elapsed == None and self._start_time != None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n    def __str__(self) -&gt; str:\n        return (str(self.elapsed_time))\n</code></pre> <pre><code>timer_obj =  TimerError()\n\nfor i in range(4,10):\n    timer_obj.start()\n    for j in range(10**i):\n        pass \n    print(f\" i: {i} time taken {timer_obj.elapsed()}\")\n</code></pre> <pre><code> i: 4 time taken 0.00022252700000535697\n i: 5 time taken 0.0022203449916560203\n i: 6 time taken 0.01746416199603118\n i: 7 time taken 0.14385948498966172\n i: 8 time taken 1.4716057649930008\n i: 9 time taken 14.134486352995737\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n    (a, b) = (max(m,n) , min(m,n))\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a-b)\ntimer_obj.start()\ngcd(9000,2)\ntimer_obj.elapsed()\n</code></pre> <pre><code>2.4133012630045414e-05\n</code></pre> <pre><code>def gcd( m : int , n : int )-&gt; int:\n    (a, b) = (max(m,n) , min(m,n))\n    if a%b == 0:\n        return b \n    else:\n        return gcd(b, a%b)\ntimer_obj.start()\ngcd(9000,2)\ntimer_obj.elapsed()\n</code></pre> <pre><code>2.3304994101636112e-05\n</code></pre>"},{"location":"week2/TA_session1/","title":"TA session1","text":"<pre><code>class Solution(object):\n    def answerQueries(self, nums, queries):\n        \"\"\"\n        :type nums: List[int]\n        :type queries: List[int]\n        :rtype: List[int]\n        \"\"\"\n        from bisect import bisect_right\n        nums.sort()\n        prefix_sums = []\n        for num in nums:\n            prefix_sums.append(num + (prefix_sums[-1] if prefix_sums else 0))\n\n        answer = []\n        for query in queries:\n            idx = bisect_right(prefix_sums, query)\n            answer.append(idx)\n\n        return answer\n</code></pre> <pre><code>num = [4,5,2,1]\nqueries = [3,10,21]\n</code></pre> <pre><code>x = Solution()\nx.answerQueries(num, queries)\n</code></pre> <pre><code>[2, 3, 4]\n</code></pre> <pre><code>class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        max_value = 0\n        max_count = 0 \n        dict_value = {}\n        for value in nums:\n            if value in dict_value:\n                dict_value[value]+=1\n            else:\n                dict_value[value]=1\n        result = []\n        for  key, values in dict_value.items():\n            if values == k:\n                result.append(key)\n        return result \n</code></pre> <pre><code>z = Solution()\nz.topKFrequent(nums=[1,1,1,2,2,3], k = 2)\n</code></pre> <pre><code>[2]\n</code></pre> <pre><code>test = {1:2 , 4:5}\n</code></pre> <pre><code>max(list(test.values()))\n</code></pre> <pre><code>5\n</code></pre> <pre><code>[7]*7\n</code></pre> <pre><code>[7, 7, 7, 7, 7, 7, 7]\n</code></pre> <pre><code>class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        test = {}\n        for value in nums:\n            if value in test:\n                test[value]+=1\n            else:\n                test[value]=1\n        result = []\n\n        for order in range(3):\n            occurrence = test.get(order)\n\n            result.extend([order]*occurrence)\n\n        return result\n</code></pre> <pre><code>x = Solution()\n\nx.sortColors([2,0,2,1,1,0])\n</code></pre> <pre><code>[0, 0, 1, 1, 2, 2]\n</code></pre> <pre><code>class Solution:\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n\n        intervals.sort(key=lambda x: x[0])  # Sort by starting point\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] &lt; interval[0]:\n                merged.append(interval)  # No overlap, add directly\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])  # Merge overlapping intervals\n\n        return merged\n</code></pre> <pre><code>x = Solution()\n\nx.merge([[1,4],[0,2],[3,5]])\n</code></pre> <pre><code>[[0, 5]]\n</code></pre> <pre><code>intervals= [[1,4],[0,2],[3,5]]\nintervals.sort()\n\nintervals\n</code></pre> <pre><code>[[0, 2], [1, 4], [3, 5]]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/grpa/","title":"Grpa","text":"<pre><code>def sort_list(L: list ):\n    if len(L) == 0:\n        return []\n    midpoint = len(L)//2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\ndef sort_list_descending(L: list) -&gt; list:\n    if len(L) == 0:\n        return []\n    midpoint = len(L)//2\n    mid_value = L[midpoint]\n    first_list = [first for first in L if int(first[1:]) &gt; int(mid_value[1:])]\n    mid_list = [mid for mid in L if int(mid[1:]) == int(mid_value[1:])]\n    last_list = [last for last in L if int(last[1:]) &lt; int(mid_value[1:])]\n    return sort_list_descending(first_list) + mid_list + sort_list_descending(last_list)\n\ndef combinationSort(strList: list) -&gt; list:\n    ascending_list , descending_list = [] , []\n    master_dict = {}\n\n    for value in strList:\n        if value[0] in master_dict:\n            master_dict[value[0]].append(value)\n        else:\n            master_dict[value[0]] = [value]\n    sorted_keys = sort_list(list(master_dict.keys()))\n    for keys in sorted_keys:\n        value_to_add = master_dict.get(keys)\n        ascending_list.extend(value_to_add)\n        if len(value_to_add) &gt; 1:\n            descending_list.extend(sort_list_descending(value_to_add))\n        else:\n            descending_list.extend(value_to_add)\n\n\n\n    return ascending_list , descending_list \n</code></pre> <pre><code>mast_dict = combinationSort([\"d34\", \"g54\", \"d12\", \"b87\", \"g1\", \"c65\", \"g40\", \"g5\", \"d77\"])\n</code></pre> <pre><code>mast_dict\n</code></pre> <pre><code>(['b87', 'c65', 'd34', 'd12', 'd77', 'g54', 'g1', 'g40', 'g5'],\n ['b87', 'c65', 'd77', 'd34', 'd12', 'g54', 'g40', 'g5', 'g1'])\n</code></pre> <pre><code>L = ['g54', 'g1', 'g40', 'g5']\n</code></pre> <pre><code>midpoint = len(L)//2\nmid_value = L[midpoint]\nfirst_list = [first for first in L if int(first[1:]) &gt; int(mid_value[1:])]\nmid_list = [mid for mid in L if int(mid[1:]) == int(mid_value[1:])]\nlast_list = [last for last in L if int(last[1:]) &lt; int(mid_value[1:])]\n</code></pre> <pre><code>first_list\n</code></pre> <pre><code>['g54']\n</code></pre> <pre><code>mid_list\n</code></pre> <pre><code>['g40']\n</code></pre> <pre><code>last_list\n</code></pre> <pre><code>['g1', 'g5']\n</code></pre> <pre><code>def findLargest(L):\n    left , right = 0 , len(L)-1\n    if len(L) ==1:\n        return L[0]\n\n    largest = -1 \n    while left &lt; right:\n        midpoint = L[(left+right)//2]\n        largest = max(largest, L[left], L[right] , midpoint)  # Update largest if temp is greater\n\n        if midpoint &gt; L[left] :\n            left = (left+right)//2+1\n        else:\n            right = (left+right)//2-1\n    return largest\n</code></pre> <pre><code>L =[7 ,8 ,2 ,4 ,5 ,6]\n</code></pre> <pre><code>findLargest(L)\n</code></pre> <pre><code>8\n</code></pre> <pre><code>L =[2 , 4 , 5 ,7 ,9]\n</code></pre> <pre><code>findLargest(L)\n</code></pre> <pre><code>9\n</code></pre> <pre><code>left , right = 0 , len(L)-1\n</code></pre> <pre><code>largest = -1 \n</code></pre> <pre><code>left , right\n</code></pre> <pre><code>(3, 2)\n</code></pre> <pre><code>midpoint = L[(left+right)//2]\nlargest = max(largest, L[left], L[right] , midpoint)  # Update largest if temp is greater\nlargest\n</code></pre> <pre><code>9\n</code></pre> <pre><code>if midpoint &gt; L[left] :\n            left = (left+right)//2+1\nelse:\n    right = (left+right)//2-1\n</code></pre> <pre><code>def selectionsort(L : list) -&gt; list :\n    number_of_elements = len(L)\n    if number_of_elements&lt;= 1:\n        return L\n    for i in range(number_of_elements):\n        index_to_sort = i \n        for j in range(i+1, number_of_elements):\n            if L[j] &lt; L[index_to_sort]:\n                L[j] , L[index_to_sort] = L[index_to_sort] , L[j]\n    return L\n</code></pre> <pre><code>selectionsort(L)\n</code></pre> <pre><code>[2, 4, 5, 7, 9]\n</code></pre> <pre><code>\n</code></pre> <pre><code>class MyList:\n    def __init__(self, data):\n        self.data = data\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, index):\n        return self.data[index]\n\n    def swap(self, indexA, other, indexB):\n        if isinstance(other, MyList):\n            self.data[indexA], other.data[indexB] = other.data[indexB], self.data[indexA]\n        else:\n            self.data[indexA], self.data[other] = self.data[other], self.data[indexA]\n</code></pre> <pre><code>def mergeInPlace(first_list , second_list):\n    len_of_first , len_of_second = len(first_list) , len(second_list)\n    pointer_first , pointer_second = 0, 0 \n\n    while pointer_first &lt; len_of_first and pointer_second &lt; len_of_second:\n        if first_list[pointer_first] &lt;= second_list[pointer_second]:\n            pointer_first+=1 \n        else:\n            first_list.swap(pointer_first, second_list, pointer_second)\n        # temp pointer to sorted second list \n        k = pointer_second\n        while k &lt; len_of_second-1 and second_list[k] &gt; second_list[k+1]:\n            second_list.swap(k, second_list, k+1)\n            k+=1\n        pointer_first+=1\n    return first_list , second_list    \n</code></pre> <pre><code>def mergeInPlace(first_list , second_list):\n    len_of_first , len_of_second = len(first_list) , len(second_list)\n    for first_index in range(len_of_first):\n        for second_index in range(len_of_second):\n            if first_list[first_index] &gt; second_list[second_index]:\n                first_list.swap(first_index, second_list, second_index)\n    for second_index in range(len_of_second):\n        for j in range(second_index+1, len_of_second):\n            if second_list[second_index] &gt; second_list[j]:\n                second_list.swap(second_index, second_list, j)\n    return first_list , second_list    \n</code></pre> <pre><code>A = MyList([2,4 ,6 ,9 ,13 ,15])\nB = MyList([1 ,3 ,5 ,10])\nmergeInPlace(A, B)\nprint(A.data)  # Output: [1, 2, 3]\nprint(B.data)  # Output: [4, 5, 6]\n</code></pre> <pre><code>[1, 2, 3, 4, 5, 6]\n[9, 10, 13, 15]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/insert_sort_2_6/","title":"Insert sort 2 6","text":"<pre><code>from loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\n# lg.add(sys.stdout, colorize=True)\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:21:09.423[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m37[0m - [1mtime taken:1.105800038203597e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 100) for i in range(1000)]\nV = random.randint(1, 100)\n</code></pre>"},{"location":"week2/insert_sort_2_6/#insertion-sort","title":"insertion sort","text":"<pre><code>def insertion_sort(L):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm.\n\n    Args:\n        L (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(L)\n\n    # If the list has 1 or fewer elements, it is already sorted\n    if n &lt;= 1:\n        return L\n\n    # Iterate through each element in the list\n    for i in range(n):\n        j = i\n\n        # Mo value_to_inserte the element at index j towards the beginning of the list\n        # until it's in the correct sorted position\n        while j &gt; 0 and L[j] &lt; L[j - 1]:\n            # Swap the current element with the prevalue_to_insertalue_to_insertious one if it's smaller\n            L[j], L[j - 1] = L[j - 1], L[j]\n            j -= (\n                1  # Decrement j to movalue_to_inserte towards the beginning of the list\n            )\n\n    return L\n</code></pre> <pre><code>T = TimerError()\nT.start()\ninsertion_sort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:47:10.805[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:0.014249863976147026[0m\n</code></pre> \\[ \\begin{gather*} outer\\ loop\\ =\\ n\\ \\\\ inner\\ loop\\ =\\ \\frac{n( n-1)}{2}\\\\ \\\\ complexity\\ =\\ O\\left( n^{2}\\right) \\end{gather*}\\] <pre><code>def Insert(List_to_sort, Value_to_insert):\n    \"\"\"\n    Inserts a value into a sorted list while maintaining the sorted order.\n\n    Args:\n        List_to_sort (list): The sorted list to insert the value into.\n        Value_to_insert (Any): The value to insert into the list.\n\n    Returns:\n        list: The sorted list after inserting the value.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list is empty, simply return the value as a single-element list\n    if n == 0:\n        return [Value_to_insert]\n\n    # If the value is greater than or equal to the last element in the list,\n    # append it to the end of the list\n    if Value_to_insert &gt;= List_to_sort[-1]:\n        return List_to_sort + [Value_to_insert]\n    else:\n        # Recursively insert the value into the sublist List_to_sort[:-1]\n        # and then append the last element of List_to_sort to the result\n        return Insert(List_to_sort[:-1], Value_to_insert) + List_to_sort[-1:]\n\n\ndef ISort(List_to_sort):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm recursively.\n\n    Args:\n        List_to_sort (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list has less than 1 element, it is already sorted\n    if n &lt; 1:\n        return List_to_sort\n\n    # Recursively sort the sublist List_to_sort[:-1]\n    # and then insert the last element of List_to_sort into the sorted sublist\n    L = Insert(ISort(List_to_sort[:-1]), List_to_sort[-1])\n\n    return L\n</code></pre> <pre><code>T = TimerError()\nT.start()\nISort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:49:07.900[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:0.003761364030651748[0m\n</code></pre> <p>$$ \\begin{gather*}</p> <p>complexity\\ =\\ O\\left( n^{2}\\right) \\end{gather*}$$</p>"},{"location":"week2/lec2.1/","title":"Lec2.1","text":"<p>Sim card vs Aadhar card example</p> <ul> <li>Naive</li> <li>smarter approach</li> </ul> <p>Main resources of interest</p> <ul> <li>running time</li> <li>space</li> </ul> <p>Time is depends on the processing power.</p> <ul> <li>10^6 operation for python</li> </ul> <p>Storage is limited by available.</p> <p>Running time depends on the input size.</p> <p>we will be measure time efficiency as a function of input size.</p> <ul> <li>input size n</li> <li>Running Time  t(n)</li> </ul> <p>$$ \\begin{array}{l} data\\ avaiable\\ of\\ Aadhaar\\ -\\ n\\ \\approx \\ 10^{9}\\ -\\ Naive\\ algorithin\\ t( n) \\ =\\ n^{2}\\</p> <p>-\\ clever\\ algo\\ t( n) \\ \\approx \\ n\\ \\log_{2} n \\end{array} $$</p> <p>Asymptotyic complexity</p> <ul> <li>means we will be ingonring the coinstants in the function as we will be looking at large value of n (input value )</li> <li>When comparingt(n), focus on orders of magnitudeIgnore constant factors.</li> </ul> <p></p> <p>Typically a natural parameter</p> <ul> <li>side of the list or array - sort / search</li> <li>number of objects we want to re arrange</li> <li>for graphs we will have two parameter</li> <li>vertices</li> <li>number of edge</li> </ul> <p>numeric problem </p> <ul> <li>magnitude of n is not the correct measure</li> <li>Arithmetic operations are performed digit by digitAddition with carry, subtraction with borrow, multiplication, long division .</li> </ul> <p>Ideally, want the \u201caverage\u201d behaviour</p> <ul> <li>Difficult to compute Average over what?</li> <li>Are all inputs equally likely?</li> <li>Need a probability distribution over inputs</li> </ul> <p>Instead, worst case input</p> <ul> <li>Input that forces algorithm to take longest possible time</li> <li>Search for a value that is not present in an unsorted list</li> <li>Must scan all elements</li> <li>Pessimistic \u2014 worst case may be rare</li> <li>Upper bound for worst case guarantees good performance.</li> </ul>"},{"location":"week2/lec2_2/","title":"Comparing Orders of Magnitude.","text":""},{"location":"week2/lec2_2/#comparing-orders-of-magnitude","title":"Comparing Orders of Magnitude.","text":"<p>f(x) is said to be O(g(x)) if we can find constants c and x0 such that c\u00b7g(x) is an upper bound forf(x) for x beyond x0 f(x)\u2264cg(x) </p> <p>pending -  greek and latin</p>"},{"location":"week2/lec2_3/","title":"Lec2 3","text":"<pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n</code></pre> <pre><code>class TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(1000000)]\n</code></pre> <pre><code>\n</code></pre> <pre><code>def MaxELement(L):\n    time = TimerError()\n    time.start()\n    maxval = L[0]\n    for i in range(len(L)):\n        if L[i] &gt; maxval:\n            maxval = L[i]\n    end_time = time.elapsed()\n    lg.info(f\"time take \\n {end_time}\")\n    return maxval\n</code></pre> <pre><code>MaxELement(L)\n</code></pre> <pre><code>[32m2024-05-08 15:07:43.327[0m | [1mINFO    [0m | [36m__main__[0m:[36mMaxELement[0m:[36m9[0m - [1mtime take \n 0.01241532398853451[0m\n\n\n\n\n\n999999798\n</code></pre>"},{"location":"week2/lec2_3/#input-size-n","title":"input size = N","text":"\\[ Overall\\ time\\ =\\ 0( n) \\]"},{"location":"week2/lec2_3/#example-2","title":"Example 2","text":"<pre><code>def noDuplicates(L):\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if L[i] == L[j]:\n                return False\n    return True\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = noDuplicates(L)\nlg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.224[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m4[0m - [1mFalse[0m\n[32m2024-05-08 15:07:46.225[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 2.88110359798884[0m\n</code></pre> <p>Time is</p> <p>$$</p> <p>  $$</p>"},{"location":"week2/lec2_3/#example-3","title":"Example 3","text":"<p>Matrix multiplication </p> <pre><code>def matrix_Multiplication(A, B):\n    (m, n, p) = (len(A), len(B), len(B[0]))\n    C = [[0 for i in range(p)] for j in range(m)]\n    for i in range(m):\n        for j in range(p):\n            for k in range(n):\n                C[i][j] = C[i][j] + A[i][k] * B[k][j]\n    return C\n</code></pre> <pre><code>m, n = 100, 1001\n</code></pre> <pre><code>A = [[random.randint(1, 100) for _ in range(n)] for j in range(m)]\nB = [[random.randint(1, 100) for _ in range(m)] for j in range(n)]\n</code></pre> <pre><code>len(A[0]), len(B)\n</code></pre> <pre><code>(1001, 1001)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = matrix_Multiplication(A, B)\n# lg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.752[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 0.4464707520091906[0m\n</code></pre> <pre><code>import numpy as np\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = np.matmul(A, B)\n# lg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.785[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 0.019344176980666816[0m\n</code></pre> \\[ \\begin{gather*} Overall\\ time\\ \\equiv O( MNP) \\ \\\\ Overall\\ time\\ \\equiv O\\left( N^{3}\\right) \\ if\\ N\\ x\\ N\\ \\ \\\\ \\end{gather*}\\]"},{"location":"week2/lec2_3/#example-3_1","title":"example 3","text":"<pre><code>def numberOfBits(n):\n    count = 1\n    while n &gt; 1:\n        count = count + 1\n        n = n // 2\n    return count\n</code></pre> <pre><code>T = TimerError()\nT.start()\nresult = numberOfBits(12564665525885888)\n# lg.info(result)\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.799[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime take \n 5.3243013098835945e-05[0m\n</code></pre> \\[Overall\\ time\\ =\\ O( log_{2} n)\\]"},{"location":"week2/lec2_3/#example-4","title":"example 4","text":"<p>Tower of hanoi </p> <pre><code># Recursive Python function to solve tower of hanoi\n\n\ndef TowerOfHanoi(n, from_rod, to_rod, aux_rod):\n    if n == 0:\n        return\n    TowerOfHanoi(n - 1, from_rod, aux_rod, to_rod)\n    print(\"Move disk\", n, \"from rod\", from_rod, \"to rod\", to_rod)\n    TowerOfHanoi(n - 1, aux_rod, to_rod, from_rod)\n\n\n# Driver code\nN = 10\nT = TimerError()\nT.start()\n# A, C, B are the name of rods\nTowerOfHanoi(N, \"A\", \"C\", \"B\")\nend_time = T.elapsed()\nlg.info(f\"time take \\n {end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 15:07:46.819[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m19[0m - [1mtime take \n 0.012417969992384315[0m\n\n\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 7 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 8 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 7 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 9 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 7 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 8 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 7 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 10 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 7 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 8 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 7 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 9 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 7 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 6 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 8 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 6 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 5 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 7 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 5 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 4 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 6 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 4 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 3 from rod C to rod A\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 5 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 3 from rod A to rod B\nMove disk 1 from rod C to rod A\nMove disk 2 from rod C to rod B\nMove disk 1 from rod A to rod B\nMove disk 4 from rod A to rod C\nMove disk 1 from rod B to rod C\nMove disk 2 from rod B to rod A\nMove disk 1 from rod C to rod A\nMove disk 3 from rod B to rod C\nMove disk 1 from rod A to rod B\nMove disk 2 from rod A to rod C\nMove disk 1 from rod B to rod C\n</code></pre> <pre><code>def Tower_of_Hanoi(n, from_rod, tp_rod, aux_rod):\n    if n:\n        pass\n</code></pre> \\[Overall\\ time\\ =\\ O(n^{2})\\]"},{"location":"week2/lec2_4_searchinlist/","title":"Lec2 4 searchinlist","text":"<pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.450[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m38[0m - [1mtime taken:1.1658004950731993e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(10000)]\n</code></pre> <pre><code>v = random.randint(1, 1000000)\n</code></pre>"},{"location":"week2/lec2_4_searchinlist/#naive-approach","title":"Naive Approach","text":"<pre><code>def naive_search(V, L):\n    for x in L:\n        if V == x:\n            return True\n    else:\n        return False\n</code></pre> <p>complexity = O(n)</p> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nprint(naive_search(v, L))\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.480[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.00020517699886113405[0m\n\n\nlength of L :10000\nFalse\n</code></pre>"},{"location":"week2/lec2_4_searchinlist/#binary-search","title":"binary search","text":""},{"location":"week2/lec2_4_searchinlist/#sorting-function","title":"sorting function","text":"<pre><code>def sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n</code></pre> <pre><code>midpoint = len(L) // 2\nmid_value = L[midpoint]\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nsort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.512[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.012002756993751973[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def sort_list(L: list) -&gt; list:\n    \"\"\"Sorts a list of numbers in ascending order using Quicksort algorithm.\n\n    Args:\n        L: The list to be sorted.\n\n    Returns:\n        A new list containing the sorted elements of the original list.\n    \"\"\"\n\n    if len(L) &lt;= 1:\n        return L\n\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = sort_list([low for low in L if low &lt; mid_value])\n    upper_list = sort_list([upper for upper in L if upper &gt; mid_value])\n    mid_list = [mid for mid in L if mid == mid_value]\n    return lower_list + mid_list + upper_list\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nL = sort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.538[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.009969204023946077[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def binarysearch(v: int, L: list) -&gt; bool:\n\n    if not L:\n        return False\n    midpoint = len(L) // 2\n\n    if v == L[midpoint]:\n        return True\n    if v &lt; L[midpoint]:\n        return binarysearch(v, L[:midpoint])\n    else:\n        return binarysearch(v, L[midpoint + 1 :])\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nprint(binarysearch(v, L))\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 17:13:40.554[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.0001781220198608935[0m\n\n\nlength of L :10000\nFalse\n</code></pre> <p>Complexity = O(logn)</p>"},{"location":"week2/lec_summary/","title":"Lec summary","text":"<p>for loop in pseudocode is  i =0 , i&lt;= n-1 , i++  this is equal to if n = 5  loop will run for n times then checks and terminate when  i == n  so total the loop will run for n+1 </p> <p>j loop will fun for n * (n+1)</p> <p>The Cauchy-Schwarz Inequality</p> <pre><code>$\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)$\n</code></pre>"},{"location":"week2/live_session/","title":"Live session","text":"<p>Space Complexity </p> <ul> <li>fixed part(C) - size of code</li> <li>Variable Part (\\(S_x\\)) = the size of the input</li> <li>T(X) =  C + \\(S_x\\) = Total space</li> </ul> <p>Time  Complexity </p> <ul> <li>Best case</li> <li>Average Case</li> <li>Worst case</li> </ul> <p>unit of time - how many steps or code is excuteds for a input n</p> <p>notion to represent complexity </p> <ul> <li>Big o  O(n) = upper Bound</li> <li>always f(n)  less than or = c * g(n)</li> <li>Omega - lower bound</li> <li>theta - Tightly bound - average case</li> </ul> <p></p>"},{"location":"week2/master%20theorm/","title":"Master theorm","text":"<p>The time complexity of the merge sort algorithm can be analyzed using the recurrence relation and its components. Let's break it down and then solve the recurrence relation to determine the overall complexity.</p>"},{"location":"week2/master%20theorm/#components-of-merge-sort","title":"Components of Merge Sort","text":"<ol> <li>Base Case: When the list has 0 or 1 element, the function returns immediately with O(1) time complexity.</li> <li>Splitting the List: Dividing the list into two halves takes O(1) time since it only involves calculating the middle index and slicing the list.</li> <li>Recursive Calls: The function makes two recursive calls, each with a list half the size of the original, leading to <code>2T(n/2)</code>.</li> <li>Merging: Merging the two sorted halves takes O(n) time, where n is the total number of elements in the list.</li> </ol>"},{"location":"week2/master%20theorm/#recurrence-relation","title":"Recurrence Relation","text":"<p>The recurrence relation for merge sort can be written as:  </p>"},{"location":"week2/master%20theorm/#solving-the-recurrence-relation","title":"Solving the Recurrence Relation","text":"<p>We can solve this recurrence relation using the Master Theorem for divide-and-conquer recurrences of the form:  </p> <p>For merge sort:</p> <ul> <li>\\( a = 2 \\) (number of subproblems)</li> <li>\\( b = 2 \\) (each subproblem size is n/2)</li> <li>\\( f(n) = O(n) \\) (the cost of dividing and merging)</li> </ul> <p>According to the Master Theorem, we compare \\( f(n) \\) with \\( n^{\\log_b{a}} \\):</p> <ol> <li>Calculate \\( \\log_b{a} \\):     </li> <li> <p>Compare \\( f(n) \\) with \\( n^{\\log_b{a}} \\):</p> </li> <li> <p>\\( f(n) = O(n) \\)</p> </li> <li>\\( n^{\\log_2{2}} = n^1 = n \\)</li> </ol> <p>Since \\( f(n) \\) is \\( O(n) \\) and \\( n^{\\log_2{2}} \\) is also \\( O(n) \\), we are in case 2 of the Master Theorem, which states:</p> <p>If \\( f(n) = O(n^{\\log_b{a}}) \\), then:  </p> <p>Thus:  </p>"},{"location":"week2/master%20theorm/#conclusion","title":"Conclusion","text":"<p>The overall time complexity of merge sort is:  </p> <p>This complexity reflects the efficient performance of merge sort for large datasets, combining the divide-and-conquer approach with efficient merging, resulting in a logarithmic number of levels of recursion and linear work per level.</p>"},{"location":"week2/mergesort2_7/","title":"Mergesort2 7","text":"<pre><code>from loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\n# lg.add(sys.stdout, colorize=True)\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 22:56:27.046[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m37[0m - [1mtime taken:1.082499511539936e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 100) for i in range(1000)]\nV = random.randint(1, 100)\n</code></pre> <pre><code>def merge(A, B):\n    \"\"\"\n    Merge two sorted lists A and B into a single sorted list.\n\n    Args:\n        A (list): The first sorted list.\n        B (list): The second sorted list.\n\n    Returns:\n        list: The merged sorted list.\n    \"\"\"\n    C, i, j, k = [], 0, 0, 0\n    m, n = len(A), len(B)\n\n    while k &lt; m + n:\n        if i == m:\n            C.extend(B[j:])\n            k = k + (n - j)\n        elif j == n:\n            C.extend(A[i:])\n            k = k + (m - i)\n        elif A[i] &lt; B[j]:\n            C.append(A[i])\n            i, k = i + 1, k + 1\n        else:\n            C.append(B[j])\n            j, k = j + 1, k + 1\n\n    return C\n\n\ndef mergesort(A):\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    Args:\n        A (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(A)\n\n    # Base case: If the list has 0 or 1 element, it is already sorted\n    if n &lt;= 1:\n        return A\n\n    # Recursively split the list into two halves and sort each half\n    L = mergesort(A[: n // 2])\n    R = mergesort(A[n // 2 :])\n\n    # Merge the sorted halves\n    B = merge(L, R)\n\n    return B\n</code></pre> \\[complexity\\ =\\ O\\left( nlogn\\right)\\] <pre><code>T = TimerError()\nT.start()\nmergesort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:07:56.251[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:0.0008673730189912021[0m\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/ppa/","title":"Ppa","text":"<pre><code>def merge(first_list : list, second_list : list) -&gt; list:\n\n    sorted_listed = list() \n    first_list_size = len(first_list)\n    second_list_size = len(second_list)\n    first_pointer , second_pointer = 0, 0 \n    while len(sorted_listed) &lt; first_list_size+second_list_size:\n        if first_pointer == first_list_size:\n            sorted_listed.extend(second_list[second_pointer:])\n            break\n        elif second_pointer == second_list_size:\n            sorted_listed.extend(first_list[first_pointer:])\n            break\n        elif first_list[first_pointer] &lt; second_list[second_pointer]:\n            sorted_listed.append(first_list[first_pointer])\n            first_pointer += 1\n        else:\n            sorted_listed.append(second_list[second_pointer])\n            second_pointer += 1\n    return  sorted_listed\n\ndef merge_sort( list_to_sort : list) -&gt; list:\n\n    if len(list_to_sort) &lt;= 1:\n        return list_to_sort\n\n    mid = len(list_to_sort) // 2\n\n    left = merge_sort(list_to_sort[:mid])\n    right = merge_sort(list_to_sort[mid:])\n    return merge(left, right)\n\ndef  binarySearchIndexAndComparisons(list_to_sort : list , value_to_check) -&gt; tuple:\n    search_result =  False\n    value_compared = 0\n    sorted_list = merge_sort(list_to_sort)\n    left , right = 0, len(sorted_list)-1\n    while left &lt;=right:\n        mid = (left + right) // 2\n        value_compared += 1\n        if value_to_check == sorted_list[mid]:\n            search_result = True\n            return (search_result, value_compared)\n        elif value_to_check &lt; sorted_list[mid]:\n            right = mid-1\n        elif value_to_check &gt; sorted_list[mid]:\n            left = mid + 1\n    return (search_result, value_compared)\n</code></pre> <pre><code>import random\nL = [random.randint(1, 100) for i in range(10)]\nV = random.randint(1, 100)\nprint(L)\nj = merge_sort(L)\n</code></pre> <pre><code>[67, 65, 11, 52, 50, 99, 9, 31, 2, 23]\n</code></pre> <pre><code>L=[2, 6, 8, 11, 17, 23, 33, 44, 46, 50, 65]\n</code></pre> <pre><code>binarySearchIndexAndComparisons(L,100)\n</code></pre> <pre><code>(False, 4)\n</code></pre> <pre><code>len(L)//2\n</code></pre> <pre><code>5\n</code></pre> <pre><code>j[5]\n</code></pre> <pre><code>54\n</code></pre> <pre><code>j\n</code></pre> <pre><code>[8, 9, 37, 37, 41, 54, 76, 84, 90, 97]\n</code></pre> <pre><code>[0]*4\n</code></pre> <pre><code>[0, 0, 0, 0]\n</code></pre>"},{"location":"week2/ppa/#dont-return-the-sorted-listed-the-sorted-has-to-be-same","title":"dont return the sorted listed , the sorted has to be same","text":"<pre><code>def sortInRange(list_to_sort : list,range_value: int)-&gt; list:\n    result_dict = {}\n    for n in list_to_sort:\n        if n in result_dict:\n            result_dict[n].append(n)\n        else:\n            result_dict[n] = [n]\n    list_to_sort.clear()\n    for i in range(range_value):\n        list_to_sort.extend(result_dict.get(i))\n    return\n</code></pre> <pre><code>L = [2 ,0, 1, 1 ,2, 3 ,0, 2, 1 ,0, 2, 3 ,1, 2]\nvalue = 4 \n\nsortInRange(L, 4)\n</code></pre> <pre><code>L\n</code></pre> <pre><code>[0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week2/selection_sort_2_5/","title":"Selection sort 2 5","text":"<pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\n# lg.add(sys.stdout, colorize=True)\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 18:59:53.053[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m38[0m - [1mtime taken:1.0107993148267269e-05[0m\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(1000000)]\n</code></pre> <pre><code>def SelectionSort(L):\n    n = len(L)\n    if n &lt;= 1:\n        return L\n    for i in range(n):\n        # Assume L[:i] is sorted\n        mpos = i\n        # mpos: position of minimum in L[i:]\n        for j in range(i + 1, n):\n            if L[j] &lt; L[mpos]:\n                mpos = j\n                # L[mpos] : smallest value in L[i:]\n                # # Exchange L[mpos] and L[i]\n                (L[i], L[mpos]) = (L[mpos], L[i])\n                # Now L[:i+1] is sorted\n                return L\n</code></pre> \\[T(n) =  O(N^{2})\\] <pre><code>T = TimerError()\nT.start()\nSelectionSort(L)\nend_time_1 = T.elapsed()\nlg.info(f\"time taken:{end_time_1}\")\n</code></pre> <pre><code>[32m2024-05-08 19:01:03.132[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:2.2412044927477837e-05[0m\n</code></pre> <pre><code>def sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nsort_list(L)\nend_time_2 = T.elapsed()\nlg.info(f\"time taken:{end_time_2}\")\n</code></pre> <pre><code>[32m2024-05-08 19:01:42.396[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken:1.7496046359883621[0m\n</code></pre>"},{"location":"week2/week%20summary/","title":"Week summary","text":"<pre><code>import sys\n\nsys.setrecursionlimit(2**31 - 1)\n</code></pre> <pre><code>import sys\nfrom loguru import logger as lg\nimport random\nimport time\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:37.997[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m38[0m - [1mtime taken:1.1069001629948616e-05[0m\n</code></pre> <pre><code>random.seed(1965)\n</code></pre> <pre><code>L = [random.randint(1, 1000000000) for i in range(10000)]\n</code></pre> <pre><code>v = random.randint(1, 1000000)\n</code></pre>"},{"location":"week2/week%20summary/#naive-approach","title":"Naive Approach","text":"<pre><code>def naive_search(V, L):\n    for x in L:\n        if V == x:\n            return True\n    else:\n        return False\n</code></pre> <p>complexity = O(n)</p>"},{"location":"week2/week%20summary/#binary-search","title":"binary search","text":""},{"location":"week2/week%20summary/#sorting-function","title":"sorting function","text":"<pre><code>def sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n</code></pre> <pre><code>midpoint = len(L) // 2\nmid_value = L[midpoint]\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nsort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.066[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.011552168987691402[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def sort_list(L: list) -&gt; list:\n    \"\"\"Sorts a list of numbers in ascending order using Quicksort algorithm.\n\n    Args:\n        L: The list to be sorted.\n\n    Returns:\n        A new list containing the sorted elements of the original list.\n    \"\"\"\n\n    if len(L) &lt;= 1:\n        return L\n\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = sort_list([low for low in L if low &lt; mid_value])\n    upper_list = sort_list([upper for upper in L if upper &gt; mid_value])\n    mid_list = [mid for mid in L if mid == mid_value]\n    return lower_list + mid_list + upper_list\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nL = sort_list(L)\nend_time = T.elapsed()\nlg.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.093[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken:0.01215230894740671[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>def binarysearch(v: int, L: list) -&gt; bool:\n\n    if not L:\n        return False\n    midpoint = len(L) // 2\n\n    if v == L[midpoint]:\n        return True\n    if v &lt; L[midpoint]:\n        return binarysearch(v, L[:midpoint])\n    else:\n        return binarysearch(v, L[midpoint + 1 :])\n</code></pre> <p>Complexity = O(logn)</p> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nend_time = T.elapsed()\nlg.info(f\"time taken naive :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.106[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m5[0m - [1mtime taken naive :0.0001515159965492785[0m\n\n\nlength of L :10000\n</code></pre> <pre><code>T = TimerError()\nT.start()\nprint(f\"length of L :{len(L)}\")\nprint(binarysearch(v, L))\nend_time = T.elapsed()\nlg.info(f\"time taken binary:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.112[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken binary:0.0001189609756693244[0m\n\n\nlength of L :10000\nFalse\n</code></pre> <pre><code>def SelectionSort(L):\n    n = len(L)\n    if n &lt;= 1:\n        return L\n    for i in range(n):\n        # Assume L[:i] is sorted\n        mpos = i\n        # mpos: position of minimum in L[i:]\n        for j in range(i + 1, n):\n            if L[j] &lt; L[mpos]:\n                mpos = j\n                # L[mpos] : smallest value in L[i:]\n                # # Exchange L[mpos] and L[i]\n                (L[i], L[mpos]) = (L[mpos], L[i])\n                # Now L[:i+1] is sorted\n                return L\n\n\nT = TimerError()\nT.start()\nSelectionSort(L)\nend_time_1 = T.elapsed()\nlg.info(f\"time taken SelectionSort:{end_time_1}\")\n\n\ndef sort_list(L: list):\n    if len(L) == 0:\n        return []\n    midpoint = len(L) // 2\n    mid_value = L[midpoint]\n    lower_list = [low for low in L if low &lt; mid_value]\n    mid_list = [mid for mid in L if mid == mid_value]\n    upper_list = [upper for upper in L if upper &gt; mid_value]\n    return sort_list(lower_list) + mid_list + sort_list(upper_list)\n\n\nT = TimerError()\nT.start()\nsort_list(L)\nend_time_2 = T.elapsed()\nlg.info(f\"time taken sort_list:{end_time_2}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.914[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m21[0m - [1mtime taken SelectionSort:0.7941872259834781[0m\n[32m2024-05-08 23:58:38.922[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m35[0m - [1mtime taken sort_list:0.007573203009087592[0m\n</code></pre> <pre><code># insertion sort\ndef insertion_sort(L):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm.\n\n    Args:\n        L (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(L)\n\n    # If the list has 1 or fewer elements, it is already sorted\n    if n &lt;= 1:\n        return L\n\n    # Iterate through each element in the list\n    for i in range(n):\n        j = i\n\n        # Mo value_to_inserte the element at index j towards the beginning of the list\n        # until it's in the correct sorted position\n        while j &gt; 0 and L[j] &lt; L[j - 1]:\n            # Swap the current element with the prevalue_to_insertalue_to_insertious one if it's smaller\n            L[j], L[j - 1] = L[j - 1], L[j]\n            j -= (\n                1  # Decrement j to movalue_to_inserte towards the beginning of the list\n            )\n\n    return L\n\n\nT = TimerError()\nT.start()\ninsertion_sort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken insertion_sort:{end_time}\")\n\n\ndef Insert(List_to_sort, Value_to_insert):\n    \"\"\"\n    Inserts a value into a sorted list while maintaining the sorted order.\n\n    Args:\n        List_to_sort (list): The sorted list to insert the value into.\n        Value_to_insert (Any): The value to insert into the list.\n\n    Returns:\n        list: The sorted list after inserting the value.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list is empty, simply return the value as a single-element list\n    if n == 0:\n        return [Value_to_insert]\n\n    # If the value is greater than or equal to the last element in the list,\n    # append it to the end of the list\n    if Value_to_insert &gt;= List_to_sort[-1]:\n        return List_to_sort + [Value_to_insert]\n    else:\n        # Recursively insert the value into the sublist List_to_sort[:-1]\n        # and then append the last element of List_to_sort to the result\n        return Insert(List_to_sort[:-1], Value_to_insert) + List_to_sort[-1:]\n\n\ndef ISort(List_to_sort):\n    \"\"\"\n    Sorts a list using the insertion sort algorithm recursively.\n\n    Args:\n        List_to_sort (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(List_to_sort)\n\n    # If the list has less than 1 element, it is already sorted\n    if n &lt; 1:\n        return List_to_sort\n\n    # Recursively sort the sublist List_to_sort[:-1]\n    # and then insert the last element of List_to_sort into the sorted sublist\n    L = Insert(ISort(List_to_sort[:-1]), List_to_sort[-1])\n\n    return L\n\n\nT = TimerError()\nT.start()\nISort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken merge Sort(:{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:38.929[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m35[0m - [1mtime taken insertion_sort:0.0003439149586483836[0m\n[32m2024-05-08 23:58:39.333[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m89[0m - [1mtime taken merge Sort(:0.40309521002927795[0m\n</code></pre> <pre><code>def merge(A, B):\n    \"\"\"\n    Merge two sorted lists A and B into a single sorted list.\n\n    Args:\n        A (list): The first sorted list.\n        B (list): The second sorted list.\n\n    Returns:\n        list: The merged sorted list.\n    \"\"\"\n    C, i, j, k = [], 0, 0, 0\n    m, n = len(A), len(B)\n\n    while k &lt; m + n:\n        if i == m:\n            C.extend(B[j:])\n            k = k + (n - j)\n        elif j == n:\n            C.extend(A[i:])\n            k = k + (m - i)\n        elif A[i] &lt; B[j]:\n            C.append(A[i])\n            i, k = i + 1, k + 1\n        else:\n            C.append(B[j])\n            j, k = j + 1, k + 1\n\n    return C\n\n\ndef mergesort(A):\n    \"\"\"\n    Sorts a list using the merge sort algorithm.\n\n    Args:\n        A (list): The list to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(A)\n\n    # Base case: If the list has 0 or 1 element, it is already sorted\n    if n &lt;= 1:\n        return A\n\n    # Recursively split the list into two halves and sort each half\n    L = mergesort(A[: n // 2])\n    R = mergesort(A[n // 2 :])\n\n    # Merge the sorted halves\n    B = merge(L, R)\n\n    return B\n\n\nT = TimerError()\nT.start()\nmergesort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:39.347[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m64[0m - [1mtime taken merge sort :0.006971621012780815[0m\n</code></pre> <pre><code>T = TimerError()\nT.start()\n\nmergesort(list(range(1000000, 0, -1)))\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:40.284[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken merge sort :0.9263360829791054[0m\n</code></pre> <pre><code>T = TimerError()\nT.start()\n\nmergesort(list(range(1000000)))\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:58:41.205[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken merge sort :0.9164764899760485[0m\n</code></pre> <pre><code>L = [random.randint(1, 1000000) for i in range(1000000)]\nT = TimerError()\nT.start()\nmergesort(L)\nend_time = T.elapsed()\nlg.info(f\"time taken merge sort :{end_time}\")\n</code></pre> <pre><code>[32m2024-05-08 23:59:49.059[0m | [1mINFO    [0m | [36m__main__[0m:[36m&lt;module&gt;[0m:[36m6[0m - [1mtime taken merge sort :1.6022985609597526[0m\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/list%26dictionary_imp_3_9/","title":"List&dictionary imp 3 9","text":"<pre><code>import sys\nimport random\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:3.456299987192324e-05\n</code></pre> <pre><code>sys.setrecursionlimit(2**31 - 1)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range(10**7):\n    l.append(i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:0.7082312540001112\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range(10**5):\n    l.insert(0, i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.2863995140000952\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range((10**5) * 2):\n    l.insert(0, i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:4.889978135000092\n</code></pre> <pre><code>T = TimerError()\nT.start()\nl = []\nfor i in range((10**5) * 3):\n    l.insert(0, i)\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:15.133477557999868\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/list_implementation_3_6/","title":"List implementation 3 6","text":"<pre><code>import sys\nimport random\n\n\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nprint(f\" CWD : {os.getcwd()}\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code> CWD : /home/pk/Desktop/gitmaster/PDSA\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.9004004318267107e-05\n</code></pre> <pre><code>class Node:\n    def __init__(self, v=None):\n        self.value = v\n        self.next = None\n\n    def isempty(self):\n        return self.value is None\n\n    def append(self, value_to_append):\n        if self.isempty():\n            self.value = value_to_append\n        elif self.next is None:\n            self.next = Node(value_to_append)\n        else:\n            self.next.append(value_to_append)\n\n    def insert(self, value_to_insert):\n        new_node = Node(value_to_insert)\n        new_node.next = self.next\n        self.next = new_node\n        self.value, new_node.value = new_node.value, self.value\n\n    def delete(self, value_to_delete):\n        if self.isempty():\n            return\n\n        if self.value == value_to_delete:\n            if self.next is not None:\n                self.value = self.next.value\n                self.next = self.next.next\n            else:\n                self.value = None\n        else:\n            if self.next is not None:\n                self.next.delete(value_to_delete)\n\n    def __str__(self):\n        result = str(self.value)\n        if self.next:\n            result += \" -&gt; \" + str(self.next)\n        return result\n</code></pre> <pre><code>l1 = Node()\nl1.isempty()\n</code></pre> <pre><code>True\n</code></pre> <pre><code>l2 = Node(5)\nl2.isempty()\n</code></pre> <pre><code>False\n</code></pre> <pre><code># Creating a linked list with values 1, 2, 3\nhead = Node(1)\nhead.append(2)\nhead.append(3)\n# Output: 1 -&gt; 2 -&gt; 3\nprint(f\"Initial linked list:{head}\")\n\n# Inserting a new node with value 4 after the first node\nhead.insert(4)\nprint(f\"After inserting 4:{head}\")  # Output: 1 -&gt; 4 -&gt; 2 -&gt; 3\n\n# Deleting the node with value 2\nhead.delete(2)\nprint(f\"After deleting 2:{head}\")  # Output: 1 -&gt; 4 -&gt; 3\n</code></pre> <pre><code>Initial linked list:1 -&gt; 2 -&gt; 3\nAfter inserting 4:4 -&gt; 1 -&gt; 2 -&gt; 3\nAfter deleting 2:4 -&gt; 1 -&gt; 3\n</code></pre>"},{"location":"week3/listsinpython3_7/","title":"Listsinpython3 7","text":"<pre><code>import sys\nimport random\n\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.2912001693621278e-05\n</code></pre> <pre><code>zerolist = [0, 0, 0]\n\nzeromatrix = [zerolist, zerolist, zerolist]\n\nzeromatrix[1][1] = 1\nprint(zeromatrix)\n</code></pre> <pre><code>[[0, 1, 0], [0, 1, 0], [0, 1, 0]]\n</code></pre> <pre><code>zerolist = [0, 0, 0]\n\nzeromatrix = [zerolist, zerolist.copy(), zerolist]\n\nzeromatrix[1][1] = 1\n\nzeromatrix[0][1] = 2\n\nprint(zeromatrix)\n</code></pre> <pre><code>[[0, 2, 0], [0, 1, 0], [0, 2, 0]]\n</code></pre> <pre><code>import numpy as np\n\nzeromatrix = np.zeros((3, 3))\n\nzeromatrix\n</code></pre> <pre><code>array([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n</code></pre> <pre><code>np.arange(5)\n</code></pre> <pre><code>array([0, 1, 2, 3, 4])\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/quick_sort_3_1/","title":"Quick sort 3 1","text":"<pre><code>import sys\nfrom loguru import logger\nimport random\nimport time\n\nlogger.remove()\nlogger.add(\n    sys.stdout, colorize=True, format=\"&lt;level&gt;{level}&lt;/level&gt; | &lt;blue&gt;{message}&lt;/blue&gt;\"\n)\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlogger.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[1mINFO[0m | [34mtime taken:2.2756998077966273e-05[0m\n</code></pre> <p>Merge needs to create a new list to hold the merged elements - No obvious way to efficiently merge two lists in place - Extra storage can be costly Inherently recursive - Recursive calls and returns are expensive</p>"},{"location":"week3/quick_sort_3_1/#quick-sorting","title":"quick sorting","text":"<ol> <li>select the median </li> <li>recursively sort the left and right   </li> </ol> <p>how to find the median ?</p> <p>choose a pivot element </p> <ul> <li>[C.A.R Hoare]</li> </ul> <pre><code>def quicksort(L: list, lower_index: int, upper_index: int):\n    \"\"\"\n    Sorts a list using the Quicksort algorithm.\n\n    Parameters:\n        L (list): The list to be sorted.\n        lower_index (int): The lower index of the sublist to be sorted (default is 0).\n        upper_index (int): The upper index of the sublist to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    if upper_index - lower_index &lt;= 1:\n        return L\n\n    pivot = L[lower_index]\n    lower = lower_index + 1\n    upper = lower_index + 1\n\n    for i in range(lower_index + 1, upper_index):\n        if L[i] &gt; pivot:\n            L[i], L[upper] = L[upper], L[i]\n            upper += 1\n        else:\n            L[i], L[lower] = L[lower], L[i]\n            lower += 1\n\n    # Move pivot between lower and upper\n    L[lower - 1], L[lower_index] = L[lower_index], L[lower - 1]\n\n    # Recursive calls\n    quicksort(L, lower_index=lower_index, upper_index=lower - 1)\n    quicksort(L, lower_index=lower, upper_index=upper_index)\n\n    return L\n</code></pre> <p></p> <pre><code>L = [random.randint(1, 100) for i in range(100000)]\nV = random.randint(1, 100)\n</code></pre> <pre><code>T = TimerError()\nT.start()\nquicksort(L, 0, len(L))\nend_time = T.elapsed()\nlogger.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[1mINFO[0m | [34mtime taken:0.6071723460045177[0m\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week3/quicksort_anaylsis_3.2/","title":"Quicksort anaylsis 3.2","text":"<pre><code>import sys\nfrom loguru import logger\nimport random\nimport time\n\nlogger.remove()\nlogger.add(\n    sys.stdout, colorize=True, format=\"&lt;level&gt;{level}&lt;/level&gt; | &lt;blue&gt;{message}&lt;/blue&gt;\"\n)\n\n\nclass TimerError(Exception):\n    def __init__(self) -&gt; None:\n        self._start_time = None\n        self._stop_time = None\n        self.elapsed_time = None\n\n    def start(self):\n        if self._start_time != None:\n            raise TimerError(\" please stop the timer\")\n        self._start_time = time.perf_counter()\n        self._stop_time = None\n\n    def stop(self):\n        if self._start_time == None:\n            raise TimerError(\"please start the timer\")\n        self._stop_time = time.perf_counter()\n        self.elapsed_time = self._stop_time - self._start_time\n        self._start_time = None\n\n    def elapsed(self):\n        if self.elapsed == None and self._start_time == None:\n            raise TimerError(\"the counter not running\")\n        else:\n            self.stop()\n            return self.elapsed_time\n\n    def __str__(self) -&gt; str:\n        return str(self.elapsed_time)\n\n\nT = TimerError()\nT.start()\nend_time = T.elapsed()\nlogger.info(f\"time taken:{end_time}\")\n</code></pre> <pre><code>[1mINFO[0m | [34mtime taken:1.97930057765916e-05[0m\n</code></pre>"},{"location":"week3/quicksort_anaylsis_3.2/#choose-the-pivot-element-randomly","title":"choose the pivot element - randomly","text":"<ul> <li>uniformly disturbed between 0 to (n-1) where n is the number of elements </li> </ul>"},{"location":"week4/BFS_4_3/","title":"BFS 4 3","text":"<pre><code>import os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.6460999177070335e-05\n</code></pre> <pre><code>class Queue:\n    def __init__(self):\n        \"\"\"\n        Initializes an empty queue.\n        The queue is represented as a list.\n        \"\"\"\n        self.queue = []\n\n    def addq(self, v):\n        \"\"\"\n        Adds an element 'v' to the end of the queue.\n\n        Parameters:\n        v: The element to be added to the queue.\n        \"\"\"\n        self.queue.append(v)\n\n    def delq(self):\n        \"\"\"\n        Removes and returns the element at the front of the queue.\n\n        Returns:\n        The element at the front of the queue if the queue is not empty,\n        otherwise None.\n        \"\"\"\n        v = None\n        if not self.isempty():\n            v = self.queue[0]  # Get the first element in the queue\n            self.queue = self.queue[1:]  # Remove the first element by slicing\n        return v\n\n    def isempty(self):\n        \"\"\"\n        Checks if the queue is empty.\n\n        Returns:\n        True if the queue is empty, otherwise False.\n        \"\"\"\n        return self.queue == []\n\n    def __str__(self):\n        \"\"\"\n        Returns a string representation of the queue.\n\n        Returns:\n        A string representation of the queue list.\n        \"\"\"\n        return str(self.queue)\n\n\n# Example usage\nq = Queue()\nq.addq(1)\nq.addq(2)\nq.addq(3)\nprint(q)  # Output: [1, 2, 3]\nprint(q.delq())  # Output: 1\nprint(q)  # Output: [2, 3]\nprint(q.isempty())  # Output: False\nq.delq()\nq.delq()\nprint(q.isempty())  # Output: True\nprint(q.delq())  # Output: None\n</code></pre> <pre><code>[1, 2, 3]\n1\n[2, 3]\nFalse\nTrue\nNone\n</code></pre> <pre><code>q = Queue()\nfor i in range(3):\n    q.addq(i)\nprint(q)\nprint(q.isempty())\nfor j in range(3):\n    print(q.delq(), q)\nprint(q.isempty())\n</code></pre> <pre><code>[0, 1, 2]\nFalse\n0 [1, 2]\n1 [2]\n2 []\nTrue\n</code></pre> <pre><code>def BFS(AMat, v):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    v: int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited: dict\n        A dictionary where keys are the vertices and values are booleans indicating\n        whether the vertex has been visited (True) or not (False).\n    \"\"\"\n\n    # Get the number of rows (and columns) in the adjacency matrix\n    (rows, cols) = AMat.shape\n\n    # Initialize a dictionary to keep track of visited vertices\n    visited = {}\n    for i in range(rows):\n        visited[i] = False\n\n    # Initialize the queue for BFS\n    q = Queue()\n\n    # Mark the starting vertex as visited and enqueue it\n    visited[v] = True\n    q.addq(v)\n\n    # Perform BFS\n    while not q.isempty():\n        # Dequeue a vertex from the queue\n        j = q.delq()\n\n        # Get all the neighbors of the dequeued vertex j\n        for k in neighbours(AMat, j):\n            # If the neighbor has not been visited, mark it as visited and enqueue it\n            if not visited[k]:\n                visited[k] = True\n                q.addq(k)\n\n    # Return the dictionary of visited vertices\n    return visited\n\n\n# Define the neighbours function\ndef neighbours(AMat, j):\n    \"\"\"\n    Finds the neighbors of a given vertex in a graph represented by an adjacency matrix.\n\n    Parameters:\n    AMat: 2D numpy array\n        The adjacency matrix representing the graph.\n    j: int\n        The vertex for which to find the neighbors.\n\n    Returns:\n    list:\n        A list of neighbors of vertex j.\n    \"\"\"\n    neighbors = []\n    for i in range(AMat.shape[1]):\n        if AMat[j, i] == 1:  # Assuming 1 indicates an edge/connection\n            neighbors.append(i)\n    return neighbors\n\n\nimport numpy as np\n\n# Example adjacency matrix\nAMat = np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]])\n\n# Starting vertex\nv = 0\n\n# Perform BFS\nvisited = BFS(AMat, v)\nprint(visited)  # Output will show which vertices were visited\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True}\n</code></pre> <pre><code>AMat = np.array(\n    [\n        [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 1, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0, 1, 0, 0, 0, 1],\n        [0, 0, 0, 1, 1, 0, 0, 1, 0, 0],\n        [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    ]\n)\n</code></pre> <pre><code># Starting vertex\nv = 0\n\n# Perform BFS\nvisited = BFS(AMat, v)\nprint(visited)\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\n</code></pre> <pre><code>def BFSListPath(AList, v):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented by an adjacency list.\n\n    Parameters:\n    AList: dict\n        The adjacency list representing the graph, where keys are vertices and values are lists of adjacent vertices.\n    v: int\n        The starting vertex for the BFS.\n\n    Returns:\n    visited: dict\n        A dictionary where keys are vertices and values are booleans indicating whether the vertex has been visited.\n    parent: dict\n        A dictionary where keys are vertices and values are the parent of that vertex in the BFS tree.\n    \"\"\"\n\n    # Initialize the visited dictionary and parent dictionary\n    visited, parent = {}, {}\n    for i in AList.keys():\n        visited[i] = False\n        parent[i] = -1\n\n    # Initialize the queue for BFS\n    q = Queue()\n\n    # Mark the starting vertex as visited and enqueue it\n    visited[v] = True\n    q.addq(v)\n\n    # Perform BFS\n    while not q.isempty():\n        # Dequeue a vertex from the queue\n        j = q.delq()\n\n        # Get all the neighbors of the dequeued vertex j\n        for k in AList[j]:\n            # If the neighbor has not been visited, mark it as visited and set its parent\n            if not visited[k]:\n                visited[k] = True\n                parent[k] = j\n                q.addq(k)\n\n    # Return the visited dictionary and the parent dictionary\n    return visited, parent\n\n\n# Example usage\nAList = {\n    0: [1, 2],\n    1: [0, 3],\n    2: [0, 4],\n    3: [1, 5, 6],\n    4: [2, 5, 9],\n    5: [3, 4, 7],\n    6: [3],\n    7: [5, 8],\n    8: [7],\n    9: [4],\n}\n\n# Starting vertex\nv = 0\n\n# Perform BFS\nvisited, parent = BFSListPath(AList, v)\nprint(\"Visited:\", visited)\nprint(\"Parent:\", parent)\n</code></pre> <pre><code>Visited: {0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\nParent: {0: -1, 1: 0, 2: 0, 3: 1, 4: 2, 5: 3, 6: 3, 7: 5, 8: 7, 9: 4}\n</code></pre> <pre><code>def BFSListPathLevel(AList, v):\n    \"\"\"\n    Performs Breadth-First Search (BFS) on a graph represented as an adjacency list,\n    starting from vertex `v`. Computes the level (distance from the start vertex)\n    and parent (preceding vertex in the BFS tree) for each vertex in the graph.\n\n    Parameters:\n    AList (dict): Adjacency list representation of the graph.\n                  Keys are vertices, values are lists of adjacent vertices.\n    v (int): The starting vertex for BFS.\n\n    Returns:\n    tuple: A tuple containing two dictionaries:\n           - level (dict): Maps each vertex to its level (distance from `v`).\n           - parent (dict): Maps each vertex to its parent in the BFS tree.\n                            The parent of the starting vertex `v` is set to -1.\n\n    Example usage:\n    AList = {\n        0: [1, 2],\n        1: [0, 3, 4],\n        2: [0, 5],\n        3: [1],\n        4: [1],\n        5: [2]\n    }\n    level, parent = BFSListPathLevel(AList, 0)\n    print(\"Levels:\", level)\n    print(\"Parents:\", parent)\n    \"\"\"\n\n    level = {}\n    parent = {}\n\n    # Initialize level and parent for each node\n    for i in AList.keys():\n        level[i] = -1\n        parent[i] = -1\n\n    # Create a queue and enqueue the starting vertex\n    q = Queue()\n    level[v] = 0\n    q.addq(v)\n\n    # BFS algorithm\n    while not q.isempty():\n        j = q.delq()\n        for k in AList[j]:\n            if level[k] == -1:  # If k is not visited\n                level[k] = level[j] + 1\n                parent[k] = j\n                q.addq(k)\n\n    return level, parent\n\n\n# Example usage\nAList = {0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2]}\n\nlevel, parent = BFSListPathLevel(AList, 0)\nprint(\"Levels:\", level)\nprint(\"Parents:\", parent)\n</code></pre> <pre><code>Levels: {0: 0, 1: 1, 2: 1, 3: 2, 4: 2, 5: 2}\nParents: {0: -1, 1: 0, 2: 0, 3: 1, 4: 1, 5: 2}\n</code></pre>"},{"location":"week4/DFS_4_4/","title":"DFS 4 4","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.3529000170819927e-05\n</code></pre> <pre><code>def DFSInitList(AList):\n    \"\"\"\n    Initializes the visited and parent dictionaries for each node in the graph.\n\n    Parameters:\n        AList (dict): The adjacency list representation of the graph.\n\n    Returns:\n        tuple: A tuple containing two dictionaries:\n               - visited: A dictionary to track visited nodes, initialized to False.\n               - parent: A dictionary to track parent nodes, initialized to -1.\n    \"\"\"\n    visited = {}\n    parent = {}\n    for i in AList.keys():\n        visited[i] = False\n        parent[i] = -1\n    return (visited, parent)\n\n\ndef DFSList(AList, visited, parent, v):\n    \"\"\"\n    Performs Depth-First Search (DFS) traversal recursively starting from node v.\n\n    Parameters:\n        AList (dict): The adjacency list representation of the graph.\n        visited (dict): A dictionary to track visited nodes.\n        parent (dict): A dictionary to track parent nodes.\n        v (hashable): The current node being visited.\n\n    Returns:\n        tuple: A tuple containing two dictionaries:\n               - visited: Updated dictionary with visited nodes.\n               - parent: Updated dictionary with parent nodes.\n    \"\"\"\n    visited[v] = True\n    for k in AList[v]:\n        if not visited[k]:\n            parent[k] = v\n            DFSList(AList, visited, parent, k)\n    return (visited, parent)\n\n\ndef DFSGlobal(AList, k):\n    \"\"\"\n    Initializes DFS and starts DFS traversal from node k in the graph.\n\n    Parameters:\n        AList (dict): The adjacency list representation of the graph.\n        k (hashable): The starting node for DFS traversal.\n\n    Returns:\n        tuple: A tuple containing two dictionaries:\n               - visited: Dictionary with visited nodes after DFS traversal.\n               - parent: Dictionary with parent nodes after DFS traversal.\n    \"\"\"\n    (visited, parent) = DFSInitList(AList)\n    (visited, parent) = DFSList(AList, visited, parent, k)\n    return (visited, parent)\n\n\n# Example usage:\nAList = {\n    \"A\": [\"B\", \"C\"],\n    \"B\": [\"A\", \"D\", \"E\"],\n    \"C\": [\"A\", \"F\"],\n    \"D\": [\"B\"],\n    \"E\": [\"B\", \"F\"],\n    \"F\": [\"C\", \"E\"],\n}\n\n# Starting node\nstart_node = \"A\"\nvisited, parent = DFSGlobal(AList, start_node)\nprint(\"Visited nodes:\", visited)\nprint(\"Parent nodes:\", parent)\n</code></pre> <pre><code>Visited nodes: {'A': True, 'B': True, 'C': True, 'D': True, 'E': True, 'F': True}\nParent nodes: {'A': -1, 'B': 'A', 'C': 'F', 'D': 'B', 'E': 'B', 'F': 'E'}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/","title":"Lecture 4.1 - Introduction to graphs_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#lecture-41-introduction-to-graphs_pdf-pdf-file","title":"Lecture 4.1 - Introduction to graphs_.pdf (PDF file)","text":"<p>Summary Graphs</p> <p>Graphs are used to visually represent relationships between entities. Entities are represented as vertices (nodes), and relationships are represented as edges. Graphs can be directed (edges have a specific direction) or undirected (edges do not have a specific direction).</p> <p>Paths and Reachability</p> <p>A path is a sequence of connected edges. Reachability determines if there is a path from one vertex to another.</p> <p>Graph Applications</p> <p>Graphs have numerous practical applications, including:</p> <ul> <li>Map Colouring: Determining the minimum number of colors needed to colour a map so that adjacent areas have different colors.</li> <li>Graph Colouring: Assigning colors to vertices such that adjacent vertices have different colors.</li> <li>Vertex Cover: Finding the minimum set of vertices that cover all edges.</li> <li>Independent Set: Identifying a set of vertices where no two vertices are connected by an edge.</li> <li>Matching: Finding a set of non-overlapping edges that connect pairs of vertices.</li> </ul> <p>Concept Overview</p> <ul> <li>Graphs represent relationships between entities.</li> <li>Directed graphs have edges with specific directions, while undirected graphs do not.</li> <li>Reachability is used to determine if one vertex can reach another through a path.</li> <li>Graph applications include map colouring, graph colouring, vertex cover, independent set, and matching. Lec file</li> </ul>"},{"location":"week4/Lecture%204.1%20-%20Introduction%20to%20graphs_/#lecture-41-introduction-to-graphs_pdf-pdf-file_1","title":"Lecture 4.1 - Introduction to graphs_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.2%20-%20Representing%20Graphs_/","title":"Lecture 4.2 - Representing Graphs_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.2%20-%20Representing%20Graphs_/#lecture-42-representing-graphs_pdf-pdf-file","title":"Lecture 4.2 - Representing Graphs_.pdf (PDF file)","text":"<p>Summary Graph Representation</p> <ul> <li>Graphs represent relationships between objects (vertices) and connections between them (edges).</li> <li>The adjacency matrix method represents graphs using a table where each row and column corresponds to a vertex.</li> <li>The adjacency list method stores vertices in a list, with each vertex having a list of its edges to other vertices.</li> </ul> <p>Representing Graphs for Computing</p> <ul> <li>Adjacency lists are more space-efficient than adjacency matrices.</li> <li>Adjacency lists are more efficient for determining whether one vertex is a neighbor of another.</li> <li>Adjacency matrices are more efficient for identifying all the neighbors of a vertex.</li> </ul> <p>Checking Reachability</p> <ul> <li>To check if one vertex is reachable from another, we can:<ul> <li>Mark the target vertex as reachable.</li> <li>Mark all neighbors of reachable vertices as reachable.</li> <li>Repeat until the target vertex is marked or the entire graph has been explored.</li> </ul> </li> </ul> <p>Breadth-First Search vs. Depth-First Search</p> <ul> <li>Breadth-first search explores all vertices at a given depth before moving on to the next depth.</li> <li>Depth-first search explores a single path as far as possible before backtracking and trying another path. Lec file</li> </ul>"},{"location":"week4/Lecture%204.2%20-%20Representing%20Graphs_/#lecture-42-representing-graphs_pdf-pdf-file_1","title":"Lecture 4.2 - Representing Graphs_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_/","title":"Lecture 4.3 - Breadth First Search (BFS)_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_/#lecture-43-breadth-first-search-bfs_pdf-pdf-file","title":"Lecture 4.3 - Breadth First Search (BFS)_.pdf (PDF file)","text":"<p>Summary Summary of Breadth First Search (BFS):</p> <p>BFS is a systematic technique for exploring a graph level by level. It involves: - Marking visited vertices - Maintaining a queue of explored but unvisited vertices - Complexity: O(n\u00b2) using an adjacency matrix or O(m + n) using an adjacency list</p> <p>Enhancing BFS: - Maintain parent information to recover the path to reachable vertices. - Record distance (levels) to identify the shortest path in terms of edge count.</p> <p>Generalizations: - Edges can have weights (costs). - In weighted graphs, shortest paths are determined by cost, not edge count. Lec file</p>"},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_/#lecture-43-breadth-first-search-bfs_pdf-pdf-file_1","title":"Lecture 4.3 - Breadth First Search (BFS)_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_T/","title":"Lecture 4.3 - Breadth First Search (BFS)_T.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_T/#lecture-43-breadth-first-search-bfs_tpdf-pdf-file","title":"Lecture 4.3 - Breadth First Search (BFS)_T.pdf (PDF file)","text":"<p>Summary Breadth First Search (BFS) is a systematic strategy for exploring a graph. It involves marking which vertices have been visited and using a queue to keep track of which have yet to be explored.</p> <p>Using an adjacency matrix requires n^2 time, regardless of edges. To optimize, adjacency lists are used, resulting in m+n time, where m is the number of edges and n is the number of vertices.</p> <p>BFS can be extended to maintain parent information for path recovery and level information for recording shortest path length. However, shortest path in terms of edges may not always indicate the shortest path in distance. Lec file</p>"},{"location":"week4/Lecture%204.3%20-%20Breadth%20First%20Search%20%28BFS%29_T/#lecture-43-breadth-first-search-bfs_tpdf-pdf-file_1","title":"Lecture 4.3 - Breadth First Search (BFS)_T.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/","title":"Lecture 4.4 - Depth First Search (DFS)_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#lecture-44-depth-first-search-dfs_pdf-pdf-file","title":"Lecture 4.4 - Depth First Search (DFS)_.pdf (PDF file)","text":"<p>Summary Depth First Search (DFS) is a technique in graph theory to explore graphs systematically. In DFS, we start from a vertex, visit an unexplored neighbor, and continue exploring its neighbors until all neighbors are visited. If there are still unexplored neighbors, we backtrack to the nearest suspended vertex that still has an unexplored neighbor.</p> <p>DFS is often implemented using a stack. This is because we need to keep track of the vertices we have visited but not yet fully explored. As we visit a vertex, we push it onto the stack. When we have explored all of its neighbors, we pop it from the stack.</p> <p>The complexity of DFS is O(n^2) using an adjacency matrix and O(m + n) using an adjacency list, where n is the number of vertices and m is the number of edges. Lec file</p>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_/#lecture-44-depth-first-search-dfs_pdf-pdf-file_1","title":"Lecture 4.4 - Depth First Search (DFS)_.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_T/","title":"Lecture 4.4 - Depth First Search (DFS)_T.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_T/#lecture-44-depth-first-search-dfs_tpdf-pdf-file","title":"Lecture 4.4 - Depth First Search (DFS)_T.pdf (PDF file)","text":"<p>Summary Depth First Search (DFS) is an alternative search strategy to BFS, using a stack instead of a queue. In DFS, we start from a vertex, explore an unexplored neighbor, then explore that neighbor's unexplored neighbors, and so on, following a path until we reach a vertex with no unexplored neighbors. We then backtrack, systematically revisiting previous vertices to explore any unexplored neighbors they may have.</p> <p>Unlike BFS, where we explore all neighbors of the first level, then all neighbors of the second level, DFS explores paths in a depth-first manner. This allows us to explore more deeply into the graph, but also means we may not find the shortest path to a destination.</p> <p>In order to keep track of which vertices have been visited and which vertex led to their discovery (parent), DFS uses a stack, implemented either explicitly or implicitly through recursion. When using recursion, visited and parent are global variables, which DFS updates as it explores.</p> <p>In terms of complexity, DFS has a time complexity similar to BFS. Exploring each vertex requires linear time, as does checking for unexplored neighbors. Thus, with an adjacency matrix, the worst-case complexity is O(n^2), and with an adjacency list, it is O(m + n).</p> <p>While DFS does not provide information about shortest paths like BFS, it is often more informative about the graph structure, making it a valuable tool for exploring graphs and understanding their connectivity. Lec file</p>"},{"location":"week4/Lecture%204.4%20-%20Depth%20First%20Search%20%28DFS%29_T/#lecture-44-depth-first-search-dfs_tpdf-pdf-file_1","title":"Lecture 4.4 - Depth First Search (DFS)_T.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/","title":"Lecture 4.5 - Applications of BFS and DFS.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#lecture-45-applications-of-bfs-and-dfspdf-pdf-file","title":"Lecture 4.5 - Applications of BFS and DFS.pdf (PDF file)","text":"<p>Summary BFS and DFS are graph traversal algorithms that provide insights into a graph's structure and connectivity. Here's a summary of their applications: </p> <ol> <li>Connectivity: </li> <li>BFS can identify connected components in an undirected graph, which are maximal sets of vertices that can reach each other. </li> <li> <p>DFS numbering can help determine if a directed graph is strongly connected, meaning there is a path between every pair of vertices in both directions. </p> </li> <li> <p>Cycles: </p> </li> <li> <p>Non-tree edges in a BFS or DFS tree indicate the presence of cycles in a graph. In a directed graph, only back edges (edges from a vertex to an ancestor in the DFS tree) create cycles. </p> </li> <li> <p>Strongly Connected Components (SCCs): </p> </li> <li> <p>DFS numbering can be used to decompose directed graphs into SCCs, where each component consists of vertices that are strongly connected to each other. </p> </li> <li> <p>Acyclic Graphs: </p> </li> <li>Directed acyclic graphs (DAGs) have no cycles and are useful for representing dependencies. </li> <li> <p>Topological sorting, which finds a valid order for completing tasks with dependencies, can be performed using DFS on DAGs. </p> </li> <li> <p>Other Features: </p> </li> <li> <p>DFS can also identify articulation points (vertices whose removal would disconnect the graph) and bridges (edges whose removal would disconnect the graph). </p> </li> <li> <p>Course Scheduling: </p> </li> <li>Given a set of courses with prerequisites, DFS can be used to find a valid sequence for completing the courses without violating any prerequisites. Lec file</li> </ol>"},{"location":"week4/Lecture%204.5%20-%20Applications%20of%20BFS%20and%20DFS/#lecture-45-applications-of-bfs-and-dfspdf-pdf-file_1","title":"Lecture 4.5 - Applications of BFS and DFS.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/","title":"Lecture 4.6 - Introduction to Directed Acyclic Graph (DAG).pdf (PDF file)","text":""},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#lecture-46-introduction-to-directed-acyclic-graph-dagpdf-pdf-file","title":"Lecture 4.6 - Introduction to Directed Acyclic Graph (DAG).pdf (PDF file)","text":"<p>Summary Directed Acyclic Graphs (DAGs) are graphical representations of tasks with dependencies. They are used to organize and schedule tasks, ensuring that tasks that must be completed before others are done first.</p> <p>DAGs consist of vertices (tasks) and edges (dependencies). An arrow from vertex A to vertex B indicates that task A must be completed before task B can begin.</p> <p>Typical questions addressed using DAGs include scheduling tasks while respecting dependencies and estimating the time required to complete all tasks.</p> <p>In a DAG, topological sorting finds a valid ordering of tasks, and finding the longest path determines the longest sequence of dependent tasks, providing an estimate of the time required to complete the project. Lec file</p>"},{"location":"week4/Lecture%204.6%20-%20Introduction%20to%20Directed%20Acyclic%20Graph%20%28DAG%29/#lecture-46-introduction-to-directed-acyclic-graph-dagpdf-pdf-file_1","title":"Lecture 4.6 - Introduction to Directed Acyclic Graph (DAG).pdf (PDF file)","text":""},{"location":"week4/Lecture%204.7%20-%20Topological%20Sorting/","title":"Lecture 4.7 - Topological Sorting.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.7%20-%20Topological%20Sorting/#lecture-47-topological-sortingpdf-pdf-file","title":"Lecture 4.7 - Topological Sorting.pdf (PDF file)","text":"<p>Summary Topological sorting is a technique used to organize a set of tasks or activities with dependencies into a sequence that respects those dependencies. It is particularly useful in situations where tasks must be completed in a specific order to avoid conflicts or errors.</p> <p>Key concepts in topological sorting include:</p> <ol> <li> <p>Directed Acyclic Graphs (DAGs): Topological sorting is applicable to directed acyclic graphs (DAGs), which are graphs that contain no cycles, meaning there is no path from any vertex back to itself.</p> </li> <li> <p>Indegree: Indegree refers to the number of incoming edges into a vertex in a directed graph.</p> </li> <li> <p>Topological Sort: A topological sort is a linear arrangement of vertices in a graph that preserves the dependencies between the vertices.</p> </li> <li> <p>Algorithm: The topological sorting algorithm works by iteratively identifying vertices with an indegree of 0 and removing them from the graph. The removed vertices are placed in the topological order. This process is repeated until all vertices have been listed.</p> </li> <li> <p>Complexity: The complexity of the topological sorting algorithm using an adjacency matrix is O(n^2), where n represents the number of vertices in the graph. However, using an adjacency list, the complexity can be reduced to O(m + n), where m represents the number of edges in the graph. Lec file</p> </li> </ol>"},{"location":"week4/Lecture%204.7%20-%20Topological%20Sorting/#lecture-47-topological-sortingpdf-pdf-file_1","title":"Lecture 4.7 - Topological Sorting.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/","title":"Lecture 4.8 - Longest Path in DAGs.pdf (PDF file)","text":""},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/#lecture-48-longest-path-in-dagspdf-pdf-file","title":"Lecture 4.8 - Longest Path in DAGs.pdf (PDF file)","text":"<p>Summary Directed Acyclic Graphs (DAGs) are graphs without directed cycles. Topological sorting provides a feasible schedule by enumerating vertices from the graph with no incoming edges to vertices with the highest number of incoming edges. The longest path in a DAG can be found by iterating through the vertices in topological order and checking if there is a longer path to each vertex from its incoming neighbors. The longest path problem in general graphs, however, is more difficult, and the best-known strategy involves enumerating all possible paths. Lec file</p>"},{"location":"week4/Lecture%204.8%20-%20Longest%20Path%20in%20DAGs/#lecture-48-longest-path-in-dagspdf-pdf-file_1","title":"Lecture 4.8 - Longest Path in DAGs.pdf (PDF file)","text":""},{"location":"week4/longest_path4_8/","title":"Longest path4 8","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.27989999075362e-05\n</code></pre> <pre><code>from queue import Queue\n\n\ndef longestpathlist(AList):\n    \"\"\"\n    Computes the longest path in a directed acyclic graph (DAG) using an adjacency list.\n\n    Parameters:\n    AList (dict): Adjacency list representing the graph, where keys are nodes and values are lists of adjacent nodes.\n\n    Returns:\n    dict: A dictionary where keys are nodes and values are the lengths of the longest paths ending at those nodes.\n    \"\"\"\n\n    # Initialize indegree and longest path length dictionaries\n    indegree = {}\n    lpath = {}\n    for u in AList.keys():\n        indegree[u] = 0\n        lpath[u] = 0\n\n    # Compute indegree for each node\n    for u in AList.keys():\n        for v in AList[u]:\n            indegree[v] += 1\n\n    # Initialize the zero degree queue\n    zerodegreeq = Queue()\n    for u in AList.keys():\n        if indegree[u] == 0:\n            zerodegreeq.put(u)\n\n    # Process nodes with zero indegree\n    while not zerodegreeq.empty():\n        j = zerodegreeq.get()\n\n        for k in AList[j]:\n            indegree[k] -= 1\n            lpath[k] = max(lpath[k], lpath[j] + 1)\n            if indegree[k] == 0:\n                zerodegreeq.put(k)\n\n    return lpath\n\n\n# Example usage:\nAList = {\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}\n\n# Prints the longest path lengths from each node\nprint(longestpathlist(AList))\n</code></pre> <pre><code>{'A': 0, 'B': 1, 'C': 1, 'D': 2, 'E': 3}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/pending/","title":"Pending","text":"<ul> <li>[X] 4.1</li> <li>[X] 4.2</li> <li>[X] 4.3</li> <li>[X] 4.4</li> <li>[X] 4.5</li> <li>[X] 4.6</li> <li>[X] 4.7</li> <li>[X] 4.8</li> </ul>"},{"location":"week4/redo/","title":"Redo","text":"<pre><code>import numpy as np \nimport os \nfrom IPython.display import display, Markdown, Image\n\nos.chdir(\"..\")\nos.chdir(\"..\")\n\nfrom driver_folder.shared.graph import plot_graph_from_adj_list\n</code></pre>"},{"location":"week4/redo/#queue","title":"Queue","text":"<pre><code>class Queue:\n    def __init__(self):\n        self.queue = []\n\n    def addq(self , value_to_add):\n        self.queue.append(value_to_add)\n\n    def delq(self):\n        v = None \n        if not self.is_empty(): \n            v = self.queue.pop(0)\n        return v\n\n    def is_empty(self):\n        return self.queue == []\n\n    def __str__(self):\n        return str(self.queue)\n</code></pre> <pre><code>q = Queue()\nfor i in range(3):\n    q.addq(i)\nprint(q)\nprint(q.is_empty())\nfor j in range(3):\n    print(q.delq(),q)\nprint(q.is_empty())\n</code></pre> <pre><code>[0, 1, 2]\nFalse\n0 [1, 2]\n1 [2]\n2 []\nTrue\n</code></pre> <pre><code>AMat = np.array([\n    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 1, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 1, 1, 0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]\n])\n</code></pre> <pre><code>fig = plot_graph_from_adj_list(adj_list=AMat)\n</code></pre> <pre><code># Save the graph as an image\nfig.write_image(\"graph_image.png\")\n\n# Display the plot\ndisplay(Image(filename=\"graph_image.png\"))\n</code></pre>"},{"location":"week4/redo/#bfs-using-adjacency-matrix","title":"BFS using Adjacency Matrix","text":"<pre><code>def neighbours(AMat , j):\n    neighbour = []\n    for col in range(AMat.shape[1]):\n        if AMat[j,col] ==1:\n            neighbour.append(col)\n    return neighbour    \n</code></pre> <pre><code>def BFS( AMat : np.array , V : int ):\n\n\n    rows , cols = AMat.shape \n\n    visited = {}\n\n    for node in range(rows):\n        visited[node] = False\n\n    queue= Queue()\n    visited[V] = True \n\n    queue.addq(V)\n\n    while not queue.is_empty():\n        j = queue.delq()\n        for N in neighbours(AMat=AMat, j = j):\n            if not visited[N]:\n                queue.addq(N)\n                visited[N] = True \n    return visited\n</code></pre> <pre><code>start_vertex = 0\nvisited = BFS(AMat, start_vertex)\nprint(visited)\n</code></pre> <pre><code>{0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\n</code></pre>"},{"location":"week4/redo/#bfs-using-adjacency-list","title":"BFS using Adjacency list","text":"<pre><code>def adj_matrix_to_list(AMat):\n    Alist = {}\n    rows, cols = AMat.shape\n    for i in range(rows):\n        Alist[i] = []\n        for j in range(cols):\n            if AMat[i, j] == 1:\n                Alist[i].append(j)\n    return Alist\n</code></pre> <pre><code>AList = adj_matrix_to_list(AMat=AMat)\n</code></pre> <pre><code>def BFSListPath(Alist : dict , start_vertex : int ):\n\n    visited , parent = {} , {}\n\n    for row in Alist.keys():\n        visited[row] = False\n        parent[row] = -1 \n    queue = Queue()\n    visited[start_vertex] = True \n    queue.addq(start_vertex)\n\n    while not queue.is_empty():\n        parent_node = queue.delq()\n        for child in Alist[parent_node]:\n            if not visited[child]:\n                queue.addq(child)\n                visited[child] = True \n                parent[child] = parent_node\n    return visited, parent  \n</code></pre> <pre><code># Starting vertex\nv = 0\n\n# Perform BFS\nvisited, parent = BFSListPath(AList, v)\nprint(\"Visited:\", visited)\nprint(\"Parent:\", parent)\n</code></pre> <pre><code>Visited: {0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\nParent: {0: -1, 1: 0, 2: 0, 3: 1, 4: 2, 5: 3, 6: 3, 7: 5, 8: 7, 9: 4}\n</code></pre>"},{"location":"week4/redo/#dfs-using-global-parent-visited","title":"DFS using Global Parent &amp; Visited","text":"<pre><code>PARENT , VISITED = {} , {}\n\ndef DFS_Init_Global(AMat):\n\n    rows , cols = AMat.shape\n\n    for node in range(rows):\n        PARENT[node] = -1 \n        VISITED[node] = False\n\ndef DFS_Global(AMat, V):\n    VISITED[V] = True \n    for child in neighbours(AMat=AMat, j=V):\n        if not VISITED[child]:\n            PARENT[child] = V\n            DFS_Global(AMat=AMat,V=child)\n    return\n</code></pre> <pre><code># Starting node\nstart_node = 0\nDFS_Init_Global(AMat=AMat)\nDFS_Global(AMat=AMat, V= start_node)\nprint(\"Visited nodes:\", VISITED)\nprint(\"Parent nodes:\", PARENT)\n</code></pre> <pre><code>Visited nodes: {0: True, 1: True, 2: True, 3: True, 4: True, 5: True, 6: True, 7: True, 8: True, 9: True}\nParent nodes: {0: -1, 1: 0, 2: 4, 3: 1, 4: 5, 5: 3, 6: 3, 7: 5, 8: 7, 9: 4}\n</code></pre> <pre><code>#Application Of BFS and DFS\n</code></pre> <pre><code>def Components(AList):\n    component = {}\n    for row in AList.keys():\n        component[row] = -1 \n    comp_id , seen = 0,0 \n    while seen &lt;= max(AList.keys()):\n        start_vertex_depth = min([i for i in AList.keys() if component[i] == -1])\n        visited , _ = BFSListPath(AList, start_vertex_depth)\n        for node in visited.keys():\n            if visited[node]:\n                seen += 1\n                component[node] = comp_id\n        comp_id += 1\n\n    return component\n</code></pre> <pre><code>def Components(AList):\n    component = {}\n    for i in AList.keys():\n        component[i] = -1\n    (compid,seen) = (0,0)\n    while seen &lt;= max(AList.keys()):\n        startv = min([i for i in AList.keys()\n                      if component[i] == -1])\n        visited , _ = BFSListPath(AList,startv)\n        for i in visited.keys():\n            if visited[i]:\n                seen = seen + 1\n                component[i] = compid\n        compid = compid + 1\n    return(component)\n</code></pre> <pre><code>Components(AList)\n</code></pre> <pre><code>{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}\n</code></pre> <pre><code>Amat = np.array([\n[0,1,1,0,0,0,0,0,0,0,0],\n    [1,0,1,0,0,0,0,0,0,0,0], \n    [1,1,0,0,0,0,0,0,0,0,0],\n    [0,0,0,0,1,0,0,0,0,0 ,0],\n    [0,0,0,1,0,1,0,0,0,0,0],\n    [0,0,0,0,1,0,1,0,0,0,0],\n    [0,0,0,0,0,1,0,0,0,0,0],\n    [0,0,0,0,0,0,0,0,1,1,1],\n    [0,0,0,0,0,0,0,1,0,0,0],\n    [0,0,0,0,0,0,0,1,0,0,0],\n    [0,0,0,0,0,0,0,1,0,0,0]])\n</code></pre> <pre><code>adj_list = adj_matrix_to_list(Amat)\n</code></pre> <pre><code>fig = plot_graph_from_adj_list(adj_list)\n</code></pre> <pre><code># Save the graph as an image\nfig.write_image(\"graph_image1.png\")\n\n# Display the plot\ndisplay(Image(filename=\"graph_image1.png\"))\n</code></pre> <pre><code>Components(adj_list)\n</code></pre> <pre><code>{0: 0, 1: 0, 2: 0, 3: 1, 4: 1, 5: 1, 6: 1, 7: 2, 8: 2, 9: 2, 10: 2}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/represntinggraph4.2/","title":"Represntinggraph4.2","text":"<pre><code>import sys\nimport random\nimport os\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.3933000445831567e-05\n</code></pre> <pre><code>edges = [\n    (0, 1),\n    (0, 4),\n    (1, 2),\n    (2, 0),\n    (3, 4),\n    (3, 6),\n    (4, 0),\n    (4, 3),\n    (4, 7),\n    (5, 3),\n    (5, 7),\n    (6, 5),\n    (7, 4),\n    (7, 8),\n    (8, 5),\n    (8, 9),\n    (9, 8),\n]\n</code></pre> <pre><code>import numpy as np\n</code></pre> <pre><code>A = np.zeros(shape=(10, 10))\n</code></pre> <pre><code>for i, j in edges:\n    A[i, j] = 1\n</code></pre> <pre><code>A\n</code></pre> <pre><code>array([[0., 1., 0., 0., 1., 0., 0., 0., 0., 0.],\n       [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],\n       [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 0., 1., 0., 0., 0.],\n       [1., 0., 0., 1., 0., 0., 0., 1., 0., 0.],\n       [0., 0., 0., 1., 0., 0., 0., 1., 0., 0.],\n       [0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 1., 0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 0., 1., 0., 0., 0., 1.],\n       [0., 0., 0., 0., 0., 0., 0., 0., 1., 0.]])\n</code></pre> <pre><code>def neighbours(AMat, i):\n    nbrs = []\n    (rows, cols) = AMat.shape\n    for j in range(cols):\n        if AMat[i, j] == 1:\n            nbrs.append(j)\n            return nbrs\n</code></pre> <pre><code>neighbours(A, 7)\n</code></pre> <pre><code>[4]\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week4/topologoical_sorting/","title":"Topologoical sorting","text":"<pre><code>import os\nimport numpy as np\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.2519000026477443e-05\n</code></pre> <pre><code>import numpy as np\n\n\ndef toposort(AMat):\n    \"\"\"\n    Performs a topological sort on a directed acyclic graph (DAG) using an adjacency matrix.\n\n    Parameters:\n    AMat (np.ndarray): Adjacency matrix representing the graph, where AMat[i][j] == 1 indicates an edge from node i to node j.\n\n    Returns:\n    list: A list of nodes in topologically sorted order.\n    \"\"\"\n\n    # Get the number of rows and columns from the adjacency matrix\n    rows, cols = AMat.shape\n\n    # Initialize the indegree dictionary and the list to store the topological sort result\n    indegree = {}\n    toposortlist = []\n\n    # Step 1: Initialize all nodes' indegree to 0\n    for c in range(cols):\n        indegree[c] = 0\n\n    # Step 2: Compute indegree for each node\n    for r in range(rows):\n        for c in range(cols):\n            if AMat[r, c] == 1:\n                indegree[c] += 1\n\n    # Step 3: Perform the topological sort\n    for _ in range(cols):\n        # Find a node with zero indegree\n        zero_indegree_nodes = [k for k in range(cols) if indegree[k] == 0]\n        if not zero_indegree_nodes:\n            raise ValueError(\"Graph has at least one cycle\")\n\n        # Select the first node with zero indegree\n        j = zero_indegree_nodes[0]\n        toposortlist.append(j)\n\n        # Set the indegree of this node to -1 to mark it as processed\n        indegree[j] = -1\n\n        # Decrease the indegree of all nodes that this node points to\n        for k in range(cols):\n            if AMat[j, k] == 1:\n                indegree[k] -= 1\n\n    return toposortlist\n\n\n# Example usage:\nAMat = np.array(\n    [\n        [0, 1, 1, 0, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 1, 0],\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0],\n    ]\n)\n\nprint(toposort(AMat))\n</code></pre> <pre><code>[0, 1, 2, 3, 4]\n</code></pre> <pre><code>from queue import Queue\n\n\ndef toposortlist(AList):\n    \"\"\"\n    Performs a topological sort on a directed acyclic graph (DAG) using Kahn's algorithm.\n\n    Parameters:\n    AList (dict): Adjacency list representing the graph, where keys are nodes and values are lists of adjacent nodes.\n\n    Returns:\n    list: A list of nodes in topologically sorted order.\n    \"\"\"\n\n    # Initialize the indegree dictionary and the list to store the topological sort result\n    indegree = {}\n    toposortlist = []\n\n    # Step 1: Initialize all nodes' indegree to 0\n    for u in AList.keys():\n        indegree[u] = 0\n\n    # Step 2: Compute indegree for each node\n    for u in AList.keys():\n        for v in AList[u]:\n            indegree[v] = indegree[v] + 1\n\n    # Step 3: Initialize the queue with nodes having zero indegree\n    zerodegreeq = Queue()\n    for u in AList.keys():\n        if indegree[u] == 0:\n            zerodegreeq.put(u)\n\n    # Step 4: Perform the topological sort\n    while not zerodegreeq.empty():\n        # Dequeue a node with zero indegree\n        j = zerodegreeq.get()\n        # Append it to the topological sort list\n        toposortlist.append(j)\n\n        # Decrease the indegree of all its adjacent nodes\n        for k in AList[j]:\n            indegree[k] = indegree[k] - 1\n            # If the indegree of any adjacent node becomes zero, enqueue it\n            if indegree[k] == 0:\n                zerodegreeq.put(k)\n\n    return toposortlist\n\n\n# Example usage:\nAList = {\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"D\"], \"D\": [\"E\"], \"E\": []}\n\n# Prints the topological sort of the graph\nprint(toposortlist(AList))\n</code></pre> <pre><code>['A', 'B', 'C', 'D', 'E']\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/Lecture%205.1%20-%20Shortest%20Paths%20in%20Weighted%20Graphs_annotated/","title":"Lecture 5.1 - Shortest Paths in Weighted Graphs_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.1%20-%20Shortest%20Paths%20in%20Weighted%20Graphs_annotated/#lecture-51-shortest-paths-in-weighted-graphs_annotatedpdf-pdf-file","title":"Lecture 5.1 - Shortest Paths in Weighted Graphs_annotated.pdf (PDF file)","text":"<p>Summary In weighted graphs, edges have assigned values (costs). Shortest paths in weighted graphs consider the total cost of the path rather than the number of edges. This can lead to different results compared to unweighted graphs.</p> <p>Two common shortest path problems are:</p> <ul> <li>Single Source Shortest Paths: Finding the shortest path from a specified vertex to all other vertices.</li> <li>All Pairs Shortest Paths: Finding the shortest path between every pair of vertices.</li> </ul> <p>Negative edge weights can be meaningful in certain scenarios, such as modeling costs in a taxi system where some roads have negative weights due to earning revenue. However, negative edge weights can also lead to negative cycles, which hinder the definition of shortest paths. Graphs without negative cycles allow for shortest path computations even with negative weights. Lec file</p>"},{"location":"week5/Lecture%205.1%20-%20Shortest%20Paths%20in%20Weighted%20Graphs_annotated/#lecture-51-shortest-paths-in-weighted-graphs_annotatedpdf-pdf-file_1","title":"Lecture 5.1 - Shortest Paths in Weighted Graphs_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.2%20-%20Single%20Source%20Shortest%20Paths%20%28Dijkstra_s%20algorithm%29/","title":"Lecture 5.2 - Single Source Shortest Paths (Dijkstra_s algorithm).pdf (PDF file)","text":""},{"location":"week5/Lecture%205.2%20-%20Single%20Source%20Shortest%20Paths%20%28Dijkstra_s%20algorithm%29/#lecture-52-single-source-shortest-paths-dijkstra_s-algorithmpdf-pdf-file","title":"Lecture 5.2 - Single Source Shortest Paths (Dijkstra_s algorithm).pdf (PDF file)","text":"<p>Summary Dijkstra's algorithm finds the shortest paths from a single source vertex to every other vertex in a weighted graph with non-negative edge weights. Using a greedy approach, it iteratively selects the unvisited vertex with the shortest known distance, recomputes the distance to its neighbors, and updates the shortest distance accordingly. The algorithm's proof of correctness relies on the non-decreasing edge weights, and it has a time complexity of O(n^2), with an improvement to O(n + m) using an adjacency list representation of the graph. However, the bottleneck of identifying the vertex with the minimum distance remains unsolved and requires a more efficient data structure for removal of minimum elements. Lec file</p>"},{"location":"week5/Lecture%205.2%20-%20Single%20Source%20Shortest%20Paths%20%28Dijkstra_s%20algorithm%29/#lecture-52-single-source-shortest-paths-dijkstra_s-algorithmpdf-pdf-file_1","title":"Lecture 5.2 - Single Source Shortest Paths (Dijkstra_s algorithm).pdf (PDF file)","text":""},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/","title":"Lecture 5.3 - Single Source Shortest Paths with Negative Weights (Bellman-Ford Algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#lecture-53-single-source-shortest-paths-with-negative-weights-bellman-ford-algorithm_annotatedpdf-pdf-file","title":"Lecture 5.3 - Single Source Shortest Paths with Negative Weights (Bellman-Ford Algorithm)_annotated.pdf (PDF file)","text":"<p>Summary The Bellman-Ford algorithm is used to find the shortest paths from a single source vertex to all other vertices in a weighted graph that may contain negative edge weights. Unlike Dijkstra's algorithm, which assumes non-negative edge weights, the Bellman-Ford algorithm allows for negative weights.</p> <p>Initially, the distance to all vertices is set to infinity except for the source vertex, which is set to 0. The algorithm then iteratively updates the distance to each vertex by considering all the edges that connect it to its neighbors. After n iterations (where n is the number of vertices in the graph), the algorithm converges and the resulting distance values represent the shortest paths from the source to all other vertices.</p> <p>The Bellman-Ford algorithm takes O(nm) time, where n is the number of vertices in the graph and m is the number of edges. If the graph contains negative cycles, the algorithm will detect them and report that no shortest path exists. Lec file</p>"},{"location":"week5/Lecture%205.3%20-%20Single%20Source%20Shortest%20Paths%20with%20Negative%20Weights%20%28Bellman-Ford%20Algorithm%29_annotated/#lecture-53-single-source-shortest-paths-with-negative-weights-bellman-ford-algorithm_annotatedpdf-pdf-file_1","title":"Lecture 5.3 - Single Source Shortest Paths with Negative Weights (Bellman-Ford Algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.4%20-%20All%20Pairs%20Shortest%20Paths%20%28Floyd-Warshall%20algorithm%29_annotated/","title":"Lecture 5.4 - All Pairs Shortest Paths (Floyd-Warshall algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.4%20-%20All%20Pairs%20Shortest%20Paths%20%28Floyd-Warshall%20algorithm%29_annotated/#lecture-54-all-pairs-shortest-paths-floyd-warshall-algorithm_annotatedpdf-pdf-file","title":"Lecture 5.4 - All Pairs Shortest Paths (Floyd-Warshall algorithm)_annotated.pdf (PDF file)","text":"<p>Summary The Floyd-Warshall algorithm is a method for finding the shortest paths between all pairs of vertices in a weighted graph. It works by iteratively updating a matrix of distances between all pairs of vertices, until the matrix contains the shortest paths. The algorithm has a time complexity of O(n^3), where n is the number of vertices in the graph.</p> <p>An alternative approach is to use Warshall's algorithm, which can be used to compute the transitive closure of a graph. The transitive closure of a graph is a matrix that indicates whether there is a path from every vertex to every other vertex in the graph. Warshall's algorithm has a time complexity of O(n^3), where n is the number of vertices in the graph.</p> <p>The Floyd-Warshall algorithm can be used to solve a variety of problems, such as finding the shortest path between two cities in a road network, or finding the minimum cost of a set of tasks that must be performed in a given order. Lec file</p>"},{"location":"week5/Lecture%205.4%20-%20All%20Pairs%20Shortest%20Paths%20%28Floyd-Warshall%20algorithm%29_annotated/#lecture-54-all-pairs-shortest-paths-floyd-warshall-algorithm_annotatedpdf-pdf-file_1","title":"Lecture 5.4 - All Pairs Shortest Paths (Floyd-Warshall algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/","title":"Lecture 5.5 - Minimum Cost Spanning Trees_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#lecture-55-minimum-cost-spanning-trees_annotatedpdf-pdf-file","title":"Lecture 5.5 - Minimum Cost Spanning Trees_annotated.pdf (PDF file)","text":"<p>Summary Minimum Cost Spanning Trees (MCSTs) are used to connect a set of nodes with the minimum total cost. They have applications in areas such as road construction and network design. A tree is a graph with no cycles, and a spanning tree is a tree that connects all the nodes in a graph. A MCST is a spanning tree with the minimum total edge weight.</p> <p>MCSTs can be constructed using Kruskal's or Prim's algorithm. Kruskal's algorithm sorts the edges in ascending order of weight and adds them to the MCST until all nodes are connected. Prim's algorithm starts with a single node and iteratively adds the lowest-cost edge that connects an existing node to an unconnected node.</p> <p>Some facts about trees that are useful for building MCSTs include: - A tree with n vertices has n-1 edges. - Adding an edge to a tree creates a cycle. - Every pair of vertices in a tree is connected by a unique path. Lec file</p>"},{"location":"week5/Lecture%205.5%20-%20Minimum%20Cost%20Spanning%20Trees_annotated/#lecture-55-minimum-cost-spanning-trees_annotatedpdf-pdf-file_1","title":"Lecture 5.5 - Minimum Cost Spanning Trees_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.6%20-%20Minimum%20Cost%20Spanning%20Trees%20%28Prim_s%20Algorithm%29_annotated/","title":"Lecture 5.6 - Minimum Cost Spanning Trees (Prim_s Algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/Lecture%205.6%20-%20Minimum%20Cost%20Spanning%20Trees%20%28Prim_s%20Algorithm%29_annotated/#lecture-56-minimum-cost-spanning-trees-prim_s-algorithm_annotatedpdf-pdf-file","title":"Lecture 5.6 - Minimum Cost Spanning Trees (Prim_s Algorithm)_annotated.pdf (PDF file)","text":"<p>Summary Prim's algorithm is a technique used to generate a minimum cost spanning tree (MCST) from a given weighted undirected graph. An MCST is a tree that spans all vertices in the graph, and has the minimum total edge weight among all such trees. </p> <p>The algorithm incrementally grows the MCST by adding the smallest weight edge from the tree to a vertex not yet in the tree. It begins with a single vertex and expands until it includes all vertices while adhering to the MCST principles. </p> <p>The correctness of Prim's algorithm is based on the Minimum Separator Lemma, which states that every MCST must include the minimum cost edge separating two non-empty subsets of vertices. This allows the algorithm to efficiently construct the MCST by selecting the smallest weight edge at each step. </p> <p>The implementation involves tracking visited vertices, distances to the tree, and the nearest neighbor in the tree for each vertex. By continuously updating this information, the algorithm identifies the next vertex to add to the tree based on the minimum distance criterion. </p> <p>Despite its simplicity, Prim's algorithm has a complexity of O(n2), where n is the number of vertices, even with adjacency lists. This is due to the need to repeatedly scan through the unvisited vertices to find the minimum distance. More efficient algorithms exist, such as Kruskal's algorithm, which has a complexity of O(E log E), but Prim's algorithm remains a fundamental and widely used approach for constructing MCSTs. Lec file</p>"},{"location":"week5/Lecture%205.6%20-%20Minimum%20Cost%20Spanning%20Trees%20%28Prim_s%20Algorithm%29_annotated/#lecture-56-minimum-cost-spanning-trees-prim_s-algorithm_annotatedpdf-pdf-file_1","title":"Lecture 5.6 - Minimum Cost Spanning Trees (Prim_s Algorithm)_annotated.pdf (PDF file)","text":""},{"location":"week5/bellman_ford_5_3/","title":"Bellman ford 5 3","text":"<pre><code>import os\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:2.5657998776296154e-05\n</code></pre> <pre><code># Number of nodes\nnum_nodes = 8\n\n# Initialize adjacency matrix with inf (representing no connection)\nadj_matrix = np.zeros((num_nodes, num_nodes, 2))\n\n# Define the edges and their weights\nedges = [\n    (0, 1, 10),\n    (0, 7, 8),\n    (1, 5, 2),\n    (2, 1, 1),\n    (2, 3, 1),\n    (3, 4, 3),\n    (4, 5, -1),\n    (5, 2, -2),\n    (6, 1, -4),\n    (6, 5, -1),\n    (7, 6, 1),\n]\n\n# Fill the adjacency matrix with the edge weights\nfor edge in edges:\n    u, v, weight = edge\n    adj_matrix[u, v] = [1, weight]\n\n# Create a NetworkX graph\nG = nx.DiGraph()\n\n# Add edges with weights to the graph\nfor u, v, weight in edges:\n    G.add_edge(u, v, weight=weight)\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\nplt.title(\"Graph with a Negative Cycle\")\nplt.show()\n</code></pre> <pre><code>def bellmanford(Wmat, source):\n    rows, cols, x = Wmat.shape\n    connection = 0\n    weights = 1\n    infinity = np.max(Wmat) * rows + 1\n    distance = {}\n\n    for vertex in range(rows):\n        distance[vertex] = infinity\n\n    distance[source] = 0\n    for _ in range(rows):\n        for vertex in range(rows):\n            for child in range(cols):\n                if Wmat[vertex, child, connection] == 1:\n                    distance[child] = min(\n                        distance[child], distance[vertex] + Wmat[vertex, child, weight]\n                    )\n    return distance\n</code></pre> <pre><code>distance = bellmanford(adj_matrix, source=0)\n</code></pre> <pre><code>distance\n</code></pre> <pre><code>{0: 0, 1: 5.0, 2: 5.0, 3: 6.0, 4: 9.0, 5: 7.0, 6: 9.0, 7: 8.0}\n</code></pre> <pre><code>G = nx.DiGraph()\n\n# Add edges with weights to the graph\nfor i in range(num_nodes):\n    for j in range(num_nodes):\n        if adj_matrix[i, j, 0] == 1:\n            G.add_edge(i, j, weight=adj_matrix[i, j, 1])\n\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(G, pos, with_labels=True, node_color=\"lightblue\", node_size=500, font_size=10)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\n# Add the distance information to the plot\nfor node, dist in distance.items():\n    plt.annotate(\n        f\"Dist: {dist}\",\n        xy=pos[node],\n        xytext=(5, 5),\n        textcoords=\"offset points\",\n        fontsize=10,\n        color=\"red\",\n    )\n\nplt.title(\"Weighted Graph with Distances\")\nplt.show()\n</code></pre> <pre><code>distance\n</code></pre> <pre><code>{0: 0, 1: 5.0, 2: 5.0, 3: 6.0, 4: 9.0, 5: 7.0, 6: 9.0, 7: 8.0}\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/dijkstra_5_2/","title":"Dijkstra 5 2","text":"<pre><code>import os\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.2648000392800895e-05\n</code></pre> <pre><code># Define the number of nodes\nnum_nodes = 5\n\n# Create a three-dimensional adjacency matrix\n# The third dimension size 2: first for presence, second for weight\nadj_matrix = np.zeros((num_nodes, num_nodes, 2))\n\n# Define the edges and their weights\nedges = [(0, 1, 2), (0, 4, 1), (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 3, 2)]\n\n# Fill the adjacency matrix with edge presence and weights\nfor edge in edges:\n    u, v, weight = edge\n    adj_matrix[u, v] = [1, weight]\n    adj_matrix[v, u] = [1, weight]  # Assuming the graph is undirected\n\n# Create a NetworkX graph\nG = nx.Graph()\n\n# Add edges with weights to the graph\nfor i in range(num_nodes):\n    for j in range(num_nodes):\n        if adj_matrix[i, j, 0] == 1:\n            G.add_edge(i, j, weight=adj_matrix[i, j, 1])\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(G, pos, with_labels=True, node_color=\"lightblue\", node_size=500, font_size=10)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\nplt.title(\"Weighted Graph\")\nplt.show()\n</code></pre> <pre><code>adj_matrix\n</code></pre> <pre><code>array([[[0., 0.],\n        [1., 2.],\n        [0., 0.],\n        [0., 0.],\n        [1., 1.]],\n\n       [[1., 2.],\n        [0., 0.],\n        [1., 3.],\n        [1., 2.],\n        [0., 0.]],\n\n       [[0., 0.],\n        [1., 3.],\n        [0., 0.],\n        [1., 4.],\n        [0., 0.]],\n\n       [[0., 0.],\n        [1., 2.],\n        [1., 4.],\n        [0., 0.],\n        [1., 5.]],\n\n       [[1., 1.],\n        [0., 0.],\n        [0., 0.],\n        [1., 5.],\n        [0., 0.]]])\n</code></pre> <pre><code>def dijkastra(WMat, s):\n    rows, cols, x = WMat.shape\n    infinity = np.max(WMat) * rows + 1  # set the max value as infinity\n    visited, distance = {}, {}  # dict to keep track of the distance and visited\n    for vertex in range(rows):\n        visited[vertex], distance[vertex] = False, infinity\n    # starting vertex\n    distance[s] = 0\n    for u in range(rows):\n        nextd = min([distance[v] for v in range(rows) if not visited[v]])\n        nextvlist = [\n            v for v in range(rows) if (not visited[v]) and distance[v] == nextd\n        ]\n        # print(nextvlist)\n        if nextvlist == []:\n            break\n        nextv = min(nextvlist)\n        visited[nextv] = True\n        for v in range(cols):\n            if WMat[nextv, v, 0] == 1 and not visited[v]:\n                distance[v] = min(distance[v], distance[nextv] + WMat[nextv, v, 1])\n    return distance\n</code></pre> <pre><code>distance = dijkastra(WMat=adj_matrix, s=0)\n</code></pre> <pre><code>plt.show()\n</code></pre> <pre><code>G = nx.Graph()\n\n# Add edges with weights to the graph\nfor i in range(num_nodes):\n    for j in range(num_nodes):\n        if adj_matrix[i, j, 0] == 1:\n            G.add_edge(i, j, weight=adj_matrix[i, j, 1])\n\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(G, pos, with_labels=True, node_color=\"lightblue\", node_size=500, font_size=10)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\n# Add the distance information to the plot\nfor node, dist in distance.items():\n    plt.annotate(\n        f\"Dist: {dist}\",\n        xy=pos[node],\n        xytext=(5, 5),\n        textcoords=\"offset points\",\n        fontsize=10,\n        color=\"red\",\n    )\n\nplt.title(\"Weighted Graph with Distances\")\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/floyd_warshall_5_4/","title":"Floyd warshall 5 4","text":"<pre><code>import os\nimport numpy as np\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.1470001481939107e-05\n</code></pre> <pre><code>def floydwarshall(WMat):\n\n    rows, cols, x = WMat.shape\n    # transitive closure matrix\n    SP = np.full((rows, cols, cols + 1), np.inf)\n    infinity = np.max(WMat) * rows * rows + 1\n    closure = 0\n    connection = 0\n    weight = 1\n    # for vertex in range(rows):\n    #     for child in range(cols):\n    #         SP[vertex,child, closure] = infinity\n\n    for vertex in range(rows):\n        for child in range(cols):\n            if WMat[vertex, child, connection] == 1:\n                SP[vertex, child, closure] = WMat[vertex, child, weight]\n    for closure_loop in range(1, cols + 1):\n        for vertex in range(rows):\n            for child in range(cols):\n                SP[vertex, child, closure_loop] = min(\n                    SP[vertex, child, closure_loop - 1],\n                    SP[vertex, closure_loop - 1, closure_loop - 1]\n                    + SP[closure_loop - 1, child, closure_loop - 1],\n                )\n    return SP[:, :, cols]\n</code></pre> <pre><code># Number of nodes\nnum_nodes = 8\n\n# Initialize adjacency matrix with inf (representing no connection)\nadj_matrix = np.zeros((num_nodes, num_nodes, 2))\n\n# Define the edges and their weights\nedges = [\n    (0, 1, 10),\n    (0, 7, 8),\n    (1, 5, 2),\n    (2, 1, 1),\n    (2, 3, 1),\n    (3, 4, 3),\n    (4, 5, -1),\n    (5, 2, -2),\n    (6, 1, -4),\n    (6, 5, -1),\n    (7, 6, 1),\n]\n\n# Fill the adjacency matrix with the edge weights\nfor edge in edges:\n    u, v, weight = edge\n    adj_matrix[u, v] = [1, weight]\n\n# Create a NetworkX graph\nG = nx.DiGraph()\n\n# Add edges with weights to the graph\nfor u, v, weight in edges:\n    G.add_edge(u, v, weight=weight)\n\n# Draw the graph\npos = nx.spring_layout(G)  # Positions for all nodes\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\n\n# Draw edge labels\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n\nplt.title(\"Graph with a Negative Cycle\")\nplt.show()\n</code></pre> <pre><code>distance = floydwarshall(adj_matrix)\n</code></pre> <pre><code>distance\n</code></pre> <pre><code>array([[inf,  5.,  5.,  6.,  9.,  7.,  9.,  8.],\n       [inf,  1.,  0.,  1.,  4.,  2., inf, inf],\n       [inf,  1.,  1.,  1.,  4.,  3., inf, inf],\n       [inf,  1.,  0.,  1.,  3.,  2., inf, inf],\n       [inf, -2., -3., -2.,  1., -1., inf, inf],\n       [inf, -1., -2., -1.,  2.,  1., inf, inf],\n       [inf, -4., -4., -3.,  0., -2., inf, inf],\n       [inf, -3., -3., -2.,  1., -1.,  1., inf]])\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/kruskal/","title":"Kruskal","text":"<pre><code>import os\nimport numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.8425998860038817e-05\n</code></pre> <pre><code>def kruskal(adj_list):\n    \"\"\"\n    Implements Kruskal's algorithm to find the Minimum Spanning Tree (MST) of a graph.\n\n    Args:\n    adj_list (dict): A dictionary representing the adjacency list of the graph.\n\n    Returns:\n    list: A list of tuples representing the edges in the MST.\n    \"\"\"\n    edges = []\n    component = {}\n    mst_edges = []\n\n    # Convert adjacency list to a list of edges with weights\n    for node in adj_list.keys():\n        # Weight as the first component to sort easily\n        edges.extend(\n            [(weight, node, neighbor) for (neighbor, weight) in adj_list[node]]\n        )\n        component[node] = node\n\n    # Sort edges by weight\n    edges.sort()\n\n    # Iterate over sorted edges and construct MST\n    for weight, u, v in edges:\n        if component[u] != component[v]:\n            mst_edges.append((u, v))\n            old_component = component[u]\n            new_component = component[v]\n            for node in component.keys():\n                if component[node] == old_component:\n                    component[node] = new_component\n\n    return mst_edges\n</code></pre> <p>Certainly! Let's enhance your <code>kruskal</code> function by renaming the variables for better readability, formatting the code properly, adding comments for clarity, and providing a description. We'll also include the necessary functions to plot the original graph and the MST generated by Kruskal's algorithm.</p>"},{"location":"week5/kruskal/#enhanced-kruskal-function","title":"Enhanced <code>kruskal</code> Function","text":""},{"location":"week5/kruskal/#explanation-of-the-enhanced-code","title":"Explanation of the Enhanced Code:","text":"<ol> <li> <p>Function <code>kruskal</code>:</p> <ul> <li><code>adj_list</code>: The adjacency list of the graph.</li> <li><code>edges</code>: A list to store all edges with their weights.</li> <li><code>component</code>: A dictionary to track the component (connected component) of each node.</li> <li><code>mst_edges</code>: A list to store the edges of the Minimum Spanning Tree (MST).</li> <li>Converts the adjacency list to a list of edges with weights.</li> <li>Sorts the edges by weight.</li> <li>Iterates over the sorted edges to construct the MST, using the component dictionary to avoid cycles.</li> <li>Returns the list of MST edges.</li> </ul> </li> <li> <p>Graph Construction and Plotting:</p> <ul> <li>Constructs the original graph and MST using NetworkX.</li> <li>Plots the original graph and MST side-by-side with labeled nodes and edge weights using Matplotlib and NetworkX.</li> </ul> </li> </ol>"},{"location":"week5/kruskal/#output","title":"Output:","text":"<ul> <li>The code prints the edges in the MST.</li> <li>It displays two plots: the original graph and the Minimum Spanning Tree (MST).</li> </ul> <pre><code># Example usage\nweighted_adj_list = {\n    0: [(1, 10), (7, 8)],\n    1: [(0, 10), (2, 1), (5, 2)],\n    2: [(1, 1), (3, 1), (5, -2), (2, -4)],\n    3: [(2, 1), (4, 3)],\n    4: [(3, 3), (5, -1)],\n    5: [(4, -1), (6, -1), (2, -2)],\n    6: [(5, -1), (7, 1)],\n    7: [(6, 1), (0, 8)],\n}\n\nmst_edges = kruskal(weighted_adj_list)\nprint(\"MST Edges:\", mst_edges)\n</code></pre> <pre><code>MST Edges: [(2, 5), (4, 5), (5, 6), (1, 2), (2, 3), (6, 7), (0, 7)]\n</code></pre> <pre><code># Create a NetworkX graph for the original graph\nG = nx.DiGraph()\nfor u in weighted_adj_list.keys():\n    for v, weight in weighted_adj_list[u]:\n        G.add_edge(u, v, weight=weight)\n\n# Create a NetworkX graph for the MST\nMST = nx.Graph()\nfor u, v in mst_edges:\n    for neighbor, weight in weighted_adj_list[u]:\n        if neighbor == v:\n            MST.add_edge(u, v, weight=weight)\n            break\n\n# Plot the original graph\npos = nx.spring_layout(G)  # Positions for all nodes\nplt.figure(figsize=(12, 6))\n\nplt.subplot(121)\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\nplt.title(\"Original Graph\")\n\n# Plot the Minimum Spanning Tree\nplt.subplot(122)\nnx.draw(\n    MST, pos, with_labels=True, node_color=\"lightgreen\", node_size=500, font_size=10\n)\nmst_edge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in MST.edges(data=True)}\nnx.draw_networkx_edge_labels(MST, pos, edge_labels=mst_edge_labels, font_size=10)\nplt.title(\"Minimum Spanning Tree\")\n\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"week5/prims/","title":"Prims","text":"<pre><code>import os\nimport numpy as np\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nos.chdir(\"..\")\nos.chdir(\"..\")\nfrom driver_folder.time_driver import TimerError\n</code></pre> <pre><code>T = TimerError()\nT.start()\nend_time = T.elapsed()\nprint(f\"time taken:{end_time}\")\n</code></pre> <pre><code>time taken:1.317600253969431e-05\n</code></pre> <pre><code>def primlist(weighted_adj_list):\n    # Initialize the infinity value to a number greater than any edge weight\n    infinity = 1 + max(\n        [\n            weight\n            for u in weighted_adj_list.keys()\n            for (v, weight) in weighted_adj_list[u]\n        ]\n    )\n\n    # Initialize the visited dictionary to keep track of visited nodes\n    # Initialize the distance dictionary to store the minimum distance to each node\n    # Initialize the list to store the edges of the Minimum Spanning Tree (MST)\n    visited = {}\n    min_distance = {}\n    mst_edges = []\n\n    # Set all nodes as not visited and their initial distances to infinity\n    for node in weighted_adj_list.keys():\n        visited[node] = False\n        min_distance[node] = infinity\n\n    # Start with the first node (node 0)\n    visited[0] = True\n\n    # Update the distances for the adjacent nodes of node 0\n    for neighbor, weight in weighted_adj_list[0]:\n        min_distance[neighbor] = weight\n\n    # Loop to find the minimum distance edge connecting a visited node to an unvisited node\n    for _ in range(len(weighted_adj_list) - 1):\n        min_edge_weight = infinity\n        next_node = None\n        next_edge = None\n\n        # Find the minimum weight edge from the visited set to the unvisited set\n        for current_node in weighted_adj_list.keys():\n            for neighbor, weight in weighted_adj_list[current_node]:\n                if (\n                    visited[current_node]\n                    and not visited[neighbor]\n                    and weight &lt; min_edge_weight\n                ):\n                    min_edge_weight = weight\n                    next_node = neighbor\n                    next_edge = (current_node, neighbor)\n\n        # If no next node is found, the graph is disconnected\n        if next_node is None:\n            break\n\n        # Mark the next node as visited and add the edge to the MST\n        visited[next_node] = True\n        mst_edges.append(next_edge)\n\n        # Update the distances for the adjacent nodes of the newly visited node\n        for neighbor, weight in weighted_adj_list[next_node]:\n            if not visited[neighbor]:\n                min_distance[neighbor] = min(min_distance[neighbor], weight)\n\n    return mst_edges\n</code></pre>"},{"location":"week5/prims/#explanation","title":"Explanation:","text":"<ol> <li>Define the Three-Dimensional Array:</li> <li><code>adj_matrix</code> is a 3D NumPy array of shape <code>(num_nodes, num_nodes, 2)</code>.</li> <li> <p>The third dimension stores two values: <code>[presence, weight]</code>, where <code>presence</code> indicates the existence of an edge (1 for present, 0 for not present), and <code>weight</code> is the weight of the edge.</p> </li> <li> <p>Populate the Adjacency Matrix:</p> </li> <li> <p>For each edge, the matrix at position <code>[u, v]</code> is updated with the presence set to <code>1</code> and the weight.</p> </li> <li> <p>Create and Draw the Graph:</p> </li> <li>We use <code>nx.DiGraph()</code> to create a directed graph, which is important for handling negative cycles.</li> <li>Edges are added to the graph and it is drawn using NetworkX and Matplotlib.</li> <li> <p>The <code>spring_layout</code> is used for positioning the nodes.</p> </li> <li> <p>Detect Negative Cycle:</p> </li> <li>Using NetworkX's <code>find_negative_cycle</code> method (available from NetworkX version 2.6), we can detect and print any negative cycle present in the graph. If your NetworkX version does not support this method, you may need to implement a custom function or upgrade to a newer version.</li> </ol> <pre><code>weighted_adj_list = {\n    0: [(1, 10), (7, 8)],\n    1: [(0, 10), (2, 1), (5, 2)],\n    2: [(1, 1), (3, 1), (5, -2), (2, -4)],\n    3: [(2, 1), (4, 3)],\n    4: [(3, 3), (5, -1)],\n    5: [(4, -1), (6, -1), (2, -2)],\n    6: [(5, -1), (7, 1)],\n    7: [(6, 1), (0, 8)],\n}\n\nmst_edges = primlist(weighted_adj_list)\nprint(\"Minimum Spanning Tree Edges:\", mst_edges)\n</code></pre> <pre><code>Minimum Spanning Tree Edges: [(0, 7), (7, 6), (6, 5), (5, 2), (5, 4), (2, 1), (2, 3)]\n</code></pre> <pre><code># Create a NetworkX graph for the original graph\nG = nx.DiGraph()\nfor u in weighted_adj_list.keys():\n    for v, weight in weighted_adj_list[u]:\n        G.add_edge(u, v, weight=weight)\n\n# Create a NetworkX graph for the MST\nMST = nx.DiGraph()\nfor u, v in mst_edges:\n    for x, weight in weighted_adj_list[u]:\n        if x == v:\n            MST.add_edge(u, v, weight=weight)\n\n# Plot the original graph\npos = nx.spring_layout(G)  # Positions for all nodes\nplt.figure(figsize=(12, 6))\n\nplt.subplot(121)\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\nplt.title(\"Original Graph\")\n\n# Plot the Minimum Spanning Tree\nplt.subplot(122)\nnx.draw(\n    MST,\n    pos,\n    with_labels=True,\n    node_color=\"lightgreen\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nmst_edge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in MST.edges(data=True)}\nnx.draw_networkx_edge_labels(MST, pos, edge_labels=mst_edge_labels, font_size=10)\nplt.title(\"Minimum Spanning Tree\")\n\nplt.show()\n</code></pre> <p></p> <pre><code>def prim_mst(adj_list):\n\n    # Define infinity as a value larger than any edge weight\n    infinity = 1 + max(\n        [weight for node in adj_list.keys() for (neighbor, weight) in adj_list[node]]\n    )\n\n    # Initialize dictionaries to keep track of visited nodes, minimum distances, and parent nodes\n    visited = {}\n    min_distance = {}\n    parent = {}\n\n    # Set all nodes as not visited, their distances to infinity, and their parent to -1\n    for node in adj_list.keys():\n        visited[node] = False\n        min_distance[node] = infinity\n        parent[node] = -1\n\n    # Start with the first node (node 0)\n    visited[0] = True\n\n    # Update the distances and parents for the adjacent nodes of node 0\n    for neighbor, weight in adj_list[0]:\n        min_distance[neighbor] = weight\n        parent[neighbor] = 0\n\n    # Loop to find the minimum distance edge connecting a visited node to an unvisited node\n    for _ in range(1, len(adj_list.keys())):\n        # Find the smallest distance among the unvisited nodes\n        next_distance = min(\n            [min_distance[node] for node in adj_list.keys() if not visited[node]]\n        )\n        next_node_candidates = [\n            node\n            for node in adj_list.keys()\n            if not visited[node] and min_distance[node] == next_distance\n        ]\n\n        if not next_node_candidates:\n            break\n\n        # Choose the node with the smallest index among the candidates\n        next_node = min(next_node_candidates)\n        visited[next_node] = True\n\n        # Update the distances and parents for the adjacent nodes of the newly visited node\n        for neighbor, weight in adj_list[next_node]:\n            if not visited[neighbor] and weight &lt; min_distance[neighbor]:\n                min_distance[neighbor] = weight\n                parent[neighbor] = next_node\n\n    return parent\n</code></pre> <pre><code># Example usage\nweighted_adj_list = {\n    0: [(1, 10), (7, 8)],\n    1: [(0, 10), (2, 1), (5, 2)],\n    2: [(1, 1), (3, 1), (5, -2), (2, -4)],\n    3: [(2, 1), (4, 3)],\n    4: [(3, 3), (5, -1)],\n    5: [(4, -1), (6, -1), (2, -2)],\n    6: [(5, -1), (7, 1)],\n    7: [(6, 1), (0, 8)],\n}\n\nmst_parents = prim_mst(weighted_adj_list)\nprint(\"Parent nodes in MST:\", mst_parents)\n</code></pre> <pre><code>Parent nodes in MST: {0: -1, 1: 2, 2: 5, 3: 2, 4: 5, 5: 6, 6: 7, 7: 0}\n</code></pre> <pre><code>def create_mst_edges(parents):\n    \"\"\"\n    Creates a list of edges for the Minimum Spanning Tree (MST) from the parent node dictionary.\n\n    Args:\n    parents (dict): A dictionary where keys are nodes and values are their respective parent nodes in the MST.\n\n    Returns:\n    list: A list of tuples representing the edges in the MST.\n    \"\"\"\n    mst_edges = []\n    for child, parent in parents.items():\n        if parent != -1:\n            mst_edges.append((parent, child))\n    return mst_edges\n</code></pre> <pre><code>mst_edges = create_mst_edges(mst_parents)\nprint(\"MST Edges:\", mst_edges)\n\n# Create a NetworkX graph for the original graph\nG = nx.DiGraph()\nfor u in weighted_adj_list.keys():\n    for v, weight in weighted_adj_list[u]:\n        G.add_edge(u, v, weight=weight)\n\n# Create a NetworkX graph for the MST\nMST = nx.DiGraph()\nfor u, v in mst_edges:\n    for x, weight in weighted_adj_list[u]:\n        if x == v:\n            MST.add_edge(u, v, weight=weight)\n\n# Plot the original graph\npos = nx.spring_layout(G)  # Positions for all nodes\nplt.figure(figsize=(12, 6))\n\nplt.subplot(121)\nnx.draw(\n    G,\n    pos,\n    with_labels=True,\n    node_color=\"lightblue\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nedge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in G.edges(data=True)}\nnx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\nplt.title(\"Original Graph\")\n\n# Plot the Minimum Spanning Tree\nplt.subplot(122)\nnx.draw(\n    MST,\n    pos,\n    with_labels=True,\n    node_color=\"lightgreen\",\n    node_size=500,\n    font_size=10,\n    arrows=True,\n)\nmst_edge_labels = {(u, v): f'{d[\"weight\"]:.0f}' for u, v, d in MST.edges(data=True)}\nnx.draw_networkx_edge_labels(MST, pos, edge_labels=mst_edge_labels, font_size=10)\nplt.title(\"Minimum Spanning Tree\")\n\nplt.show()\n</code></pre> <pre><code>MST Edges: [(2, 1), (5, 2), (2, 3), (5, 4), (6, 5), (7, 6), (0, 7)]\n</code></pre> <p></p>"},{"location":"week5/prims/#explanation-of-the-updated-code","title":"Explanation of the Updated Code:","text":"<ol> <li>Function <code>prim_mst</code>:</li> <li><code>adj_list</code>: The adjacency list of the graph.</li> <li><code>infinity</code>: A large value greater than any edge weight.</li> <li><code>visited</code>: A dictionary to keep track of visited nodes.</li> <li><code>min_distance</code>: A dictionary to store the minimum distance from the MST to each node.</li> <li><code>parent</code>: A dictionary to store the parent node of each node in the MST.</li> <li>Initializes all nodes as not visited, sets their distances to infinity, and parents to -1.</li> <li>Starts with node <code>0</code>, marks it as visited, and updates distances and parents for its neighbors.</li> <li>Finds the minimum distance edge connecting a visited node to an unvisited node, updates distances and parents.</li> <li> <p>Returns the <code>parent</code> dictionary representing the parent of each node in the MST.</p> </li> <li> <p>Function <code>create_mst_edges</code>:</p> </li> <li><code>parents</code>: The parent dictionary returned by <code>prim_mst</code>.</li> <li>Constructs the MST edges using the parent dictionary.</li> <li> <p>Returns a list of MST edges.</p> </li> <li> <p>Graph Construction and Plotting:</p> </li> <li>Constructs the original graph and MST using NetworkX.</li> <li>Plots the original graph and MST side-by-side with labeled nodes and edge weights using Matplotlib and NetworkX.</li> </ol>"},{"location":"week5/prims/#output","title":"Output:","text":"<ul> <li>The code prints the parent nodes in the MST and the edges in the MST.</li> <li>It displays two plots: the original graph and the Minimum Spanning Tree (MST).</li> </ul>"}]}